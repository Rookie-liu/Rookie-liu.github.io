<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>隐私权政策</title>
    <url>/2018/10/25/privacyagreement/</url>
    <content><![CDATA[<h2 id="隐私权政策"><a href="#隐私权政策" class="headerlink" title="隐私权政策"></a>隐私权政策</h2><p>2019年10月8日</p>
<p>青岛小茗科技有限公司（以下简称“我们”）深知个人信息对您的重要性，并会尽全力保护您的个人信息安全可靠。我们致力于维持您对我们的信任，恪守以下原则，保护您的个人信息：权责一致原则、目的明确原则、选择同意原则、最少够用原则、确保安全原则、主体参与原则、公开透明原则等。同时，我们承诺，我们将按业界成熟的安全标准，采取相应的安全保护措施来保护您的个人信息。</p>
<p>请在使用我们的产品（或服务）前，仔细阅读并了解本《隐私权政策》。</p>
<a id="more"></a>


<h3 id="一、我们如何收集和使用您的个人信息"><a href="#一、我们如何收集和使用您的个人信息" class="headerlink" title="一、我们如何收集和使用您的个人信息"></a>一、我们如何收集和使用您的个人信息</h3><p>个人信息是指以电子或者其他方式记录的能够单独或者与其他信息结合识别特定自然人身份或者反映特定自然人活动情况的各种信息。<br>我们仅会出于本政策所述的以下目的，收集和使用您的个人信息：</p>
<p>我们仅会出于本政策所述的以下目的，收集和使用您的个人信息：<br>####（一）可能为您提供网上购物服务</p>
<h4 id="1、业务功能一：注册成为用户"><a href="#1、业务功能一：注册成为用户" class="headerlink" title="1、业务功能一：注册成为用户"></a>1、业务功能一：注册成为用户</h4><p>为完成创建账号，您需提供以下信息：您的姓名、电子邮箱地址、创建的用户名和密码<br>在注册过程中，如果您提供以下额外信息，将有助于我们给您提供更好的服务和体验：手机号、工作职位、公司、教育背景、……。但如果您不提供这些信息，将不会影响使用本服务的基本功能。<br>您提供的上述信息，将在您使用本服务期间持续授权我们使用。在您注销账号时，我们将停止使用并删除上述信息。<br>上述信息将存储于中华人民共和国境内。如需跨境传输，我们将会单独征得您的授权同意。</p>
<h4 id="2、业务功能二：商品展示、个性化推荐、发送促销营销信息。"><a href="#2、业务功能二：商品展示、个性化推荐、发送促销营销信息。" class="headerlink" title="2、业务功能二：商品展示、个性化推荐、发送促销营销信息。"></a>2、业务功能二：商品展示、个性化推荐、发送促销营销信息。</h4><h4 id="（二）开展内部数据分析和研究，第三方SDK统计服务，改善我们的产品或服务【注：示例】"><a href="#（二）开展内部数据分析和研究，第三方SDK统计服务，改善我们的产品或服务【注：示例】" class="headerlink" title="（二）开展内部数据分析和研究，第三方SDK统计服务，改善我们的产品或服务【注：示例】"></a>（二）开展内部数据分析和研究，第三方SDK统计服务，改善我们的产品或服务【注：示例】</h4><p>我们收集数据是根据您与我们的互动和您所做出的选择，包括您的隐私设置以及您使用的产品和功能。我们收集的数据可能包括SDK/API/JS代码版本、浏览器、互联网服务提供商、IP地址、平台、时间戳、应用标识符、应用程序版本、应用分发渠道、独立设备标识符、iOS广告标识符（IDFA)、安卓广告主标识符、网卡（MAC）地址、国际移动设备识别码（IMEI）、设备型号、终端制造厂商、终端设备操作系统版本、会话启动/停止时间、语言所在地、时区和网络状态（WiFi等）、硬盘、CPU和电池使用情况等。</p>
<blockquote>
<p>当我们要将信息用于本策略未载明的其它用途时，会事先征求您的同意。<br>当我们要将基于特定目的收集而来的信息用于其他目的时，会事先征求您的同意</p>
</blockquote>
<h3 id="二、我们如何使用-Cookie-和同类技术"><a href="#二、我们如何使用-Cookie-和同类技术" class="headerlink" title="二、我们如何使用 Cookie 和同类技术"></a>二、我们如何使用 Cookie 和同类技术</h3><h4 id="（一）Cookie"><a href="#（一）Cookie" class="headerlink" title="（一）Cookie"></a>（一）Cookie</h4><p>为确保网站正常运转，我们会在您的计算机或移动设备上存储名为 Cookie 的小数据文件。Cookie 通常包含标识符、站点名称以及一些号码和字符。借助于 Cookie，网站能够存储您的偏好或购物篮内的商品等数据。<br>我们不会将 Cookie 用于本政策所述目的之外的任何用途。您可根据自己的偏好管理或删除 Cookie。您可以清除计算机上保存的所有 Cookie，大部分网络浏览器都设有阻止 Cookie 的功能。但如果您这么做，则需要在每一次访问我们的网站时亲自更改用户设置。</p>
<h4 id="（二）网站信标和像素标签"><a href="#（二）网站信标和像素标签" class="headerlink" title="（二）网站信标和像素标签"></a>（二）网站信标和像素标签</h4><p>除 Cookie 外，我们还会在网站上使用网站信标和像素标签等其他同类技术。例如，我们向您发送的电子邮件可能含有链接至我们网站内容的点击 URL。如果您点击该链接，我们则会跟踪此次点击，帮助我们了解您的产品或服务偏好并改善客户服务。网站信标通常是一种嵌入到网站或电子邮件中的透明图像。借助于电子邮件中的像素标签，我们能够获知电子邮件是否被打开。如果您不希望自己的活动以这种方式被追踪，则可以随时从我们的寄信名单中退订。</p>
<h4 id="（三）Do-Not-Track（请勿追踪）"><a href="#（三）Do-Not-Track（请勿追踪）" class="headerlink" title="（三）Do Not Track（请勿追踪）"></a>（三）Do Not Track（请勿追踪）</h4><p>很多网络浏览器均设有 Do Not Track 功能，该功能可向网站发布 Do Not Track 请求。目前，主要互联网标准组织尚未设立相关政策来规定网站应如何应对此类请求。但如果您的浏览器启用了 Do Not Track，那么我们的所有网站都会尊重您的选择。</p>
<h3 id="三、我们如何共享、转让、公开披露您的个人信息"><a href="#三、我们如何共享、转让、公开披露您的个人信息" class="headerlink" title="三、我们如何共享、转让、公开披露您的个人信息"></a>三、我们如何共享、转让、公开披露您的个人信息</h3><h4 id="（一）共享"><a href="#（一）共享" class="headerlink" title="（一）共享"></a>（一）共享</h4><p>我们不会向其他任何公司、组织和个人分享您的个人信息，但以下情况除外：<br>1、在获取明确同意的情况下共享：获得您的明确同意后，我们会与其他方共享您的个人信息。<br>2、我们可能会根据法律法规规定，或按政府主管部门的强制性要求，对外共享您的个人信息。<br>3、与我们的关联公司共享：您的个人信息可能会与我们关联公司共享。我们只会共享必要的个人信息，且受本隐私政策中所声明目的的约束。关联公司如要改变个人信息的处理目的，将再次征求您的授权同意。<br>4、与授权合作伙伴共享：仅为实现本隐私权政策中声明的目的，我们的某些服务将由授权合作伙伴提供。我们可能会与合作伙伴共享您的某些个人信息，以提供更好的客户服务和用户体验。。我们仅会出于合法、正当、必要、特定、明确的目的共享您的个人信息，并且只会共享提供服务所必要的个人信息。</p>
<p>对我们与之共享个人信息的公司、组织和个人，我们会与其签署严格的保密协定，要求他们按照我们的说明、本隐私政策以及其他任何相关的保密和安全措施来处理个人信息</p>
<h4 id="（二）转让"><a href="#（二）转让" class="headerlink" title="（二）转让"></a>（二）转让</h4><p>我们不会将您的个人信息转让给任何公司、组织和个人，但以下情况除外：<br>1、在获取明确同意的情况下转让：获得您的明确同意后，我们会向其他方转让您的个人信息；<br>2、在涉及合并、收购或破产清算时，如涉及到个人信息转让，我们会在要求新的持有您个人信息的公司、组织继续受此隐私政策的约束，否则我们将要求该公司、组织重新向您征求授权同意。</p>
<h4 id="（三）公开披露"><a href="#（三）公开披露" class="headerlink" title="（三）公开披露"></a>（三）公开披露</h4><p>我们仅会在以下情况下，公开披露您的个人信息：<br>1、获得您明确同意后；<br>2、基于法律的披露：在法律、法律程序、诉讼或政府主管部门强制性要求的情况下，我们可能会公开披露您的个人信息。</p>
<h3 id="四、我们如何保护您的个人信息"><a href="#四、我们如何保护您的个人信息" class="headerlink" title="四、我们如何保护您的个人信息"></a>四、我们如何保护您的个人信息</h3><p>（一）我们已使用符合业界标准的安全防护措施保护您提供的个人信息，防止数据遭到未经授权访问、公开披露、使用、修改、损坏或丢失。我们会采取一切合理可行的措施，保护您的个人信息。例如，在您的浏览器与“服务”之间交换数据（如信用卡信息）时受 SSL 加密保护；我们同时对我们网站提供 https 安全浏览方式；我们会使用加密技术确保数据的保密性；我们会使用受信赖的保护机制防止数据遭到恶意攻击；我们会部署访问控制机制，确保只有授权人员才可访问个人信息；以及我们会举办安全和隐私保护培训课程，加强员工对于保护个人信息重要性的认识。</p>
<p>（二）我们会采取一切合理可行的措施，确保未收集无关的个人信息。我们只会在达成本政策所述目的所需的期限内保留您的个人信息，除非需要延长保留期或受到法律的允许。</p>
<p>（三）互联网并非绝对安全的环境，而且电子邮件、即时通讯、及与其他我们用户的交流方式并未加密，我们强烈建议您不要通过此类方式发送个人信息。请使用复杂密码，协助我们保证您的账号安全。</p>
<p>（四）互联网环境并非百分之百安全，我们将尽力确保或担保您发送给我们的任何信息的安全性。如果我们的物理、技术、或管理防护设施遭到破坏，导致信息被非授权访问、公开披露、篡改、或毁坏，导致您的合法权益受损，我们将承担相应的法律责任。</p>
<p>（五）在不幸发生个人信息安全事件后，我们将按照法律法规的要求，及时向您告知：安全事件的基本情况和可能的影响、我们已采取或将要采取的处置措施、您可自主防范和降低风险的建议、对您的补救措施等。我们将及时将事件相关情况以邮件、信函、电话、推送通知等方式告知您，难以逐一告知个人信息主体时，我们会采取合理、有效的方式发布公告。</p>
<p>同时，我们还将按照监管部门要求，主动上报个人信息安全事件的处置情况。</p>
<p>###五、您的权利<br>按照中国相关的法律、法规、标准，以及其他国家、地区的通行做法，我们保障您对自己的个人信息行使以下权利：<br>####（一）访问您的个人信息<br>您有权访问您的个人信息，法律法规规定的例外情况除外。如果您想行使数据访问权，可以通过以下方式自行访问：</p>
<p>账户信息——如果您希望访问或编辑您的账户中的个人资料信息和支付信息、更改您的密码、添加安全信息或关闭您的账户等。</p>
<p>如果您无法通过上述链接访问这些个人信息，您可以随时使用我们的 Web 表单联系，或发送电子邮件至<a href="mailto:rookie_liu@126.com" target="_blank" rel="noopener">rookie_liu@126.com</a>。我们将在30天内回复您的访问请求。<br>对于您在使用我们的产品或服务过程中产生的其他个人信息，只要我们不需要过多投入，我们会向您提供。如果您想行使数据访问权，请发送电子邮件至<a href="mailto:rookie_liu@126.com" target="_blank" rel="noopener">rookie_liu@126.com</a>。</p>
<h4 id="（二）更正您的个人信息"><a href="#（二）更正您的个人信息" class="headerlink" title="（二）更正您的个人信息"></a>（二）更正您的个人信息</h4><p>当您发现我们处理的关于您的个人信息有错误时，您有权要求我们做出更正。您可以通过“（一）访问您的个人信息”中罗列的方式提出更正申请。<br>如果您无法通过上述链接更正这些个人信息，您可以随时使用我们的 Web 表单联系，或发送电子邮件至<a href="mailto:rookie_liu@126.com" target="_blank" rel="noopener">rookie_liu@126.com</a>。我们将在30天内回复您的更正请求。</p>
<h4 id="（三）删除您的个人信息"><a href="#（三）删除您的个人信息" class="headerlink" title="（三）删除您的个人信息"></a>（三）删除您的个人信息</h4><p>在以下情形中，您可以向我们提出删除个人信息的请求：<br>1、如果我们处理个人信息的行为违反法律法规；<br>2、如果我们收集、使用您的个人信息，却未征得您的同意；<br>3、如果我们处理个人信息的行为违反了与您的约定；<br>4、如果您不再使用我们的产品或服务，或您注销了账号；<br>5、如果我们不再为您提供产品或服务。<br>若我们决定响应您的删除请求，我们还将同时通知从我们获得您的个人信息的实体，要求其及时删除，除非法律法规另有规定，或这些实体获得您的独立授权。</p>
<p>当您从我们的服务中删除信息后，我们可能不会立即备份系统中删除相应的信息，但会在备份更新时删除这些信息。</p>
<h4 id="（四）改变您授权同意的范围"><a href="#（四）改变您授权同意的范围" class="headerlink" title="（四）改变您授权同意的范围"></a>（四）改变您授权同意的范围</h4><p>每个业务功能需要一些基本的个人信息才能得以完成（见本策略“第一部分”）。对于额外收集的个人信息的收集和使用，您可以随时给予或收回您的授权同意。</p>
<p>当您收回同意后，我们将不再处理相应的个人信息。但您收回同意的决定，不会影响此前基于您的授权而开展的个人信息处理。</p>
<h4 id="（五）个人信息主体注销账户"><a href="#（五）个人信息主体注销账户" class="headerlink" title="（五）个人信息主体注销账户"></a>（五）个人信息主体注销账户</h4><p>您随时可注销此前注册的账户</p>
<p>在注销账户之后，我们将停止为您提供产品或服务，并依据您的要求，删除您的个人信息，法律法规另有规定的除外。</p>
<h4 id="（六）个人信息主体获取个人信息副本"><a href="#（六）个人信息主体获取个人信息副本" class="headerlink" title="（六）个人信息主体获取个人信息副本"></a>（六）个人信息主体获取个人信息副本</h4><p>您有权获取您的个人信息副本，在技术可行的前提下，例如数据接口匹配，我们还可按您的要求，直接将您的个人信息副本传输给您指定的第三方。</p>
<h4 id="（七）约束信息系统自动决策"><a href="#（七）约束信息系统自动决策" class="headerlink" title="（七）约束信息系统自动决策"></a>（七）约束信息系统自动决策</h4><p>在某些业务功能中，我们可能仅依据信息系统、算法等在内的非人工自动决策机制做出决定。如果这些决定显著影响您的合法权益，您有权要求我们做出解释，我们也将提供适当的救济方式。</p>
<h4 id="（八）响应您的上述请求"><a href="#（八）响应您的上述请求" class="headerlink" title="（八）响应您的上述请求"></a>（八）响应您的上述请求</h4><p>为保障安全，您可能需要提供书面请求，或以其他方式证明您的身份。我们可能会先要求您验证自己的身份，然后再处理您的请求。<br>我们将在三十天内做出答复。</p>
<p>对于您合理的请求，我们原则上不收取费用，但对多次重复、超出合理限度的请求，我们将视情收取一定成本费用。对于那些无端重复、需要过多技术手段（例如，需要开发新系统或从根本上改变现行惯例）、给他人合法权益带来风险或者非常不切实际（例如，涉及备份磁带上存放的信息）的请求，我们可能会予以拒绝。</p>
<p>在以下情形中，按照法律法规要求，我们将无法响应您的请求：<br>1、与国家安全、国防安全有关的；<br>2、与公共安全、公共卫生、重大公共利益有关的；<br>3、与犯罪侦查、起诉和审判等有关的；<br>4、有充分证据表明您存在主观恶意或滥用权利的；<br>5、响应您的请求将导致您或其他个人、组织的合法权益受到严重损害的。</p>
<h3 id="六、我们如何处理儿童的个人信息"><a href="#六、我们如何处理儿童的个人信息" class="headerlink" title="六、我们如何处理儿童的个人信息"></a>六、我们如何处理儿童的个人信息</h3><p>我们的产品、网站和服务主要面向成人。如果没有父母或监护人的同意，儿童不得创建自己的用户账户。<br>对于经父母同意而收集儿童个人信息的情况，我们只会在受到法律允许、父母或监护人明确同意或者保护儿童所必要的情况下使用或公开披露此信息。<br>尽管当地法律和习俗对儿童的定义不同，但我们将不满 14 周岁的任何人均视为儿童。<br>如果我们发现自己在未事先获得可证实的父母同意的情况下收集了儿童的个人信息，则会设法尽快删除相关数据。</p>
<h3 id="七、您的个人信息如何在全球范围转移"><a href="#七、您的个人信息如何在全球范围转移" class="headerlink" title="七、您的个人信息如何在全球范围转移"></a>七、您的个人信息如何在全球范围转移</h3><p>原则上，我们在中华人民共和国境内收集和产生的个人信息，将存储在中华人民共和国境内。<br>由于我们通过遍布全球的资源和服务器提供产品或服务，这意味着，在获得您的授权同意后，您的个人信息可能会被转移到您使用产品或服务所在国家/地区的境外管辖区，或者受到来自这些管辖区的访问。<br>此类管辖区可能设有不同的数据保护法，甚至未设立相关法律。在此类情况下，我们会确保您的个人信息得到在中华人民共和国境内足够同等的保护。例如，我们会请求您对跨境转移个人信息的同意，或者在跨境数据转移之前实施数据去标识化等安全举措。</p>
<h3 id="八、本隐私权政策如何更新"><a href="#八、本隐私权政策如何更新" class="headerlink" title="八、本隐私权政策如何更新"></a>八、本隐私权政策如何更新</h3><p>我们可能适时会对本隐私权政策进行调整或变更，本隐私权政策的任何更新将以标注更新时间的方式公布在我们网站上，除法律法规或监管规定另有强制性规定外，经调整或变更的内容一经通知或公布后的7日后生效。如您在隐私权政策调整或变更后继续使用我们提供的任一服务或访问我们相关网站的，我们相信这代表您已充分阅读、理解并接受修改后的隐私权政策并受其约束。</p>
<h3 id="九、如何联系我们"><a href="#九、如何联系我们" class="headerlink" title="九、如何联系我们"></a>九、如何联系我们</h3><p>如果您对本隐私政策有任何疑问、意见或建议，通过以下方式与我们联系：<br>邮箱：<a href="mailto:rookie_liu@126.com" target="_blank" rel="noopener">rookie_liu@126.com</a><br>一般情况下，我们将在三十天内回复。</p>
]]></content>
      <categories>
        <category>Apple</category>
      </categories>
      <tags>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle各种版本下载</title>
    <url>/2018/05/11/gradleDown/</url>
    <content><![CDATA[<h3 id="来气"><a href="#来气" class="headerlink" title="来气"></a>来气</h3><blockquote>
<p>经常缺少gradle包. 今天网络极佳,各种all版本都down下来. 自取自用, csdn 下载一个还需要积分, 要不要脸了还.</p>
</blockquote>
<a id="more"></a>

<h3 id="官方地址"><a href="#官方地址" class="headerlink" title="官方地址"></a>官方地址</h3><p><a href="https://services.gradle.org/distributions/" target="_blank" rel="noopener">官方下载gradel地址</a></p>
<p>不翻墙不能下载司机</p>
<h3 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h3><p>百度网盘下载速度慢 , 怎么办 ?<br><a href="https://github.com/CodeTips/BaiduNetdiskPlugin-macOS" target="_blank" rel="noopener">For macOS.百度网盘 破解SVIP、下载速度限制~</a></p>
<h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><a href="https://pan.baidu.com/s/1oO_ruY0LjTUCO1kF8FjebQ" target="_blank" rel="noopener">gradle-2.0-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1MAXMfgzKpKBP0W2Di0RlCg" target="_blank" rel="noopener">gradle-2.1-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1_z1vQCL5kSfqGHHLdeqoCw" target="_blank" rel="noopener">gradle-2.2-all下载</a></p>
<p><a href="https://pan.baidu.com/s/15mJtU1ENz7N09_iJ0r3mAA" target="_blank" rel="noopener">gradle-2.3-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1ohXTtNikTmNw6QrF3nkGRw" target="_blank" rel="noopener">gradle-2.4-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1C1zdKIkB8S2PldeqFiPfqw" target="_blank" rel="noopener">gradle-2.5-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1KppvYmdfBp6LyIz4qEnBnw" target="_blank" rel="noopener">gradle-2.6-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1JYWdZzyhlaJ1XALON0Merg" target="_blank" rel="noopener">gradle-2.7-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1zfIHWn_L_MxH7gnDzTNP5A" target="_blank" rel="noopener">gradle-2.8-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1VKbFNERme-MZ9cKE4Az9rg" target="_blank" rel="noopener">gradle-2.9-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1cEVV6P92Vn7VGOSSts8OPw" target="_blank" rel="noopener">gradle-2.10-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1eEvDJdJE2FvhwBubehNgpQ" target="_blank" rel="noopener">gradle-2.11-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1LUFmcRrtomsgqzVQbNHKKA" target="_blank" rel="noopener">gradle-2.12-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1fe-KexUcP-531cTxOWTOaA" target="_blank" rel="noopener">gradle-2.13-all下载</a></p>
<p><a href="https://pan.baidu.com/s/125TlqmDzgYvgl1zHKhDNhw" target="_blank" rel="noopener">gradle-3.1-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1Yuyb8xpJlK4gg3usP8KYKg" target="_blank" rel="noopener">gradle-3.2-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1XToX6dk2g4ekYAjCugp6mQ" target="_blank" rel="noopener">gradle-3.3-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1TMPt1DmwqM_039D9hla38A" target="_blank" rel="noopener">gradle-3.4-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1fF1kfwzrZweFsBSRa3V_AQ" target="_blank" rel="noopener">gradle-3.5-all下载</a></p>
<p><a href="https://pan.baidu.com/s/15VQDKD88T2E2fTxr7F4j1A" target="_blank" rel="noopener">gradle-4.1-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1xS3dsp6Ffue_P6oKdyz26w" target="_blank" rel="noopener">gradle-4.2-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1Oe9FjDZYfRIc3u56wqqOXg" target="_blank" rel="noopener">gradle-4.3-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1ngH39WybkGssbMyN06yYPg" target="_blank" rel="noopener">gradle-4.4-all下载</a></p>
<p><a href="https://pan.baidu.com/s/1CbVd2uiPOBiVRBWQj-U14Q" target="_blank" rel="noopener">gradle-4.5-all下载</a></p>
<p><a href="https://pan.baidu.com/s/15XW9mJCWaoO1NU4NdqNY4A" target="_blank" rel="noopener">gradle-4.6-all下载</a></p>
<h3 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h3><p>如果觉得好用留言给个赞<br>如果链接有问题请留言</p>
<blockquote>
<p>话说我还不知道我的微信和支付宝打赏好不好用 , 求测试. 哈哈 . </p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>gradle下载</tag>
      </tags>
  </entry>
  <entry>
    <title>Android DataBinding使用详解</title>
    <url>/2018/04/13/DataBindingan/</url>
    <content><![CDATA[<blockquote>
<p>DataBinding是一个实现数据和UI绑定的框架，同时也是实现MVVM模式所依赖的工具。</p>
</blockquote>
<p><a href="https://developer.android.com/topic/libraries/data-binding/index.html#data_binding_layout_files" target="_blank" rel="noopener">官方文档</a></p>
<a id="more"></a>

<h2 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h2><p>在app根目录的build.gradle文件中加入DataBinding配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ....</span><br><span class="line">    dataBinding &#123;</span><br><span class="line">        enabled = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>环境要求：</p>
<ul>
<li><p>系统版本：Android 2.1(API level 7)及以上</p>
</li>
<li><p>Gradle版本：1.5.0-alpha1及以上</p>
</li>
<li><p>Android Studio版本：1.3及以上</p>
</li>
</ul>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>DataBinding的布局文件使用了layout标签作为根节点，其中包含了data标签与view标签，view标签的内容就是不使用DataBinding时的普通布局内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;user&quot;</span><br><span class="line">            type=&quot;com.yl.databindingdemo.bean.User&quot; /&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@&#123;user.firstName&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@&#123;user.lastName&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>data标签下的user变量定义了可以在此布局中使用的属性：</li>
<li>布局中的表达式使用了@{ }语法：</li>
</ul>
<h3 id="数据实体"><a href="#数据实体" class="headerlink" title="数据实体"></a>数据实体</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String firstName;</span><br><span class="line">    private String lastName;</span><br><span class="line"></span><br><span class="line">    public User(String firstName, String lastName) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getFirstName() &#123;</span><br><span class="line">        return firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFirstName(String firstName) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLastName() &#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLastName(String lastName) &#123;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>默认情况下，DataBinding会根据布局文件名称自动生成ActivityBaseUseBinding类（activity_base_use -&gt; ActivityBaseUseBinding）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BaseUseActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        // ActivityBaseUseBinding是根据布局名称自动生成的</span><br><span class="line">        // 代替原来的setContentView(R.layout.activity_base_use)方法</span><br><span class="line">        ActivityBaseUseBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_base_use);</span><br><span class="line">        User user = new User(&quot;容华&quot;, &quot;谢后&quot;);</span><br><span class="line">        // set方法是根据data标签下的variable名称自动生成的</span><br><span class="line">        binding.setUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="布局详情"><a href="#布局详情" class="headerlink" title="布局详情"></a>布局详情</h2><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>在data标签下可以使用多个import标签，就像Java一样把类导入到布局文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.view.View&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line"></span><br><span class="line">&lt;TextView</span><br><span class="line">   android:text=&quot;@&#123;user.lastName&#125;&quot;</span><br><span class="line">   android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">   android:visibility=&quot;@&#123;user.isAdult ? View.VISIBLE : View.GONE&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>当类名冲突时可以设置别名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;import type=&quot;android.view.View&quot;/&gt;</span><br><span class="line">&lt;import type=&quot;com.example.real.estate.View&quot;</span><br><span class="line">        alias=&quot;Vista&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>导入的类型也可以用于变量的类型引用和表达式中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;com.example.User&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;java.util.List&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot; type=&quot;User&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;userList&quot; type=&quot;List&lt;User&gt;&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt; &gt;需要使用转义字符&lt; &gt;代替。</code></p>
<p>在表达式中使用静态方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StringUtils &#123;</span><br><span class="line"></span><br><span class="line">    public static String capitalize(String word) &#123;</span><br><span class="line">        if (word.length() &gt; 1) &#123;</span><br><span class="line">            return String.valueOf(word.charAt(0)).toUpperCase() + word.substring(1);</span><br><span class="line">        &#125;</span><br><span class="line">        return word;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;com.yl.databindingdemo.utils.StringUtils&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;user&quot; type=&quot;com.yl.databindingdemo.bean.User&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line"></span><br><span class="line">&lt;TextView</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;@&#123;StringUtils.capitalize(user.lastName)&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>和在Java中一样，java.lang. 会被自动导入。*</p>
<h2 id="自定义绑定类名"><a href="#自定义绑定类名" class="headerlink" title="自定义绑定类名"></a>自定义绑定类名</h2><p>默认情况下，Binding的类名是根据布局文件名称命名的，假如包名是com.yl.databindingdemo，那么Binding类就会被放在com.yl.databindingdemo.databinding包下，如果不想使用默认类名和路径，可以进行自定义修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 自定义Binding类名 --&gt;</span><br><span class="line">&lt;data class=&quot;ContactItem&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/data&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 自定义Binding存放路径，.代表module根目录 --&gt;</span><br><span class="line">&lt;data class=&quot;.ContactItem&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/data&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 自定义Binding存放路径，指定路径 --&gt;</span><br><span class="line">&lt;data class=&quot;com.example.ContactItem&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Includes"><a href="#Includes" class="headerlink" title="Includes"></a>Includes</h3><p>变量可以传递到include布局中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;user&quot;</span><br><span class="line">            type=&quot;com.yl.databindingdemo.bean.User&quot; /&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;include</span><br><span class="line">            layout=&quot;@layout/layout_include&quot;</span><br><span class="line">            bind:user=&quot;@&#123;user&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>


<p>layout_include布局中也需要声明user变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;user&quot;</span><br><span class="line">            type=&quot;com.yl.databindingdemo.bean.User&quot; /&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@&#123;user.firstName&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@&#123;user.lastName&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：DataBinding不支持使用merge节点。</p>
</blockquote>
<h2 id="表达式语法"><a href="#表达式语法" class="headerlink" title="表达式语法"></a>表达式语法</h2><h3 id="支持的表达式："><a href="#支持的表达式：" class="headerlink" title="支持的表达式："></a>支持的表达式：</h3><p>数学计算 + - / * %</p>
<p>字符串连接 +</p>
<p>逻辑 &amp;&amp; ||</p>
<p>二进制 &amp; | ^</p>
<p>一元运算符 + - ! ~</p>
<p>位移 &gt;&gt; &gt;&gt;&gt; &lt;&lt;</p>
<p>比较 == &gt; &lt; &gt;= &lt;=</p>
<p>instanceof</p>
<p>组 ()</p>
<p>文字 - 字符，字符串，数字， null</p>
<p>类型转换</p>
<p>函数调用</p>
<p>字段存取</p>
<p>数组存取 []</p>
<p>三目运算符 ?：</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:text=&quot;@&#123;String.valueOf(index + 1)&#125;&quot;</span><br><span class="line">android:visibility=&quot;@&#123;age &lt; 13 ? View.GONE : View.VISIBLE&#125;&quot;</span><br><span class="line">android:transitionName=&apos;@&#123;&quot;image_&quot; + id&#125;&apos;</span><br></pre></td></tr></table></figure>
<h3 id="不支持的表达式："><a href="#不支持的表达式：" class="headerlink" title="不支持的表达式："></a>不支持的表达式：</h3><p>this</p>
<p>super</p>
<p>new</p>
<p>显式泛型调用 <T></p>
<p>非null时选择左边的操作，反之选择右边的操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:text=&quot;@&#123;user.displayName ?? user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:text=&quot;@&#123;user.displayName != null ? user.displayName : user.lastName&#125;&quot;</span><br></pre></td></tr></table></figure>


<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>通用的集合类（arrays, lists, sparse lists, maps），可以使用[ ]操作符来存取：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;android.util.SparseArray&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;java.util.Map&quot;/&gt;</span><br><span class="line">    &lt;import type=&quot;java.util.List&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;list&quot; type=&quot;List&lt;String&gt;&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;sparse&quot; type=&quot;SparseArray&lt;String&gt;&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;map&quot; type=&quot;Map&lt;String, String&gt;&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;index&quot; type=&quot;int&quot;/&gt;</span><br><span class="line">    &lt;variable name=&quot;key&quot; type=&quot;String&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;list[index]&#125;&quot;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;sparse[index]&#125;&quot;</span><br><span class="line">…</span><br><span class="line">android:text=&quot;@&#123;map[key]&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>如果属性使用单引号的话，表达式就可以使用双引号：</p>
<p><code>android:text=&#39;@{map[&quot;firstName&quot;]}&#39;</code><br>属性使用双引号，表达式可以使用以下两种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:text=&quot;@&#123;map[`firstName`&#125;&quot;</span><br><span class="line">android:text=&quot;@&#123;map[&apos;firstName&apos;]&#125;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>可以在表达式中使用普通语法来引用资源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;string name=&quot;full_name&quot;&gt;%1$s %2$s&lt;/string&gt;</span><br><span class="line"></span><br><span class="line">android:text=&quot;@&#123;@string/full_name(user.firstName, user.lastName)&#125;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="动态更新"><a href="#动态更新" class="headerlink" title="动态更新"></a>动态更新</h2><h3 id="Observable-Objects"><a href="#Observable-Objects" class="headerlink" title="Observable Objects"></a>Observable Objects</h3><p>DataBinding提供了Observable接口用于监听实体类对象属性的变化，Observable接口有具有添加、删除监听的功能。为了简化开发，DataBinding已经为我们实现了一个基本的监听类BaseObservable，实体类只要继承BaseObservable，然后在get方法上加入@Bindable注解，set方法中调用notifyPropertyChanged通知UI更新就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ObservableObjectsUser extends BaseObservable &#123;</span><br><span class="line"></span><br><span class="line">    private String firstName;</span><br><span class="line">    private String lastName;</span><br><span class="line"></span><br><span class="line">    public ObservableObjectsUser() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ObservableObjectsUser(String firstName, String lastName) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bindable</span><br><span class="line">    public String getFirstName() &#123;</span><br><span class="line">        return firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFirstName(String firstName) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        notifyPropertyChanged(BR.firstName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bindable</span><br><span class="line">    public String getLastName() &#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLastName(String lastName) &#123;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">        notifyPropertyChanged(BR.lastName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>在get方法上加入@Bindable注解后，DataBinding就会在BR文件中生成相应的字段，BR是编译期间生成的类，类似于R文件。</em></strong></p>
<p>在Activity中动态更新UI：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ObservableActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        ActivityObservableBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_observable);</span><br><span class="line">        final ObservableObjectsUser user = new ObservableObjectsUser(&quot;容华&quot;, &quot;谢后&quot;);</span><br><span class="line">        binding.setUser(user);</span><br><span class="line"></span><br><span class="line">        binding.setClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                user.setFirstName(&quot;空谷&quot;);</span><br><span class="line">                user.setLastName(&quot;幽兰&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ObservableFields"><a href="#ObservableFields" class="headerlink" title="ObservableFields"></a>ObservableFields</h3><p><strong><em>注意: 简单的方法</em></strong></p>
<p>每个get方法都要加上注解，还要在每个set方法中通知UI更新，是不是有点麻烦，贴心的DataBinding还为我们提供了更简便的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ObservableFieldsUser &#123;</span><br><span class="line"></span><br><span class="line">    public ObservableField&lt;String&gt; firstName = new ObservableField&lt;&gt;();</span><br><span class="line">    public ObservableField&lt;String&gt; lastName = new ObservableField&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public ObservableFieldsUser(String firstName, String lastName) &#123;</span><br><span class="line">        this.firstName.set(firstName);</span><br><span class="line">        this.lastName.set(lastName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在Activity中动态更新UI：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ObservableActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        ActivityObservableBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_observable);</span><br><span class="line">        final ObservableFieldsUser user = new ObservableFieldsUser(&quot;容华&quot;, &quot;谢后&quot;)</span><br><span class="line">        binding.setUser(user);</span><br><span class="line"></span><br><span class="line">        binding.setClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                user.firstName.set(&quot;空谷&quot;);</span><br><span class="line">                user.lastName.set(&quot;幽兰&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了ObservableField<T>，还可以使用ObservableBoolean, ObservableByte, ObservableChar, ObservableShort, ObservableInt, ObservableLong, ObservableFloat, ObservableDouble, ObservableParcelable。</p>
</blockquote>
<h3 id="Observable-Collections"><a href="#Observable-Collections" class="headerlink" title="Observable Collections"></a>Observable Collections</h3><p>不一定使用实体类才能动态更新，DataBinding还为我们提供了更灵活的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ObservableActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        ActivityObservableBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_observable);</span><br><span class="line"></span><br><span class="line">        final ObservableArrayMap&lt;String, String&gt; user = new ObservableArrayMap&lt;&gt;();</span><br><span class="line">        user.put(&quot;firstName&quot;, &quot;容华&quot;);</span><br><span class="line">        user.put(&quot;lastName&quot;, &quot;谢后&quot;);</span><br><span class="line"></span><br><span class="line">        binding.setUser(user);</span><br><span class="line"></span><br><span class="line">        binding.setClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                user.put(&quot;firstName&quot;, &quot;空谷&quot;);</span><br><span class="line">                user.put(&quot;lastName&quot;, &quot;幽兰&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>布局文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;import type=&quot;android.databinding.ObservableMap&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;user&quot;</span><br><span class="line">            type=&quot;ObservableMap&lt;String, String&gt;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;clickListener&quot;</span><br><span class="line">            type=&quot;android.view.View.OnClickListener&quot; /&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:layout_margin=&quot;10dp&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@&#123;user[`firstName`]&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@&#123;user[`lastName`]&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Button</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_marginTop=&quot;10dp&quot;</span><br><span class="line">            android:onClick=&quot;@&#123;clickListener&#125;&quot;</span><br><span class="line">            android:text=&quot;更新数据&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>

<h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p>DataBinding现在也支持双向绑定了，即UI改变的同时，数据模型中的数据也跟着改变：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data&gt;</span><br><span class="line"></span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;user&quot;</span><br><span class="line">            type=&quot;com.yl.databindingdemo.bean.ObservableObjectsUser&quot; /&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:layout_margin=&quot;10dp&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;EditText</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@=&#123;user.firstName&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:text=&quot;@&#123;user.firstName&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用-表达式进行双向绑"><a href="#使用-表达式进行双向绑" class="headerlink" title="使用@={ }表达式进行双向绑"></a>使用@={ }表达式进行双向绑</h4><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>类似于android:onClick可以指定Activity中的方法，DataBinding也提供了事件处理的机制：</p>
<ul>
<li><p>方法调用：方法的参数必须与监听对象的参数相匹配，比如点击事件onClick(View v)，对应的方法必须为methodName(View v)。</p>
</li>
<li><p>监听绑定：只要方法的返回值与监听对象的返回值相匹配就可以，比如onLongClick(View v)的返回值是boolean类型的，那么对应的方法返回值也必须是boolean类型的。</p>
</li>
</ul>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>表达式会在编译时处理，如果方法不存在，编译将会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EventHandler &#123;</span><br><span class="line"></span><br><span class="line">    public void onClickFriend(View view) &#123;</span><br><span class="line">        Toast.makeText(view.getContext(), &quot;onClickFriend&quot;, Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>布局文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data&gt;</span><br><span class="line"></span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;handler&quot;</span><br><span class="line">            type=&quot;com.yl.databindingdemo.handler.EventHandler&quot; /&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:gravity=&quot;center_vertical&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Button</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_margin=&quot;10dp&quot;</span><br><span class="line">            android:onClick=&quot;@&#123;handler::onClickFriend&#125;&quot;</span><br><span class="line">            android:text=&quot;方法调用&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>

<p>@{handler::onClickFriend}代表调用EventHandler类中的onClickFriend方法，注意onClickFriend方法的参数必须与onClick(View v)方法的参数相匹配。</p>
<h3 id="监听绑定"><a href="#监听绑定" class="headerlink" title="监听绑定"></a>监听绑定</h3><p>官方文档上的说明是：监听绑定在事件发生时调用，可以使用任意表达式。测试过程中发现如果方法不存在，编译也会报错。</p>
<h4 id="注意：需要在Android-Gradle-Plugin-version-2-0版本以上使用。"><a href="#注意：需要在Android-Gradle-Plugin-version-2-0版本以上使用。" class="headerlink" title="注意：需要在Android Gradle Plugin version 2.0版本以上使用。"></a>注意：需要在Android Gradle Plugin version 2.0版本以上使用。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EventHandler &#123;</span><br><span class="line"></span><br><span class="line">    public void onTaskClick(Task task) &#123;</span><br><span class="line">        task.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onTaskClick(View view, Task task) &#123;</span><br><span class="line">        Toast.makeText(view.getContext(), &quot;onTaskClick&quot;, Toast.LENGTH_LONG).show();</span><br><span class="line">        task.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onCompletedChanged(Task task, boolean completed) &#123;</span><br><span class="line">        if (completed) &#123;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Task implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG = &quot;Task&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Log.i(TAG, &quot;Task running&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布局文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data&gt;</span><br><span class="line"></span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;handler&quot;</span><br><span class="line">            type=&quot;com.yl.databindingdemo.handler.EventHandler&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;task&quot;</span><br><span class="line">            type=&quot;com.yl.databindingdemo.task.Task&quot; /&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:gravity=&quot;center_vertical&quot;</span><br><span class="line">        android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Button</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_margin=&quot;10dp&quot;</span><br><span class="line">            android:onClick=&quot;@&#123;() -&gt; handler.onTaskClick(task)&#125;&quot;</span><br><span class="line">            android:text=&quot;监听绑定&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Button</span><br><span class="line">            android:layout_width=&quot;match_parent&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_margin=&quot;10dp&quot;</span><br><span class="line">            android:onClick=&quot;@&#123;(view) -&gt; handler.onTaskClick(view,task)&#125;&quot;</span><br><span class="line">            android:text=&quot;监听绑定_使用参数&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;CheckBox</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_gravity=&quot;center_horizontal&quot;</span><br><span class="line">            android:layout_margin=&quot;10dp&quot;</span><br><span class="line">            android:onCheckedChanged=&quot;@&#123;(checkBox, isChecked) -&gt; handler.onCompletedChanged(task, isChecked)&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>

<p>lambda表达式中的参数有两种选择，全不写或者全写，例如onCheckedChanged(CompoundButton buttonView, boolean isChecked)方法有两个参数，如果用到其中一个参数，另一个参数也要补上，不能只写一个，参数名称可以自定义。</p>
<p><a href="https://www.jianshu.com/p/e4c4a9aece40" target="_blank" rel="noopener">Android DataBinding使用详解（一）</a><br><a href="https://www.jianshu.com/p/895cd56e3fd8" target="_blank" rel="noopener">Android DataBinding使用详解（二）</a>-</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>BinDing</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Hexo 博客加入 Disqus 评论</title>
    <url>/2018/04/13/hexoaddDisqus/</url>
    <content><![CDATA[<p><a href="http://wangkunlin.date/2017/03/23/hexo-use-disqus-comment/" target="_blank" rel="noopener">转自为 Hexo 博客加入 Disqus 评论</a></p>
<blockquote>
<p>由于多说将于近期关闭服务，所以不得不切换其他的评论服务，重要通知: 多说即将关闭<br>链接内主要是说 “多说将于2017年6月1日正式关停服务” Google 搜了一下，好像用 Disqus 的也不少，考查了一下集成难度，感觉很容易集成，于是决定使用 Disqus</p>
</blockquote>
<a id="more"></a>
<h3 id="注册-Disqus"><a href="#注册-Disqus" class="headerlink" title="注册 Disqus"></a>注册 Disqus</h3><p>打开 <a href="https://disqus.com" target="_blank" rel="noopener">Disqus</a> 主页<br><img src="http://static.zybuluo.com/Rookie/3f5h7y80rx6406awk58o54q7/image_1caldm1bpace1go5v012k3u379.png" alt="image_1caldm1bpace1go5v012k3u379.png-280.6kB"></p>
<p>可以看到，Disqus 支持 Facebook，Twitter以及 Google 登录，当然也可以用邮箱注册一个账号，如果是注册的账号，需要验证一下邮箱</p>
<h3 id="配置-Disqus"><a href="#配置-Disqus" class="headerlink" title="配置 Disqus"></a>配置 Disqus</h3><p>登录后，点击首页的 GET STARTED 按钮，之后选择 I want to install Disqus on my site 选项，就会看到下面的界面<br><img src="http://static.zybuluo.com/Rookie/yilv0d6za9zkunz6zpewuh2m/image_1caldo4as183m194r13pc4v1pdmm.png" alt="image_1caldo4as183m194r13pc4v1pdmm.png-81.8kB"></p>
<blockquote>
<p>Websit Name 就是 short name 自己填写，但是要求全网唯一，设定后不可改变，比如我的是 wangkunlin，这个在配置 Hexo 的时候需要用到<br>Category 选择种类，可以随便选<br>Language 语言选 Chinese 或者 English<br>然后点 Create Site 等待界面跳转<br>接下来在页面的左侧点击 Configure Disqus</p>
</blockquote>
<p><img src="http://static.zybuluo.com/Rookie/lttgi1jkfmuelm85r8ek638f/image_1caldp4sh1o3b7f7g801thp1emc13.png" alt="image_1caldp4sh1o3b7f7g801thp1emc13.png-91.5kB"><br>在 Website URL 那里填写自己的博客地址，Description 可以不写，然后点 Complete Setup，Disqus 基本的设置已经完成</p>
<p>###配置 Hexo</p>
<p>在 blog 下的 _config.yml 里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 填写你自己的 shortname</span><br><span class="line">disqus_shortname: wangkunlin</span><br></pre></td></tr></table></figure>

<p>进入 theme 目录，这里我用的主题是 Tinnypp 找到 comment.ejs，我的是在 blog/themes/Tinnypp/layout/_partial/post/comment.ejs，不同主题请自行查找，替换为下面的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if (page.comments)&#123; %&gt;</span><br><span class="line">&lt;section id=&quot;comment&quot;&gt;</span><br><span class="line">  &lt;% if(config.disqus_shortname) &#123; %&gt;</span><br><span class="line">  &lt;div id=&quot;disqus_thread&quot;&gt;</span><br><span class="line">    &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;/section&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p>修改 blog/themes/Tinnypp/layout/_partial/after_footer.ejs，将原来的多说相关的代码删掉，增加下面的代码（这是根据原来的逻辑修改过）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% if ((page.layout == &apos;post&apos; || page.layout == &apos;page&apos;) &amp;&amp; config.disqus_shortname &amp;&amp; page.comments)&#123; %&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var disqus_shortname = &apos;&lt;%= config.disqus_shortname %&gt;&apos;;</span><br><span class="line">    var disqus_config = function () &#123;</span><br><span class="line">        this.page.url = &apos;&lt;%= config.url %&gt;/&lt;%= page.path %&gt;&apos;;</span><br><span class="line">        this.page.identifier = &apos;/&lt;%= page.path %&gt;&apos;;</span><br><span class="line">        this.page.title = &apos;&lt;%= page.title %&gt;&apos;;</span><br><span class="line">    &#125;;</span><br><span class="line">    (function()&#123;</span><br><span class="line">      var d = document;</span><br><span class="line">      var dsq = d.createElement(&apos;script&apos;);</span><br><span class="line">      dsq.type = &apos;text/javascript&apos;;</span><br><span class="line">      dsq.async = true;</span><br><span class="line">      dsq.src = &apos;//&apos; + disqus_shortname + &apos;.disqus.com/&lt;% if (page.comments)&#123; %&gt;embed.js&lt;% &#125; else &#123; %&gt;count.js&lt;% &#125; %&gt;&apos;;</span><br><span class="line">      (d.head || d.body).appendChild(dsq);</span><br><span class="line">    &#125;)();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p>然后执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Hexo使用指南</category>
      </categories>
      <tags>
        <tag>Disqus 评论</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发规范</title>
    <url>/2018/04/11/androidspecification/</url>
    <content><![CDATA[<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>项目中规范是必须存在的. 保持可读性,易于维护,利人利己.为了有利于项目维护、增强代码可读性、提升 Code Review 效率以及规范团队安卓开发</p>
<a id="more"></a>

<h2 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h2><h3 id="编码方式统一用UTF-8-Android-Studio默认已是UTF-8，只要不去改动它就可以了。"><a href="#编码方式统一用UTF-8-Android-Studio默认已是UTF-8，只要不去改动它就可以了。" class="headerlink" title="编码方式统一用UTF-8. Android Studio默认已是UTF-8，只要不去改动它就可以了。"></a>编码方式统一用UTF-8. Android Studio默认已是UTF-8，只要不去改动它就可以了。</h3><p> <img src="http://static.zybuluo.com/Rookie/xygktyngq93t3agkhklh2kr7/image_1cap6t35m1g0l1cr9fmj8gvb99.png" alt="image_1cap6t35m1g0l1cr9fmj8gvb99.png-49.9kB"></p>
<h3 id="花括号不要单独一行，和它前面的代码同一行。而且，花括号与前面的代码之间用一个空格隔开。"><a href="#花括号不要单独一行，和它前面的代码同一行。而且，花括号与前面的代码之间用一个空格隔开。" class="headerlink" title="花括号不要单独一行，和它前面的代码同一行。而且，花括号与前面的代码之间用一个空格隔开。"></a>花括号不要单独一行，和它前面的代码同一行。而且，花括号与前面的代码之间用一个空格隔开。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void method() &#123; // Good </span><br><span class="line">      ...</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public void method()</span><br><span class="line">&#123; // Bad</span><br><span class="line">    ...</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">public void method()&#123; // Bad</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空格使用"><a href="#空格使用" class="headerlink" title="空格使用"></a>空格使用</h3><ul>
<li><p>if、else、for、switch、while等逻辑关键字与后面的语句留一个空格隔开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Good</span><br><span class="line">if (booleanVariable) &#123;</span><br><span class="line">    // TODO while booleanVariable is true</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // TODO else</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Bad</span><br><span class="line">if(booleanVariable) &#123;</span><br><span class="line">    // TODO while booleanVariable is true</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    // TODO else</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运算符两边各用一个空格隔开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int result = a + b; //Good, = 和 + 两边各用一个空格隔开</span><br><span class="line">int result=a+b; //Bad,=和+两边没用空格隔开</span><br></pre></td></tr></table></figure></li>
<li><p>方法的每个参数之间用一个空格隔开。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void method(String param1, String param2); // Good，param1后面的逗号与String之间隔了一个空格</span><br><span class="line">method(param1, param2); // Good，方法调用时，param1后面的逗号与param2之间隔了一个空格</span><br><span class="line">method(param1,param2); // Bad，没有用一个空格隔开</span><br></pre></td></tr></table></figure>

<h3 id="空行的使用"><a href="#空行的使用" class="headerlink" title="空行的使用"></a>空行的使用</h3><p>将逻辑相关的代码段用空行隔开，以提高可读性。空行也只空一行，不要空多行。在以下情况需用一个空行：</p>
<ul>
<li>两个方法之间</li>
<li>方法内的两个逻辑段之间</li>
<li>方法内的局部变量和方法的第一条逻辑语句之间</li>
<li>常量和变量之间</li>
</ul>
<h3 id="当一个表达式无法容纳在一行内时，可换行显示，另起的新行用8个空格缩进。"><a href="#当一个表达式无法容纳在一行内时，可换行显示，另起的新行用8个空格缩进。" class="headerlink" title="当一个表达式无法容纳在一行内时，可换行显示，另起的新行用8个空格缩进。"></a>当一个表达式无法容纳在一行内时，可换行显示，另起的新行用8个空格缩进。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">someMethod(longExpression1, longExpression2, longExpression3,  </span><br><span class="line">        longExpression4, longExpression5);</span><br></pre></td></tr></table></figure>

<h3 id="一行声明一个变量，不要一行声明多个变量，这样有利于写注释。"><a href="#一行声明一个变量，不要一行声明多个变量，这样有利于写注释。" class="headerlink" title="一行声明一个变量，不要一行声明多个变量，这样有利于写注释。"></a>一行声明一个变量，不要一行声明多个变量，这样有利于写注释。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private String param1; // 参数1</span><br><span class="line">private String param2; // 参数2</span><br></pre></td></tr></table></figure>

<h3 id="使用快捷键进行代码自动格式化。"><a href="#使用快捷键进行代码自动格式化。" class="headerlink" title="使用快捷键进行代码自动格式化。"></a>使用快捷键进行代码自动格式化。</h3><p>Windows：CTRL+ALT+L<br>Mac：OPTION+COMMAND+L (ALT+COMMAND+L)</p>
<h3 id="范围型的常量用枚举类定义，而不要直接用整型或字符，这样可以减少范围值的有效性检查。"><a href="#范围型的常量用枚举类定义，而不要直接用整型或字符，这样可以减少范围值的有效性检查。" class="headerlink" title="范围型的常量用枚举类定义，而不要直接用整型或字符，这样可以减少范围值的有效性检查。"></a>范围型的常量用枚举类定义，而不要直接用整型或字符，这样可以减少范围值的有效性检查。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 用枚举类定义，Good</span><br><span class="line">public enum CouponType &#123;</span><br><span class="line">    // 现金券</span><br><span class="line">    @SerializedName(&quot;1&quot;)</span><br><span class="line">    CASH,</span><br><span class="line">    </span><br><span class="line">    // 抵用券</span><br><span class="line">    @SerializedName(&quot;2&quot;)</span><br><span class="line">    DEBIT,</span><br><span class="line">    </span><br><span class="line">    // 折扣券</span><br><span class="line">    @SerializedName(&quot;3&quot;)</span><br><span class="line">    DISCOUNT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用整型定义，Bad</span><br><span class="line">public static final int TYPE_CASH = 1; // 现金券</span><br><span class="line">public static final int TYPE_DEBIT = 2; // 抵扣券</span><br><span class="line">public static final int TYPE_DISCOUNT = 3; // 折扣券</span><br></pre></td></tr></table></figure>

<h3 id="字符串和颜色设置"><a href="#字符串和颜色设置" class="headerlink" title="字符串和颜色设置"></a>字符串和颜色设置</h3><ul>
<li>文字大小的单位统一用sp，元素大小的单位统一用dp。</li>
<li>应用中的字符串统一在strings.xml中定义，然后在代码和布局文件中引用。</li>
<li>颜色值统一在colors.xml中定义，然后在代码和布局文件中引用。另外，不要在代码和布局文件中引用系统的颜色，除了透明。</li>
</ul>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><h3 id="包命名"><a href="#包命名" class="headerlink" title="包命名"></a>包命名</h3><p>域名反写+项目名称+模块名称，全部单词用小写字母。<br>例如，我的KAndroid项目的Model模块包名如下：<br><code>me.keeganlee.kandroid.model</code></p>
<h3 id="类和接口命名"><a href="#类和接口命名" class="headerlink" title="类和接口命名"></a>类和接口命名</h3><p>使用大驼峰规则，用名词或名词词组命名，每个单词的首字母大写。<br>以下为几种常用类的命名：</p>
<ul>
<li>activity类，命名以Activity为后缀，如：LoginActivity</li>
<li>fragment类，命名以Fragment为后缀，如：ShareDialogFragment</li>
<li>service类，命名以Service为后缀，如：DownloadService</li>
<li>adapter类，命名以Adapter为后缀，如：CouponListAdapter</li>
<li>工具类，命名以Util为后缀，如：EncryptUtil</li>
<li>模型类，命名以BO为后缀，如：CouponBO</li>
<li>接口实现类，命名以Impl为后缀，如：ApiImpl</li>
</ul>
<h3 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h3><p>使用小驼峰规则，用动词命名，第一个单词的首字母小写，其他单词的首字母大写。<br>以下为几种常用方法的命名：</p>
<ul>
<li>初始化方法，命名以init开头，例：initView</li>
<li>按钮点击方法，命名以to开头，例：toLogin</li>
<li>设置方法，命名以set开头，例：setData</li>
<li>具有返回值的获取方法，命名以get开头，例：getData</li>
<li>通过异步加载数据的方法，命名以load开头，例：loadData</li>
<li>布尔型的判断方法，命名以is或has，或具有逻辑意义的单词如equals，例：isEmpty</li>
</ul>
<p>|-|-|-|-|<br>| ——–   | —–  |<br>|控件|    缩写|    控件|    缩写|<br>|TextView|    txt    |EditText|    edt<br>|Button|    btn|    ImageButton    |ibtn<br>|ImageView|    img|    ListView|    list<br>|RadioGroup    |group|    RadioButton|    rbtn<br>|ProgressBar|    progress|    SeekBar|    seek<br>|CheckBox|    chk|    Spinner|    spinner<br>|TableLayout|    table|    TableRow|    row<br>|LinearLayout|    llayout|    RelativeLayout|    rlayout<br>|ScrollView    |scroll    |SearchView    |search<br>|TabHost|    host|    TabWidget|    widget</p>
<h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h3><p>全部为大写单词，单词之间用下划线分开。<br><code>public final static int PAGE_SIZE = 20;</code></p>
<h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>{范围描述+}意义描述+类型描述的组合，用驼峰式，首字母小写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private TextView headerTitleTxt; // 标题栏的标题</span><br><span class="line">private Button loginBtn; // 登录按钮</span><br><span class="line">private CouponBO couponBO; // 券实例</span><br></pre></td></tr></table></figure>


<h3 id="控件id命名"><a href="#控件id命名" class="headerlink" title="控件id命名"></a>控件id命名</h3><p>控件缩写<em>{范围</em>}意义，范围可选，只在有明确定义的范围内才需要加上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这是标题栏的标题 --&gt;</span><br><span class="line">&lt;TextView</span><br><span class="line">    android:id=&quot;@+id/txt_header_title&quot;</span><br><span class="line">    ... /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 这是登录按钮 --&gt;</span><br><span class="line">&lt;Button</span><br><span class="line">    android:id=&quot;@+id/btn_login&quot;</span><br><span class="line">    ... /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="layout命名"><a href="#layout命名" class="headerlink" title="layout命名"></a>layout命名</h3><p>组件类型<em>{范围</em>}功能，范围可选，只在有明确定义的范围内才需要加上。<br>以下为几种常用的组件类型命名：</p>
<ul>
<li>activity_{范围_}功能，为Activity的命名格式</li>
<li>fragment_{范围_}功能，为Fragment的命名格式</li>
<li>dialog_{范围_}功能，为Dialog的命名格式</li>
<li>item_list_{范围_}功能，为ListView的item命名格式</li>
<li>item_grid_{范围_}功能，为GridView的item命名格式</li>
<li>header_list_{范围_}功能，为ListView的HeaderView命名格式</li>
<li>footer_list_{范围_}功能，为ListView的FooterView命名格式</li>
</ul>
<h3 id="strings的命名"><a href="#strings的命名" class="headerlink" title="strings的命名"></a>strings的命名</h3><p>类型<em>{范围</em>}功能，范围可选。<br>以下为几种常用的命名：</p>
<ul>
<li>页面标题，命名格式为：title_页面</li>
<li>按钮文字，命名格式为：btn_按钮事件</li>
<li>标签文字，命名格式为：label_标签文字</li>
<li>选项卡文字，命名格式为：tab_选项卡文字</li>
<li>消息框文字，命名格式为：toast_消息</li>
<li>编辑框的提示文字，命名格式为：hint_提示信息</li>
<li>图片的描述文字，命名格式为：desc_图片文字</li>
<li>对话框的文字，命名格式为：dialog_文字</li>
<li>menu的item文字，命名格式为：action_文字</li>
</ul>
<h3 id="colors的命名"><a href="#colors的命名" class="headerlink" title="colors的命名"></a>colors的命名</h3><p>前缀{_控件}{_范围}{_后缀}，控件、范围、后缀可选，但控件和范围至少要有一个。</p>
<ul>
<li>背景颜色，添加bg前缀</li>
<li>文本颜色，添加text前缀</li>
<li>分割线颜色，添加div前缀</li>
<li>区分状态时，默认状态的颜色，添加normal后缀</li>
<li>区分状态时，按下时的颜色，添加pressed后缀</li>
<li>区分状态时，选中时的颜色，添加selected后缀</li>
<li>区分状态时，不可用时的颜色，添加disable后缀</li>
</ul>
<h3 id="drawable的命名"><a href="#drawable的命名" class="headerlink" title="drawable的命名"></a>drawable的命名</h3><p>前缀{_控件}{_范围}{_后缀}，控件、范围、后缀可选，但控件和范围至少要有一个。</p>
<ul>
<li>图标类，添加ic前缀</li>
<li>背景类，添加bg前缀</li>
<li>分隔类，添加div前缀</li>
<li>默认类，添加def前缀</li>
<li>区分状态时，默认状态，添加normal后缀</li>
<li>区分状态时，按下时的状态，添加pressed后缀</li>
<li>区分状态时，选中时的状态，添加selected后缀</li>
<li>区分状态时，不可用时的状态，添加disable后缀</li>
<li>多种状态的，添加selector后缀（一般为ListView的selector或按钮的selector）</li>
</ul>
<h3 id="动画文件命名"><a href="#动画文件命名" class="headerlink" title="动画文件命名"></a>动画文件命名</h3><p>动画类型_动画方向。</p>
<ul>
<li>fade_in，淡入</li>
<li>fade_out，淡出</li>
<li>push_down_in，从下方推入</li>
<li>push_down_out，从下方推出</li>
<li>slide_in_from_top，从头部滑动进入</li>
<li>zoom_enter，变形进入</li>
<li>shrink_to_middle，中间缩小</li>
</ul>
<h2 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h2><h3 id="文件头注释"><a href="#文件头注释" class="headerlink" title="文件头注释"></a>文件头注释</h3><p>文件顶部统一添加版权声明，声明的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by rookie Inc. on 2018/4/11. All rights reserved.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p><img src="http://static.zybuluo.com/Rookie/r9qhxk1lv97w66sglod40ebm/image_1cap9064j1vcmp1m67o19h11dbqp.png" alt="image_1cap9064j1vcmp1m67o19h11dbqp.png-53.2kB"></p>
<h3 id="类和接口注释"><a href="#类和接口注释" class="headerlink" title="类和接口注释"></a>类和接口注释</h3><p>类和接口统一添加javadoc注释，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 类或接口的描述信息</span><br><span class="line"> *</span><br><span class="line"> * @author $&#123;USER&#125;</span><br><span class="line"> * @date $&#123;DATE&#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h3 id="自定义注释"><a href="#自定义注释" class="headerlink" title="自定义注释"></a>自定义注释</h3><p>添加自定义注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description $d$</span><br><span class="line"> * @date $data$</span><br><span class="line"> * @author rookie</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>


<p><img src="http://static.zybuluo.com/Rookie/i14tk2o5bwwsxxfvkgfc9u2v/image_1capa1vkih2vt5h1oqbj2jl03m.png" alt="image_1capa1vkih2vt5h1oqbj2jl03m.png-113.8kB"></p>
<h3 id="类和接口注释-1"><a href="#类和接口注释-1" class="headerlink" title="类和接口注释"></a>类和接口注释</h3><p>类和接口统一添加javadoc注释，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 类或接口的描述信息</span><br><span class="line"> *</span><br><span class="line"> * @author $&#123;USER&#125;</span><br><span class="line"> * @date $&#123;DATE&#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>


<h3 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h3><p>下面几种方法，都必须添加javadoc注释，说明该方法的用途和参数说明，以及返回值的说明。</p>
<ul>
<li>接口中定义的所有方法</li>
<li>抽象类中自定义的抽象方法</li>
<li>抽象父类的自定义公用方法</li>
<li>工具类的公用方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 登录</span><br><span class="line"> *</span><br><span class="line"> * @param loginName 登录名</span><br><span class="line"> * @param password  密码</span><br><span class="line"> * @param listener  回调监听器</span><br><span class="line"> */</span><br><span class="line">public void login(String loginName, String password, ActionCallbackListener&lt;Void&gt; listener);</span><br></pre></td></tr></table></figure>

<h3 id="变量和常量注释"><a href="#变量和常量注释" class="headerlink" title="变量和常量注释"></a>变量和常量注释</h3><p>下面几种情况下的常量和变量，都要添加注释说明，优先采用右侧//来注释，若注释说明太长则在上方添加注释。</p>
<ul>
<li>接口中定义的所有常量</li>
<li>公有类的公有常量</li>
<li>枚举类定义的所有枚举常量</li>
<li>实体类的所有属性变量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static final int TYPE_CASH = 1; // 现金券</span><br><span class="line">public static final int TYPE_DEBIT = 2; // 抵扣券</span><br><span class="line">public static final int TYPE_DISCOUNT = 3; // 折扣券</span><br><span class="line"></span><br><span class="line">private int id;                // 券id</span><br><span class="line">private String name;           // 券名称</span><br><span class="line">private String introduce;      // 券简介</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h2><p><a href="https://keeganlee.me/post/android/20150709" target="_blank" rel="noopener">ANDROID技术积累:开发规范</a></p>
<p><a href="https://github.com/Blankj/AndroidStandardDevelop" target="_blank" rel="noopener">AndroidStandardDevelop</a></p>
<p><a href="http://www.ayqy.net/blog/android包命名规范/" target="_blank" rel="noopener">Android 包命名规范</a></p>
<p><a href="https://github.com/futurice/android-best-practices/blob/master/translations/Chinese/README.cn.md" target="_blank" rel="noopener">Android 开发最佳实践</a></p>
<p><a href="https://www.jianshu.com/p/0a984f999592" target="_blank" rel="noopener">Android 编码规范</a></p>
<p><a href="https://github.com/alibaba/p3c/blob/master/阿里巴巴Java开发手册（纪念版）.pdf" target="_blank" rel="noopener">阿里巴巴 Java 开发手册</a></p>
<p><a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener">Google Java 编程风格指南</a></p>
<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p><a href="https://pan.baidu.com/s/1JndL9Hy9brdV_JvHmDIEjA" target="_blank" rel="noopener">阿里巴巴Android开发手册</a><br><a href="https://pan.baidu.com/s/1ixKCWTdvxj2mnq1ACqgSZA" target="_blank" rel="noopener">阿里巴巴java开发手册</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Google推荐——Glide使用详解</title>
    <url>/2018/03/23/Glideuse/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Glide，一个被google所推荐的图片加载库，作者是bumptech。这个库被广泛运用在google的开源项目中，包括2014年的google I/O大会上发布的官方app。（PS：众所周知的简介就到此为止了）</p>
<a id="more"></a>
<p>Glide 对于 Android SDK 的最低要求是 API level 10</p>
<p>Glide滑行的意思，可以看出这个库的主旨就在于让图片加载变的流畅。现在被广泛使用，当然还是有很多开发者使用Square公司的picasso，也有两个库的对比</p>
<p>原文链接：<a href="http://inthecheesefactory.com/blog/get-to-know-glide-recommended-by-google/en" target="_blank" rel="noopener">http://inthecheesefactory.com/blog/get-to-know-glide-recommended-by-google/en</a></p>
<p>译文链接：<a href="http://jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0327/2650.html" target="_blank" rel="noopener">http://jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0327/2650.html</a></p>
<h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><p>###（一）导入</p>
<p>在AndroidStudio上添加依赖非常简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dependencies &#123;  </span><br><span class="line">    compile <span class="string">'com.github.bumptech.glide:glide:3.7.0'</span>  </span><br><span class="line">    compile <span class="string">'com.android.support:support-v4:23.2.1'</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Glide 也支持 Maven 项目形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.github.bumptech.glide&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;glide&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.7.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.google.android&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;support-v4&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;r7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="（二）基础使用"><a href="#（二）基础使用" class="headerlink" title="（二）基础使用"></a>（二）基础使用</h3><h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><p>Glide的一个完整的请求至少需要三个参数，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String url = &quot;http://img1.dzwww.com:8080/tupian_pl/20150813/16/7858995348613407436.jpg&quot;;</span><br><span class="line">ImageView imageView = (ImageView) findViewById(R.id.imageView);</span><br><span class="line">Glide.with(context)</span><br><span class="line">    .load(url)</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure>

<ul>
<li>with(Context context) - 需要上下文，这里还可以使用 Activity、FragmentActivity、android.support.v4.app.Fragment、android.app.Fragment 的对象。将 Activity/Fragment 对象作为参数的好处是，图片的加载会和 Activity/Fragment 的生命周期保持一致，例如：onPaused 时暂停加载，onResume 时又会自动重新加载。所以在传参的时候建议使用 Activity/Fragment 对象，而不是 Context。</li>
<li>load(String url) - 这里我们所使用的一个字符串形式的网络图片的 URL，后面会讲解 load() 的更多使用方式</li>
<li>into(ImageView imageView) - 你需要显示图片的目标 ImageView</li>
</ul>
<h4 id="占位图设置"><a href="#占位图设置" class="headerlink" title="占位图设置"></a>占位图设置</h4><p>偶尔出现图片加载慢或者加载不出来的情况是难以避免的，所以为了 UI 能好看一些，我们会使用占位图。Glide 也为我们提供这种方法 placeHolder() 和 error()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String url = &quot;http://img1.dzwww.com:8080/tupian_pl/20150813/16/7858995348613407436.jpg&quot;;</span><br><span class="line">ImageView imageView = (ImageView) findViewById(R.id.imageView);</span><br><span class="line">Glide.with(context)</span><br><span class="line">    .load(url)</span><br><span class="line">    .placeholder(R.drawable.place_image)//图片加载出来前，显示的图片</span><br><span class="line">    .error(R.drawable.error_image)//图片加载失败后，显示的图片</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：这里需要注意一点，placeholder() 和 error() 的参数都是只支持 int 和 Drawable 类型的参数，这种设计应该是考虑到使用本地图片比网络图片更加合适做占位图。</p>
</blockquote>
<h4 id="缩略图"><a href="#缩略图" class="headerlink" title="缩略图"></a>缩略图</h4><p>Glide 的缩略图功能在这里不得不说，和占位图略有不同，占位图必须使用资源文件才行，而缩略图是动态的占位图可以从网络中加载。缩略图会在世纪请求加载完成或者处理完之后才显示。在原始图片到达之后，缩略图不会取代原始图片，只会被抹除。</p>
<p>Glide 为缩略图提供了2种不同的加载方式，比较简单的方式是调用 thumbnail() 方法，参数是 float 类型，作为其倍数大小。例如，你传入 0.2f 作为参数，Glide 将会显示原始图片的20%的大小，如果原图是 1000x1000 的尺寸，那么缩略图将会是 200x200 的尺寸。为缩略图明显比原图小得多，所以我们需要确保 ImageView 的 ScaleType 设置的正确。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Glide.with( context )</span><br><span class="line">    .load( url )</span><br><span class="line">    .thumbnail( 0.2f )</span><br><span class="line">    .into( imageView );</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：应用于请求的设置也将应用于缩略图。</p>
</blockquote>
<h2 id="算了不写了"><a href="#算了不写了" class="headerlink" title="算了不写了"></a>算了不写了</h2><p><a href="https://www.jianshu.com/p/7ce7b02988a4" target="_blank" rel="noopener">原文连接,自己看吧</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Glide使用详解</tag>
      </tags>
  </entry>
  <entry>
    <title>Android基础：Fragment，看这篇就够了</title>
    <url>/2018/02/15/Fragmentst/</url>
    <content><![CDATA[<p><a href="https://xiazdong.github.io/2017/06/15/android-fragment/" target="_blank" rel="noopener">原文链接</a></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Fragment，简称碎片，是Android 3.0（API 11）提出的，为了兼容低版本，support-v4库中也开发了一套Fragment API，最低兼容Android 1.6。</p>
<a id="more"></a>
<p>过去support-v4库是一个jar包，24.2.0版本开始，将support-v4库模块化为多个jar包，包含：support-fragment, support-ui, support-media-compat等，这么做是为了减少APK包大小，你需要用哪个模块就引入哪个模块。</p>
<p>如果想引入整个support-v4库，则compile <code>&#39;com.android.support:support-v4:24.2.1&#39;</code>，如果只想引入support-fragment库，则<code>com.android.support:support-fragment:24.2.1</code>。</p>
<blockquote>
<p>因为support库是不断更新的，因此建议使用support库中的android.support.v4.app.Fragment，而不要用系统自带的android.app.Fragment。而如果要使用support库的Fragment，Activity必须要继承FragmentActivity（AppCompatActivity是FragmentActivity的子类）。</p>
</blockquote>
<h4 id="Fragment官方的定义是："><a href="#Fragment官方的定义是：" class="headerlink" title="Fragment官方的定义是："></a>Fragment官方的定义是：</h4><blockquote>
<p>A Fragment represents a behavior or a portion of user interface in an Activity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. You can think of a fragment as a modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or remove while the activity is running.</p>
</blockquote>
<p>根据上面的定义可知：</p>
<ul>
<li>Fragment是依赖于Activity的，不能独立存在的。</li>
<li>一个Activity里可以有多个Fragment。</li>
<li>一个Fragment可以被多个Activity重用。</li>
<li>Fragment有自己的生命周期，并能接收输入事件。</li>
<li>我们能在Activity运行时动态地添加或删除Fragment。</li>
</ul>
<blockquote>
<p>Android 3.0系统只针对平板电脑，且闭源，那时候针对手机和针对平板是两套源代码，后来Android 4.0时整合了手机和平板的源码，因此市面上很难看到Android 3.0系统。</p>
</blockquote>
<p>Fragment的优势有以下几点：</p>
<ul>
<li>模块化（Modularity）：我们不必把所有代码全部写在Activity中，而是把代码写在各自的Fragment中。</li>
<li>可重用（Reusability）：多个Activity可以重用一个Fragment。</li>
<li>可适配（Adaptability）：根据硬件的屏幕尺寸、屏幕方向，能够方便地实现不同的布局，这样用户体验更好。</li>
</ul>
<p><img src="http://static.zybuluo.com/Rookie/qmnjqxqtmw1yq2hj8coag344/image_1cakcsad1v6hkqd1urc1rdv1rda9.png" alt="image_1cakcsad1v6hkqd1urc1rdv1rda9.png-21.4kB"></p>
<p>Fragment核心的类有：</p>
<ul>
<li>Fragment：Fragment的基类，任何创建的Fragment都需要继承该类。</li>
<li>FragmentManager：管理和维护Fragment。他是抽象类，具体的实现类是FragmentManagerImpl。</li>
<li>FragmentTransaction：对Fragment的添加、删除等操作都需要通过事务方式进行。他是抽象类，具体的实现类是BackStackRecord。</li>
</ul>
<p>Nested Fragment（Fragment内部嵌套Fragment的能力）是Android 4.2提出的，support-fragment库可以兼容到1.6。通过getChildFragmentManager()能够获得子Fragment的FragmentManager，在子Fragment中可以通过getParentFragment()获得父Fragment。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>这里给出Fragment最基本的使用方式。首先，创建继承Fragment的类，名为Fragment1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fragment1</span> <span class="keyword">extends</span> <span class="title">Fragment</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String ARG_PARAM = <span class="string">"param_key"</span>;</span><br><span class="line">    <span class="keyword">private</span> String mParam;</span><br><span class="line">    <span class="keyword">private</span> Activity mActivity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        mActivity = (Activity) context;</span><br><span class="line">        mParam = getArguments().getString(ARG_PARAM);  <span class="comment">//获取参数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        View root = inflater.inflate(R.layout.fragment_1, container, <span class="keyword">false</span>);</span><br><span class="line">        TextView view = root.findViewById(R.id.text);</span><br><span class="line">        view.setText(mParam);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fragment1 <span class="title">newInstance</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Fragment1 frag = <span class="keyword">new</span> Fragment1();</span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putString(ARG_PARAM, str);</span><br><span class="line">        fragment.setArguments(bundle);   <span class="comment">//设置参数</span></span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fragment有很多可以复写的方法，其中最常用的就是onCreateView()，该方法返回Fragment的UI布局，需要注意的是inflate()的第三个参数是false，因为在Fragment内部实现中，会把该布局添加到container中，如果设为true，那么就会重复做两次添加，则会抛如下异常：</p>
<blockquote>
<p>Caused by: java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child’s parent first.</p>
</blockquote>
<p>如果在创建Fragment时要传入参数，必须要通过setArguments(Bundle bundle)方式添加，而不建议通过为Fragment添加带参数的构造函数，因为通过setArguments()方式添加，在由于内存紧张导致Fragment被系统杀掉并恢复（re-instantiate）时能保留这些数据。官方建议如下：</p>
<blockquote>
<p>It is strongly recommended that subclasses do not have other constructors with parameters, since these constructors will not be called when the fragment is re-instantiated.</p>
</blockquote>
<p>我们可以在Fragment的onAttach()中通过getArguments()获得传进来的参数，并在之后使用这些参数。如果要获取Activity对象，不建议调用getActivity()，而是在onAttach()中将Context对象强转为Activity对象。</p>
<p>创建完Fragment后，接下来就是把Fragment添加到Activity中。在Activity中添加Fragment的方式有两种：</p>
<ul>
<li>静态添加：在xml中通过<fragment>的方式添加，缺点是一旦添加就不能在运行时删除。</li>
<li>动态添加：运行时添加，这种方式比较灵活，因此建议使用这种方式。</li>
</ul>
<p>虽然Fragment能在XML中添加，但是这只是一个语法糖而已，Fragment并不是一个View，而是和Activity同一层次的。</p>
<p>这里只给出动态添加的方式。首先Activity需要有一个容器存放Fragment，一般是FrameLayout，因此在Activity的布局文件中加入FrameLayout：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/container"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在onCreate()中，通过以下代码将Fragment添加进Activity中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (bundle == null) &#123;</span><br><span class="line">    getSupportFragmentManager().beginTransaction()</span><br><span class="line">        .add(R.id.container, Fragment1.newInstance(&quot;hello world&quot;), &quot;f1&quot;)</span><br><span class="line">        //.addToBackStack(&quot;fname&quot;)</span><br><span class="line">        .commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意几点：</p>
<ul>
<li>因为我们使用了support库的Fragment，因此需要使用getSupportFragmentManager()获取FragmentManager。</li>
<li>add()是对Fragment众多操作中的一种，还有remove(), replace()等，第一个参数是根容器的id（FrameLayout的id，即”@id/container”），第二个参数是Fragment对象，第三个参数是fragment的tag名，指定tag的好处是后续我们可以通过Fragment1 frag = getSupportFragmentManager().findFragmentByTag(“f1”)从FragmentManager中查找Fragment对象。</li>
<li>在一次事务中，可以做多个操作，比如同时做add().remove().replace()。</li>
<li>commit()操作是异步的，内部通过mManager.enqueueAction()加入处理队列。对应的同步方法为commitNow()，commit()内部会有checkStateLoss()操作，如果开发人员使用不当（比如commit()操作在onSaveInstanceState()之后），可能会抛出异常，而commitAllowingStateLoss()方法则是不会抛出异常版本的commit()方法，但是尽量使用commit()，而不要使用commitAllowingStateLoss()。</li>
<li>addToBackStack(“fname”)是可选的。FragmentManager拥有回退栈（BackStack），类似于Activity的任务栈，如果添加了该语句，就把该事务加入回退栈，当用户点击返回按钮，会回退该事务（回退指的是如果事务是add(frag1)，那么回退操作就是remove(frag1)）；如果没添加该语句，用户点击返回按钮会直接销毁Activity。</li>
<li>Fragment有一个常见的问题，即Fragment重叠问题，这是由于Fragment被系统杀掉，并重新初始化时再次将fragment加入activity，因此通过在外围加if语句能判断此时是否是被系统杀掉并重新初始化的情况。</li>
</ul>
<p>Fragment有个常见的异常：</p>
<blockquote>
<p>java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState<br>    at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341)<br>    at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352)<br>    at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595)<br>    at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574)</p>
</blockquote>
<p>该异常出现的原因是：commit()在onSaveInstanceState()后调用。首先，onSaveInstanceState()在onPause()之后，onStop()之前调用。onRestoreInstanceState()在onStart()之后，onResume()之前。</p>
<p>因此避免出现该异常的方案有：</p>
<ul>
<li>不要把Fragment事务放在异步线程的回调中，比如不要把Fragment事务放在AsyncTask的onPostExecute()，因此onPostExecute()可能会在onSaveInstanceState()之后执行。</li>
<li>逼不得已时使用commitAllowingStateLoss()。</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Fragment的生命周期和Activity类似，但比Activity的生命周期复杂一些，基本的生命周期方法如下图</p>
<p><img src="http://static.zybuluo.com/Rookie/3l3v9cnvy3vab9doqp35trny/image_1cakd8ke61k6aosf6n31endrd9m.png" alt="image_1cakd8ke61k6aosf6n31endrd9m.png-115kB"></p>
<p>解释如下：</p>
<ul>
<li>onAttach()：Fragment和Activity相关联时调用。可以通过该方法获取- Activity引用，还可以通过getArguments()获取参数。</li>
<li>onCreate()：Fragment被创建时调用。</li>
<li>onCreateView()：创建Fragment的布局。</li>
<li>onActivityCreated()：当Activity完成onCreate()时调用。</li>
<li>onStart()：当Fragment可见时调用。</li>
<li>onResume()：当Fragment可见且可交互时调用。</li>
<li>onPause()：当Fragment不可交互但可见时调用。</li>
<li>onStop()：当Fragment不可见时调用。</li>
<li>onDestroyView()：当Fragment的UI从视图结构中移除时调用。</li>
<li>onDestroy()：销毁Fragment时调用。</li>
<li>onDetach()：当Fragment和Activity解除关联时调用。</li>
</ul>
<p><code>上面的方法中，只有onCreateView()在重写时不用写super方法，其他都需要。</code></p>
<p>因为Fragment是依赖Activity的，因此为了讲解Fragment的生命周期，需要和Activity的生命周期方法一起讲，即Fragment的各个生命周期方法和Activity的各个生命周期方法的关系和顺序，如图：</p>
<p><img src="http://static.zybuluo.com/Rookie/cj1nvuufud0tb1c7nu8vmvck/image_1cakdof3j15l24jigjcnf98j413.png" alt="image_1cakdof3j15l24jigjcnf98j413.png-317.5kB"></p>
<h3 id="Fragment实现原理和Back-Stack"><a href="#Fragment实现原理和Back-Stack" class="headerlink" title="Fragment实现原理和Back Stack"></a>Fragment实现原理和Back Stack</h3><p>我们知道Activity有任务栈，用户通过startActivity将Activity加入栈，点击返回按钮将Activity出栈。Fragment也有类似的栈，称为回退栈（Back Stack），回退栈是由FragmentManager管理的。默认情况下，Fragment事务是不会加入回退栈的，如果想将Fragment事务加入回退栈，则可以加入addToBackStack(“”)。如果没有加入回退栈，则用户点击返回按钮会直接将Activity出栈；如果加入了回退栈，则用户点击返回按钮会回滚Fragment事务。</p>
<p>我们将通过最常见的Fragment用法，讲解Back Stack的实现原理：</p>
<blockquote>
<p>getSupportFragmentManager().beginTransaction()<br>    .add(R.id.container, f1, “f1”)<br>    .addToBackStack(“”)<br>    .commit();</p>
</blockquote>
<p>上面这个代码的功能就是将Fragment加入Activity中，内部实现为：创建一个BackStackRecord对象，该对象记录了这个事务的全部操作轨迹（这里只做了一次add操作，并且加入回退栈），随后将该对象提交到FragmentManager的执行队列中，等待执行。</p>
<p>BackStackRecord类的定义如下：</p>
<blockquote>
<p>class BackStackRecord extends FragmentTransaction implements FragmentManager.BackStackEntry, Runnable {}</p>
</blockquote>
<p>从定义可以看出，BackStackRecord有三重含义：</p>
<ul>
<li>继承了FragmentTransaction，即是事务，保存了整个事务的全部操作轨迹。</li>
<li>实现了BackStackEntry，作为回退栈的元素，正是因为该类拥有事务全部的操作轨迹，因此在popBackStack()时能回退整个事务。</li>
<li>继承了Runnable，即被放入FragmentManager执行队列，等待被执行。</li>
</ul>
<p>先看第一层含义，getSupportFragmentManager.beginTransaction()返回的就是BackStackRecord对象，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public FragmentTransaction beginTransaction() &#123;</span><br><span class="line">    return new BackStackRecord(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BackStackRecord类包含了一次事务的整个操作轨迹，是以链表形式存在的，链表的元素是Op类，表示其中某个操作，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static final class Op &#123;</span><br><span class="line">    Op next; //链表后一个节点</span><br><span class="line">    Op prev; //链表前一个节点</span><br><span class="line">    int cmd;  //操作是add或remove或replace或hide或show等</span><br><span class="line">    Fragment fragment; //对哪个Fragment对象做操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下具体场景下这些类是怎么被使用的，比如我们的事务做add操作。add函数的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public FragmentTransaction add(int containerViewId, Fragment fragment, String tag) &#123;</span><br><span class="line">    doAddOp(containerViewId, fragment, tag, OP_ADD);</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doAddOp()方法就是创建Op对象，并加入链表，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) &#123;</span><br><span class="line">    fragment.mTag = tag;  //设置fragment的tag</span><br><span class="line">    fragment.mContainerId = fragment.mFragmentId = containerViewId;  //设置fragment的容器id</span><br><span class="line">    Op op = new Op();</span><br><span class="line">    op.cmd = opcmd;</span><br><span class="line">    op.fragment = fragment;</span><br><span class="line">    addOp(op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addOp()是将创建好的Op对象加入链表，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void addOp(Op op) &#123;</span><br><span class="line">    if (mHead == null) &#123;</span><br><span class="line">        mHead = mTail = op;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        op.prev = mTail;</span><br><span class="line">        mTail.next = op;</span><br><span class="line">        mTail = op;</span><br><span class="line">    &#125;</span><br><span class="line">    mNumOp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>addToBackStack(“”)是将mAddToBackStack变量记为true，在commit()中会用到该变量。commit()是异步的，即不是立即生效的，但是后面会看到整个过程还是在主线程完成，只是把事务的执行扔给主线程的Handler，commit()内部是commitInternal()，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int commitInternal(boolean allowStateLoss) &#123;</span><br><span class="line">    mCommitted = true;</span><br><span class="line">    if (mAddToBackStack) &#123;</span><br><span class="line">        mIndex = mManager.allocBackStackIndex(this);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mIndex = -1;</span><br><span class="line">    &#125;</span><br><span class="line">    mManager.enqueueAction(this, allowStateLoss); //将事务添加进待执行队列中</span><br><span class="line">    return mIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果mAddToBackStack为true，则调用allocBackStackIndex(this)将事务添加进回退栈，FragmentManager类的变量ArrayList<BackStackRecord> mBackStackIndices;就是回退栈。实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int allocBackStackIndex(BackStackRecord bse) &#123;</span><br><span class="line">    if (mBackStackIndices == null) &#123;</span><br><span class="line">        mBackStackIndices = new ArrayList&lt;BackStackRecord&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    int index = mBackStackIndices.size();</span><br><span class="line">    mBackStackIndices.add(bse);</span><br><span class="line">    return index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在commitInternal()中，mManager.enqueueAction(this, allowStateLoss);是将BackStackRecord加入待执行队列中，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void enqueueAction(Runnable action, boolean allowStateLoss) &#123;</span><br><span class="line">    if (mPendingActions == null) &#123;</span><br><span class="line">        mPendingActions = new ArrayList&lt;Runnable&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingActions.add(action);</span><br><span class="line">    if (mPendingActions.size() == 1) &#123;</span><br><span class="line">        mHost.getHandler().removeCallbacks(mExecCommit);</span><br><span class="line">        mHost.getHandler().post(mExecCommit); //调用execPendingActions()执行待执行队列的事务</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>mPendingActions就是前面说的待执行队列，mHost.getHandler()就是主线程的Handler，因此Runnable是在主线程执行的，mExecCommit的内部就是调用了execPendingActions()，即把mPendingActions中所有积压的没被执行的事务全部执行。执行队列中的事务会怎样被执行呢？就是调用BackStackRecord的run()方法，run()方法就是执行Fragment的生命周期函数，还有将视图添加进container中。</p>
<p>与addToBackStack()对应的是popBackStack()，有以下几种变种：</p>
<p>popBackStack()：将回退栈的栈顶弹出，并回退该事务。<br>popBackStack(String name, int flag)：name为addToBackStack(String name)的参数，通过name能找到回退栈的特定元素，flag可以为0或者FragmentManager.POP_BACK_STACK_INCLUSIVE，0表示只弹出该元素以上的所有元素，POP_BACK_STACK_INCLUSIVE表示弹出包含该元素及以上的所有元素。这里说的弹出所有元素包含回退这些事务。<br>popBackStack()是异步执行的，是丢到主线程的MessageQueue执行，popBackStackImmediate()是同步版本。<br>我们通过讲解Demo1来更清晰地了解回退栈的使用。功能如下：共有三个Fragment：F1, F2, F3，F1在初始化时就加入Activity，点击F1中的按钮跳转到F2，点击F2的按钮跳转到F3，点击F3的按钮回退到F1。</p>
<p>在Activity的onCreate()中，将F1加入Activity中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getSupportFragmentManager().beginTransaction()</span><br><span class="line">    .add(R.id.container, f1, &quot;f1&quot;)</span><br><span class="line">    .addToBackStack(Fragment1.class.getSimpleName())</span><br><span class="line">    .commit();</span><br></pre></td></tr></table></figure>


<p>F1按钮的onClick()内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getFragmentManager().beginTransaction()</span><br><span class="line">    .replace(R.id.container, f2, &quot;f2&quot;)</span><br><span class="line">    .addToBackStack(Fragment2.class.getSimpleName())</span><br><span class="line">    .commit();</span><br></pre></td></tr></table></figure>
<p>F2按钮的onClick()如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getFragmentManager().beginTransaction()</span><br><span class="line">    .replace(R.id.container, f3, &quot;f3&quot;)</span><br><span class="line">    .addToBackStack(Fragment3.class.getSimpleName())</span><br><span class="line">    .commit();</span><br></pre></td></tr></table></figure>
<p>F3按钮的onClick()如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getFragmentManager().popBackStack(Fragment2.class.getSimpleName(), FragmentManager.POP_BACK_STACK_INCLUSIVE);</span><br></pre></td></tr></table></figure>
<p>这样就完成了整个界面的跳转逻辑。</p>
<p>这里补充一个点，getSupportFragmentManager().findFragmentByTag()是经常用到的方法，他是FragmentManager的方法，FragmentManager是抽象类，FragmentManagerImpl是继承FragmentManager的实现类，他的内部实现是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class FragmentManagerImpl extends FragmentManager &#123;</span><br><span class="line">    ArrayList&lt;Fragment&gt; mActive;</span><br><span class="line">    ArrayList&lt;Fragment&gt; mAdded;</span><br><span class="line">    public Fragment findFragmentByTag(String tag) &#123;</span><br><span class="line">        if (mAdded != null &amp;&amp; tag != null) &#123;</span><br><span class="line">            for (int i=mAdded.size()-1; i&gt;=0; i--) &#123;</span><br><span class="line">                Fragment f = mAdded.get(i);</span><br><span class="line">                if (f != null &amp;&amp; tag.equals(f.mTag)) &#123;</span><br><span class="line">                    return f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mActive != null &amp;&amp; tag != null) &#123;</span><br><span class="line">            for (int i=mActive.size()-1; i&gt;=0; i--) &#123;</span><br><span class="line">                Fragment f = mActive.get(i);</span><br><span class="line">                if (f != null &amp;&amp; tag.equals(f.mTag)) &#123;</span><br><span class="line">                    return f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面看到，先从mAdded中查找是否有该Fragment，如果没找到，再从mActive中查找是否有该Fragment。mAdded是已经添加到Activity的Fragment的集合，mActive不仅包含mAdded，还包含虽然不在Activity中，但还在回退栈中的Fragment。</p>
<h3 id="Fragment通信"><a href="#Fragment通信" class="headerlink" title="Fragment通信"></a>Fragment通信</h3><h4 id="Fragment向Activity传递数据"><a href="#Fragment向Activity传递数据" class="headerlink" title="Fragment向Activity传递数据"></a>Fragment向Activity传递数据</h4><p>首先，在Fragment中定义接口，并让Activity实现该接口（具体实现省略）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface OnFragmentInteractionListener &#123;</span><br><span class="line">    void onItemClick(String str);  //将str从Fragment传递给Activity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Fragment的onAttach()中，将参数Context强转为OnFragmentInteractionListener对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void onAttach(Context context) &#123;</span><br><span class="line">    super.onAttach(context);</span><br><span class="line">    if (context instanceof OnFragmentInteractionListener) &#123;</span><br><span class="line">        mListener = (OnFragmentInteractionListener) context;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new RuntimeException(context.toString()</span><br><span class="line">                + &quot; must implement OnFragmentInteractionListener&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在Fragment合适的地方调用mListener.onItemClick(“hello”)将”hello”从Fragment传递给Activity。</p>
<h4 id="FABridge"><a href="#FABridge" class="headerlink" title="FABridge"></a>FABridge</h4><p>由于通过接口的方式从Fragment向Activity进行数据传递比较麻烦，需要在Fragment中定义interface，并让Activity实现该interface，FABridge通过注解的形式免去了这些定义。</p>
<p>在build.gradle中添加依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">annotationProcessor &apos;com.zhy.fabridge:fabridge-compiler:1.0.0&apos;</span><br><span class="line">compile &apos;com.zhy.fabridge:fabridge-api:1.0.0&apos;</span><br></pre></td></tr></table></figure>

<p>首先定义方法ID，这里为FAB_ITEM_CLICK，接着在Activity中定义接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FCallbackId(id = FAB_ITEM_CLICK)</span><br><span class="line">public void onItemClick(String str) &#123;  //方法名任意</span><br><span class="line">    Toast.makeText(this, str, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在Fragment中，通过以下形式调用”ID=FAB_ITEM_CLICK”的方法（该方法可能在Activity中，也可能在任何类中）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fabridge.call(mActivity,FAB_ITEM_CLICK,&quot;data&quot;);  //调用ID对应的方法，&quot;data&quot;为参数值</span><br></pre></td></tr></table></figure>

<h4 id="Activity向Fragment传递数据"><a href="#Activity向Fragment传递数据" class="headerlink" title="Activity向Fragment传递数据"></a>Activity向Fragment传递数据</h4><p>Activity向Fragment传递数据比较简单，获取Fragment对象，并调用Fragment的方法即可，比如要将一个字符串传递给Fragment，则在Fragment中定义方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setString(String str) &#123;</span><br><span class="line">     this.str = str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并在Activity中调用fragment.setString(“hello”)即可。</p>
<h3 id="Fragment之间通信"><a href="#Fragment之间通信" class="headerlink" title="Fragment之间通信"></a>Fragment之间通信</h3><p>由于Fragment之间是没有任何依赖关系的，因此如果要进行Fragment之间的通信，建议通过Activity作为中介，不要Fragment之间直接通信。</p>
<h3 id="ViewPager-Fragment相关"><a href="#ViewPager-Fragment相关" class="headerlink" title="ViewPager+Fragment相关"></a>ViewPager+Fragment相关</h3><p>ViewPager是support v4库中提供界面滑动的类，继承自ViewGroup。PagerAdapter是ViewPager的适配器类，为ViewPager提供界面。但是一般来说，通常都会使用PagerAdapter的两个子类：FragmentPagerAdapter和FragmentStatePagerAdapter作为ViewPager的适配器，他们的特点是界面是Fragment。</p>
<blockquote>
<p>在support v13和support v4中都提供了FragmentPagerAdapter和FragmentStatePagerAdapter，区别在于：support v13中使用android.app.Fragment，而support v4使用android.support.v4.app.Fragment。一般都使用support v4中的FragmentPagerAdapter和FragmentStatePagerAdapter。</p>
</blockquote>
<p>默认，ViewPager会缓存当前页相邻的界面，比如当滑动到第2页时，会初始化第1页和第3页的界面（即Fragment对象，且生命周期函数运行到onResume()），可以通过setOffscreenPageLimit(count)设置离线缓存的界面个数。</p>
<p>FragmentPagerAdapter和FragmentStatePagerAdapter需要重写的方法都一样，常见的重写方法如下：</p>
<ul>
<li>public FragmentPagerAdapter(FragmentManager fm): 构造函数，参数为FragmentManager。如果是嵌套Fragment场景，子PagerAdapter的参数传入getChildFragmentManager()。</li>
<li>Fragment getItem(int position): 返回第position位置的Fragment，必须重写。</li>
<li>int getCount(): 返回ViewPager的页数，必须重写。</li>
<li>Object instantiateItem(ViewGroup container, int position): container是ViewPager对象，返回第position位置的Fragment。</li>
<li>void destroyItem(ViewGroup container, int position, Object object): container是ViewPager对象，object是Fragment对象。</li>
<li>getItemPosition(Object object): object是Fragment对象，如果返回POSITION_UNCHANGED，则表示当前Fragment不刷新，如果返回POSITION_NONE，则表示当前Fragment需要调用destroyItem()和instantiateItem()进行销毁和重建。 默认情况下返回POSITION_UNCHANGED。</li>
</ul>
<p>懒加载</p>
<p>懒加载主要用于ViewPager且每页是Fragment的情况，场景为微信主界面，底部有4个tab，当滑到另一个tab时，先显示”正在加载”，过一会才会显示正常界面。</p>
<p>默认情况，ViewPager会缓存当前页和左右相邻的界面。实现懒加载的主要原因是：用户没进入的界面需要有一系列的网络、数据库等耗资源、耗时的操作，预先做这些数据加载是不必要的。</p>
<p>这里懒加载的实现思路是：用户不可见的界面，只初始化UI，但是不会做任何数据加载。等滑到该页，才会异步做数据加载并更新UI。</p>
<p>这里就实现类似微信那种效果，整个UI布局为：底部用PagerBottomTabStrip项目实现，上面是ViewPager，使用FragmentPagerAdapter。逻辑为：当用户滑到另一个界面，首先会显示正在加载，等数据加载完毕后（这里用睡眠1秒钟代替）显示正常界面。</p>
<p>ViewPager默认缓存左右相邻界面，为了避免不必要的重新数据加载（重复调用onCreateView()），因为有4个tab，因此将离线缓存的半径设置为3，即setOffscreenPageLimit(3)。</p>
<p>懒加载主要依赖Fragment的setUserVisibleHint(boolean isVisible)方法，当Fragment变为可见时，会调用setUserVisibleHint(true)；当Fragment变为不可见时，会调用setUserVisibleHint(false)，且该方法调用时机：</p>
<blockquote>
<p>onAttach()之前，调用setUserVisibleHint(false)。<br>onCreateView()之前，如果该界面为当前页，则调用setUserVisibleHint(true)，否则调用setUserVisibleHint(false)。<br>界面变为可见时，调用setUserVisibleHint(true)。<br>界面变为不可见时，调用setUserVisibleHint(false)。</p>
</blockquote>
<p>懒加载Fragment的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LazyFragment extends Fragment &#123;</span><br><span class="line">    private View mRootView;</span><br><span class="line">    private boolean mIsInited;</span><br><span class="line">    private boolean mIsPrepared;</span><br><span class="line">    @Override</span><br><span class="line">    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123;</span><br><span class="line">        mRootView = inflater.inflate(R.layout.fragment_lazy, container, false);</span><br><span class="line">        mIsPrepared = true;</span><br><span class="line">        lazyLoad();</span><br><span class="line">        return mRootView;</span><br><span class="line">    &#125;</span><br><span class="line">    public void lazyLoad() &#123;</span><br><span class="line">        if (getUserVisibleHint() &amp;&amp; mIsPrepared &amp;&amp; !mIsInited) &#123;</span><br><span class="line">            //异步初始化，在初始化后显示正常UI</span><br><span class="line">            loadData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void loadData() &#123;</span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                //1. 加载数据</span><br><span class="line">                //2. 更新UI</span><br><span class="line">                //3. mIsInited = true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setUserVisibleHint(boolean isVisibleToUser) &#123;</span><br><span class="line">        super.setUserVisibleHint(isVisibleToUser);</span><br><span class="line">        if (isVisibleToUser) &#123;</span><br><span class="line">            lazyLoad();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static LazyFragment newInstance() &#123;</span><br><span class="line">        return new LazyFragment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意点：</p>
<p>在Fragment中有两个变量控制是否需要做数据加载：<br>mIsPrepared：表示UI是否准备好，因为数据加载后需要更新UI，如果UI还没有inflate，就不需要做数据加载，因为setUserVisibleHint()会在onCreateView()之前调用一次，如果此时调用，UI还没有inflate，因此不能加载数据。<br>mIsInited：表示是否已经做过数据加载，如果做过了就不需要做了。因为setUserVisibleHint(true)在界面可见时都会调用，如果滑到该界面做过数据加载后，滑走，再滑回来，还是会调用setUserVisibleHint(true)，此时由于mIsInited=true，因此不会再做一遍数据加载。<br>lazyLoad()：懒加载的核心类，在该方法中，只有界面可见（getUserVisibleHint()==true）、UI准备好（mIsPrepared==true）、过去没做过数据加载（mIsInited==false）时，才需要调loadData()做数据加载，数据加载做完后把mIsInited置为true。</p>
<p>布局XML主要分两个container，一个是初始显示的状态，即R.id.container_empty，当数据加载完成，就显示R.id.container：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:id=&quot;@+id/container_empty&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_centerInParent=&quot;true&quot;</span><br><span class="line">            android:text=&quot;正在加载&quot;</span><br><span class="line">            /&gt;</span><br><span class="line">    &lt;/RelativeLayout&gt;</span><br><span class="line">    &lt;RelativeLayout</span><br><span class="line">        android:id=&quot;@+id/container&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:visibility=&quot;gone&quot;</span><br><span class="line">        &gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/RelativeLayout&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title>Android学习资源</title>
    <url>/2018/01/15/Androidst/</url>
    <content><![CDATA[<p><a href="https://github.com/zhujun2730/Android-Learning-Resources" target="_blank" rel="noopener">Android学习资源网站大全</a></p>
<h1 id="Android学习资源网站大全"><a href="#Android学习资源网站大全" class="headerlink" title="Android学习资源网站大全"></a>Android学习资源网站大全</h1><p>整理了一些 Android 的博客链接、学习资源网站。<strong>站在巨人的肩膀上，会看得更远</strong>。整理这一份资源也方便更多的Android开发者能享受到技术分享的力量。首先，在这里要感谢所有开源项目的作者，感谢Trinea，CodeKK，张明云，胡凯等等大大无私的技术分享，感谢所有乐于分享学习经验的人。最后，若有侵权，请联系本人，本人将及时删除侵权内容。</p>
<a id="more"></a>


<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#官方学习资源">1.官方学习资源</a></li>
<li><a href="#值得关注的大牛博客">2.值得关注的大牛博客</a></li>
<li><a href="#值得Android开发者阅读系列">3.值得 Android 开发者阅读系列【推荐必看】</a></li>
<li><a href="#UI自定义View/动画">4.UI/自定义 View/动画</a></li>
<li><a href="#性能优化">5.Android 性能优化</a></li>
<li><a href="#单元测试系列">6.Android 单元测试系列</a></li>
<li><a href="#框架相关">7.Android 架构/框架相关</a></li>
<li><a href="#MVP/MVVM架构相关">MVP/MVVM 架构相关</a></li>
<li><a href="#组件化开发">组件化开发</a></li>
<li><a href="#插件化开发">插件化开发</a></li>
<li><a href="#高质量Android社区">8.高质量 Android 社区</a></li>
<li><a href="#开发工具第三方开源项目">9.开发工具、第三方开源项目</a></li>
<li><a href="#视频学习网站">10.视频学习网站</a></li>
<li><a href="#面试相关">11.面试相关</a></li>
<li><a href="#Kotlin学习">12.Kotlin 学习</a></li>
</ul>
<h2 id="优质学习资源"><a href="#优质学习资源" class="headerlink" title="优质学习资源"></a>优质学习资源</h2><ul>
<li><a href="http://developer.android.com/" target="_blank" rel="noopener">Android Developer</a>【推荐必看】</li>
<li><a href="http://androiddoc.qiniudn.com/index.html" target="_blank" rel="noopener">Android Developer (七牛镜像)</a></li>
<li><a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="noopener">Android Training 中文版</a>【推荐必看】</li>
<li><a href="http://wiki.jikexueyuan.com/project/material-design/" target="_blank" rel="noopener">Material Design 中文版</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/android-weekly/" target="_blank" rel="noopener">Android Weekly 中文版</a></li>
<li><a href="http://wiki.jikexueyuan.com/list/android" target="_blank" rel="noopener">极客学院 Wiki Android 板块</a></li>
<li><a href="https://chaosleong.gitbooks.io/gradle-for-android/content/" target="_blank" rel="noopener">Gradle Android Plugin 中文版</a></li>
<li><a href="https://github.com/googlesamples" target="_blank" rel="noopener">Google samples</a> —— Google官方Samples源码</li>
<li><a href="http://android-developers.blogspot.jp/" target="_blank" rel="noopener">Android Developers blog</a> —— Google官方Android博客</li>
<li><a href="https://github.com/CharonChui/AndroidNote" target="_blank" rel="noopener">Android 学习笔记</a></li>
</ul>
<h2 id="值得关注的大牛博客"><a href="#值得关注的大牛博客" class="headerlink" title="值得关注的大牛博客"></a>值得关注的大牛博客</h2><ul>
<li><a href="http://a.codekk.com/" target="_blank" rel="noopener">CodeKK</a></li>
<li><a href="http://www.trinea.cn/" target="_blank" rel="noopener">Trinea</a></li>
<li><a href="http://blog.csdn.net/Luoshengyang" target="_blank" rel="noopener">老罗的Android之旅</a></li>
<li><a href="http://www.devtf.cn/" target="_blank" rel="noopener">开发技术前线</a></li>
<li><a href="http://blog.csdn.net/aigestudio" target="_blank" rel="noopener">爱哥</a></li>
<li><a href="http://blog.csdn.net/guolin_blog" target="_blank" rel="noopener">郭霖</a></li>
<li><a href="http://blog.csdn.net/lmj623565791" target="_blank" rel="noopener">鸿洋</a></li>
<li><a href="http://hukai.me" target="_blank" rel="noopener">胡凯</a></li>
<li><a href="http://www.jianshu.com/users/e6885381f7d4/latest_articles" target="_blank" rel="noopener">张明云</a></li>
<li><a href="http://drakeet.me" target="_blank" rel="noopener">Drakeet</a></li>
<li><a href="http://wangkuiwu.github.io" target="_blank" rel="noopener">wangkuiwu</a> —— Binder、事件分发、动画解析</li>
<li><a href="http://www.jianshu.com/users/FK4sc4/latest_articles" target="_blank" rel="noopener">高建武</a> —— 性能优化相关文章</li>
<li><a href="http://blog.csdn.net/lzyzsd" target="_blank" rel="noopener">hi大头鬼hi</a> —— RxJava相关文章</li>
<li><a href="http://blog.csdn.net/coder_pig" target="_blank" rel="noopener">Coder-pig</a> —— 最佳入门专栏</li>
<li><a href="http://keeganlee.me/" target="_blank" rel="noopener">Keegan小刚</a> —— 分享了多篇Android样式的文章</li>
<li><a href="http://blog.csdn.net/NUPTboyZHB/" target="_blank" rel="noopener">郑海波</a> —— 文章大多与自定义控件相关</li>
<li><a href="http://wuxiaolong.me/" target="_blank" rel="noopener">吴小龙同学</a> —— 分享了多篇关于AndroidDesignSupportLibrary的文章</li>
<li><a href="http://blog.csdn.net/lincyang" target="_blank" rel="noopener">全速前行</a> —— 主讲实战技巧和平常遇到的问题</li>
<li><a href="http://blog.csdn.net/asce1885" target="_blank" rel="noopener">ASCE 1985</a> —— 翻译了多篇使用Kotlin开发Android应用</li>
<li><a href="http://blog.mcxiaoke.com" target="_blank" rel="noopener">mcxiaoke</a> —— rxjava文档，EventBus博客，多渠道打包，一些开源项目</li>
<li><a href="http://blog.csdn.net/wangjinyu501?viewmode=contents" target="_blank" rel="noopener">WPJY</a> —— 自定义View、开发经验</li>
<li><a href="http://blog.csdn.net/developer_jiangqq" target="_blank" rel="noopener">江清清的专栏</a> —— 大量实例讲解</li>
<li><a href="http://hujiaweibujidao.github.io" target="_blank" rel="noopener">hujiaweibujidao</a> —— 《Android开发艺术探索》读书笔记系列</li>
<li><a href="http://www.jianshu.com/users/b99b0edd4e77/latest_articles" target="_blank" rel="noopener">BlackSwift</a> —— 简书作者【Blur实时渲染，AnimeWallpaper】</li>
<li><a href="http://blog.csdn.net/qq_23547831?viewmode=contents" target="_blank" rel="noopener">Android 源码解析专栏</a></li>
<li><a href="http://blog.csdn.net/hejjunlin" target="_blank" rel="noopener">DriodDeveloper</a> —— 原创FrameWork源码解析，插件化研究</li>
</ul>
<h2 id="值得Android开发者阅读系列"><a href="#值得Android开发者阅读系列" class="headerlink" title="值得Android开发者阅读系列"></a>值得Android开发者阅读系列</h2><ul>
<li><a href="https://github.com/lizhangqu/CoreLink/blob/master/README.md" target="_blank" rel="noopener">Android 开发中的日常积累</a></li>
<li><a href="https://github.com/tangqi92/Android-Tips" target="_blank" rel="noopener">Android-Tips</a> —— 作者收集了大量Android开发Tip</li>
<li><a href="https://github.com/ZhaoKaiQiang/AndroidDifficultAnalysis" target="_blank" rel="noopener">AndroidDifficultAnalysis</a> —— 安卓开发中遇到的重难点解析，也包括平常的读书笔记和知识点整理</li>
<li><a href="https://will_he.gitbooks.io/android/content/" target="_blank" rel="noopener">Android 知识整理 GitBook</a></li>
<li><a href="https://github.com/bboyfeiyu/android-tech-frontier/wiki" target="_blank" rel="noopener">Android wiki 周刊</a></li>
<li><a href="https://github.com/bboyfeiyu/Worth-Reading-the-Android-technical-articles" target="_blank" rel="noopener">值得阅读的 Android 技术文章</a></li>
<li><a href="http://bxbxbai.github.io/2014/10/07/android-develop-resource/" target="_blank" rel="noopener">整理一些比较好的 Android 开发教程</a> —— 这些都是该作者在学习Android开发过程中觉得比较好的教程和博客</li>
<li><a href="https://segmentfault.com/a/1190000004063006" target="_blank" rel="noopener">Segmentfault 上回答较好的一些问题</a></li>
<li><a href="http://www.woshipm.com/ucd/243897.html?utm_source=tuicool&utm_medium=referral" target="_blank" rel="noopener">Android 界面设计视觉规范</a></li>
<li><a href="http://blog.zhaiyifan.cn/2016/03/14/android-new-project-from-0-p1/" target="_blank" rel="noopener">从零开始的 Android 新项目</a></li>
<li><a href="http://www.cloudchou.com/android/post-788.html" target="_blank" rel="noopener">深入理解 Activity 启动流程</a></li>
<li><a href="http://www.jianshu.com/p/f269bcda335f" target="_blank" rel="noopener">你需要知道的 Android 拍照适配方案</a></li>
<li><a href="http://www.jianshu.com/p/94e0f9ab3f1d" target="_blank" rel="noopener">Context 都没弄明白，还怎么做 Android 开发？</a></li>
<li><a href="https://segmentfault.com/a/1190000004676352" target="_blank" rel="noopener">Android 从开机到打开第一个应用的执行流程</a></li>
<li><a href="http://www.jianshu.com/p/011eb88f4e0d" target="_blank" rel="noopener">你所不知道的Android Studio调试技巧</a></li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul>
<li><a href="http://www.trinea.cn/android/performance/" target="_blank" rel="noopener">Trinea - 性能优化系列总篇</a></li>
<li><a href="http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT.html" target="_blank" rel="noopener">高建武 - 性能优化篇</a></li>
<li><a href="http://www.jianshu.com/p/388c693c1b58" target="_blank" rel="noopener">Android 性能优化篇</a></li>
<li><a href="http://hukai.me/android-performance-patterns/" target="_blank" rel="noopener">胡凯 - Android 性能优化典范</a></li>
<li><a href="http://www.jianshu.com/p/cdc6d2e664f1" target="_blank" rel="noopener">Android 内存泄漏总结</a></li>
<li><a href="http://stackoverflow.com/documentation/android/2687/memory-leaks" target="_blank" rel="noopener">stackoverflow 上的有关内存泄漏的回答</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/24974982?utm_source=weibo&utm_medium=social" target="_blank" rel="noopener">避免 Android 中 Context 引起的内存泄露</a></li>
<li><a href="http://www.jianshu.com/p/320eac29391a" target="_blank" rel="noopener">Apk 瘦身的几个技巧</a></li>
<li><a href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&tid=1022&extra=page%3D1%26filter%3Dauthor%26orderby%3Ddateline" target="_blank" rel="noopener">Android 性能优化典范之多线程篇</a></li>
<li><a href="http://zhuanlan.zhihu.com/kaede/20326073" target="_blank" rel="noopener">Android 应用性能调优的技术点</a></li>
<li><a href="http://blog.tingyun.com/web/article/detail/155" target="_blank" rel="noopener">Android 客户端性能优化</a></li>
</ul>
<h2 id="UI-自定义View-动画"><a href="#UI-自定义View-动画" class="headerlink" title="UI/自定义View/动画"></a>UI/自定义View/动画</h2><ul>
<li><a href="http://hencoder.com/ui-1-1/" target="_blank" rel="noopener">Android 开发进阶: 自定义 View</a> —— 扔物线出品【推荐必看】</li>
<li><a href="http://www.gcssloop.com/customview/CustomViewIndex" target="_blank" rel="noopener">安卓自定义 View 教程目录</a></li>
<li><a href="http://blog.csdn.net/harvic880925/article/details/50995268" target="_blank" rel="noopener">Android 自定义控件三部曲文章索引</a></li>
<li><a href="http://blog.csdn.net/wingichoy/article/details/50483101" target="_blank" rel="noopener">简单说说 Android 自定义 view 学习推荐的方式</a></li>
<li><a href="http://www.jianshu.com/p/48554844a2db?utm_source=desktop&utm_medium=timeline" target="_blank" rel="noopener">Android 高级动画</a></li>
<li><a href="https://github.com/D-clock/AndroidSystemUiTraining" target="_blank" rel="noopener">Android System UI Training</a></li>
<li><a href="https://gold.xitu.io/post/58ad9ca70ce463006b24f134" target="_blank" rel="noopener">Android 状态栏操作，你想知道的都在这里了</a></li>
<li><a href="http://www.jianshu.com/p/640f4ef05fb2?utm_source=desktop&utm_medium=timeline" target="_blank" rel="noopener">一文彻底搞懂 Design 设计的 CoordinatorLayout 和 AppbarLayout 联动</a></li>
<li><a href="http://www.jianshu.com/p/1e6eed09d48b" target="_blank" rel="noopener">Android Material Design 兼容库的使用详解</a></li>
</ul>
<h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><ul>
<li><a href="http://www.cnblogs.com/starstone/p/4890409.html" target="_blank" rel="noopener">HTTP 必知必会</a> —— 【推荐必看】</li>
<li><a href="https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html" target="_blank" rel="noopener">In Introduction to HTTP Basics</a> ——【推荐必看】</li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-okhttp/" target="_blank" rel="noopener">OkHttp：Java 平台上的新一代HTTP客户端</a> —— 【推荐必看】</li>
<li><a href="https://zhuanlan.zhihu.com/p/27040041" target="_blank" rel="noopener">HTTPS 原理浅析及其在 Android 中的使用</a> —— 【推荐必看】</li>
<li><a href="https://zhuanlan.zhihu.com/p/22816331" target="_blank" rel="noopener">Android安全开发之安全使用HTTPS</a> —— 【推荐必看】</li>
<li><a href="http://gank.io/post/56e80c2c677659311bed9841" target="_blank" rel="noopener">RxJava 与 Retrofit 结合的最佳实践</a> —— 【推荐必看】</li>
<li><a href="https://realm.io/news/droidcon-jake-wharton-simple-http-retrofit-2/" target="_blank" rel="noopener">Retrofit 2 用法解析</a></li>
<li><a href="http://www.jianshu.com/p/aad5aacd79bf" target="_blank" rel="noopener">OkHttp3 源码分析</a></li>
<li><a href="http://blog.csdn.net/nugongahou110/article/details/46829605" target="_blank" rel="noopener">Volley 源码分析</a></li>
<li><a href="http://www.jianshu.com/p/3141d4e46240" target="_blank" rel="noopener">Android网络请求心路历程</a> —— 【推荐必看】</li>
<li><a href="http://www.ruanyifeng.com/blog/2011/09/restful" target="_blank" rel="noopener">理解 RESTful架构</a></li>
<li><a href="http://www.jianshu.com/p/93f8c9ae8819" target="_blank" rel="noopener">RxJava与Retrofit的封装</a></li>
<li><a href="http://www.jianshu.com/p/9c3b4ea108a7" target="_blank" rel="noopener">使用 Retrofit 和 Okhttp 实现网络缓存</a></li>
<li><a href="http://www.jianshu.com/p/7e28c8216c7d" target="_blank" rel="noopener">RxJava 处理网络连接失败</a></li>
<li><a href="http://www.jianshu.com/p/584707554ed7" target="_blank" rel="noopener">Android 推送技术研究</a></li>
<li><a href="http://www.jianshu.com/p/77d418e7b5d6" target="_blank" rel="noopener">OkHttp, Retrofit, Volley 应该选择哪一个？</a></li>
<li><a href="http://blog.csdn.net/qq_21430549/article/details/51212977" target="_blank" rel="noopener">Retrofit 文件上传下载</a></li>
<li><a href="http://www.jianshu.com/p/93153b34310e" target="_blank" rel="noopener">Android Retrofit 2.0 使用-补充篇</a></li>
<li><a href="http://www.jianshu.com/p/d410911be40c" target="_blank" rel="noopener">谈谈移动应用的安全性实践 - 网络篇</a></li>
</ul>
<h2 id="RxJava相关"><a href="#RxJava相关" class="headerlink" title="RxJava相关"></a>RxJava相关</h2><ul>
<li><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">Rxjava 详解</a> —— 抛物线出品经典Rxjava详解 【推荐必看】</li>
<li><a href="http://blog.csdn.net/lzyzsd/article/details/41833541" target="_blank" rel="noopener">深入浅出 Rxjava</a> —— rx教父大头鬼出品深入浅出rxjava</li>
<li><a href="https://github.com/lzyzsd/Awesome-RxJava" target="_blank" rel="noopener">Awesome-RxJava</a> —— rx教父大头鬼整理的Rxjava学习集合</li>
<li><a href="https://github.com/mcxiaoke/RxDocs" target="_blank" rel="noopener">RxDocs-RxJava 文档中文版</a></li>
<li><a href="http://wangxinghe.me/blog/2016-03-27/rxjava-basis/" target="_blank" rel="noopener">RxJava 学习总结</a></li>
<li><a href="http://gank.io/post/56e80c2c677659311bed9841" target="_blank" rel="noopener">RxJava 与 Retrofit 结合的最佳实践</a></li>
<li><a href="https://medium.com/@diolor/improving-ux-with-rxjava-4440a13b157f#.9mc2oeyzo" target="_blank" rel="noopener">Improving UX with RxJava</a></li>
<li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/index.html" target="_blank" rel="noopener">ReactiveX 文档中文翻译</a></li>
<li><a href="http://www.jianshu.com/p/c2c7c46e6b97" target="_blank" rel="noopener">使用 RxBinding 响应控件的异步事件</a></li>
<li><a href="http://www.jianshu.com/p/6d1ef9f43cdc" target="_blank" rel="noopener">详细解析 RxAndroid 的使用方式</a></li>
<li><a href="http://www.jianshu.com/p/f3f0eccbcd6f" target="_blank" rel="noopener">RxJava简洁封装之道</a></li>
</ul>
<h2 id="MVP-MVVM架构相关"><a href="#MVP-MVVM架构相关" class="headerlink" title="MVP/MVVM架构相关"></a>MVP/MVVM架构相关</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">MVC，MVP 和 MVVM 的图示</a> —— 【推荐必看】</li>
<li><a href="http://www.jianshu.com/p/1f21e1d375aa" target="_blank" rel="noopener">不容错过，最全的 Android 架构合集</a></li>
<li><a href="http://www.jianshu.com/p/0590f530c617" target="_blank" rel="noopener">Android MVP 详解</a></li>
<li><a href="http://www.judymax.com/archives/1141?utm_source=tuicool&utm_medium=referral" target="_blank" rel="noopener">Google 官方 MVP 案例 todoAPP 解析</a></li>
<li><a href="https://developer.android.com/topic/libraries/architecture/index.html" target="_blank" rel="noopener">Android Architecture Components</a> —— Google 官方 App 开发架构指南 【推荐必看】</li>
<li><a href="http://www.jianshu.com/p/6872b699879d" target="_blank" rel="noopener">Android MVVM 框架</a></li>
<li><a href="http://www.jianshu.com/p/269c3f70ec1e" target="_blank" rel="noopener">Dagger2 详解</a></li>
<li><a href="http://www.jianshu.com/collection/b838b070d6de?utm_campaign=hugo&utm_medium=reader_share&utm_content=collection&utm_source=weibo" target="_blank" rel="noopener">Android Dagger2 系列</a></li>
<li><a href="http://www.jianshu.com/p/01d3c014b0b1" target="_blank" rel="noopener">Google官方 MVP + Dagger2 架构详解</a></li>
<li><a href="https://github.com/jemshit/android_architecture_notes/" target="_blank" rel="noopener">Clean Architecture, MVP, MVC, MVVM notes</a></li>
</ul>
<h2 id="插件化开发"><a href="#插件化开发" class="headerlink" title="插件化开发"></a>插件化开发</h2><ul>
<li><a href="http://www.androidblog.cn/index.php/Index/detail/id/16" target="_blank" rel="noopener">插件化开发专栏</a> —— 有关插件化的资料这里全都有</li>
</ul>
<h2 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h2><ul>
<li><a href="https://github.com/luckybilly/AndroidComponentizeLibs" target="_blank" rel="noopener">多个维度对比一些有代表性的开源android组件化开发方案</a></li>
</ul>
<h2 id="单元测试系列"><a href="#单元测试系列" class="headerlink" title="单元测试系列"></a>单元测试系列</h2><ul>
<li><a href="http://rexstjohn.com/unit-testing-with-android-studio/" target="_blank" rel="noopener">unit-testing-with-android-studio</a></li>
<li><a href="http://www.jianshu.com/p/9d988a2f8ff7" target="_blank" rel="noopener">Robolectric3.0 介绍</a></li>
<li><a href="http://www.jianshu.com/p/b2717dc245da" target="_blank" rel="noopener">Android 单元测试: 首先，从是什么开始</a> —— 小创出品【推荐必看】</li>
<li><a href="http://www.jianshu.com/p/4b03123b4f81" target="_blank" rel="noopener">在 Android 中同时使用 unit test 和 instrument test 作为单元测试</a></li>
<li><a href="http://www.jianshu.com/p/fa76b126a7e7" target="_blank" rel="noopener">Android 单元测试——辅助工具介绍</a></li>
<li><a href="http://www.jianshu.com/p/00ab03f3d394" target="_blank" rel="noopener">Android 单元测试实践</a></li>
<li><a href="http://www.jianshu.com/p/cf446be43ae8" target="_blank" rel="noopener">解读 Android 官方 MVP 项目单元测试</a></li>
<li><a href="http://tech.meituan.com/Android_unit_test.html" target="_blank" rel="noopener">美团 Android 单元测试研究与实践</a></li>
</ul>
<h2 id="高质量Android社区"><a href="#高质量Android社区" class="headerlink" title="高质量Android社区"></a>高质量Android社区</h2><ul>
<li><a href="http://gank.io/post/published" target="_blank" rel="noopener">Gank.io 匠心写作</a> —— 【推荐必看】</li>
<li><a href="https://www.diycode.cc/sites" target="_blank" rel="noopener">Android 开发者酷站</a></li>
<li><a href="http://stackoverflow.com/questions/tagged/android" target="_blank" rel="noopener">Stackoverflow</a> —— 国外著名的问答社区</li>
<li><a href="http://antonioleiva.com" target="_blank" rel="noopener">antoniolevia</a> —— 国外android技术分享网站</li>
<li><a href="http://www.androidweekly.cn" target="_blank" rel="noopener">Android 开发技术周报</a> —— 长期更新最新前言资讯</li>
<li><a href="http://www.devtf.cn/" target="_blank" rel="noopener">开发技术前线</a> —— 《Android源码设计模式》作者 Mr.Simple 维护的社区网站</li>
<li><a href="http://gank.io" target="_blank" rel="noopener">干货集中营</a> —— 每日分享妹子图 和 技术干货，还有供大家中午休息的休闲视频</li>
<li><a href="http://bugly.qq.com/bbs/forum.php?mod=forumdisplay&fid=39" target="_blank" rel="noopener">腾讯 bugly 社区</a></li>
<li><a href="http://gold.xitu.io/explore/android" target="_blank" rel="noopener">掘金 Android</a></li>
<li><a href="https://www.v2ex.com/go/android" target="_blank" rel="noopener">V2ex-Android</a></li>
</ul>
<h2 id="开发工具第三方开源项目"><a href="#开发工具第三方开源项目" class="headerlink" title="开发工具第三方开源项目"></a>开发工具第三方开源项目</h2><ul>
<li><a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">AndroidDevTools</a> —— Android各种开发工具、SDK、资源</li>
<li><a href="https://github.com/Trinea/android-open-project" target="_blank" rel="noopener">Android 开源项目分类汇总</a> —— 史上最全的Android开源项目汇总</li>
<li><a href="http://app.memect.com/doc/android.html" target="_blank" rel="noopener">Android 资源库列表</a> —— 一个超级棒的安卓资源库列表</li>
<li><a href="http://www.oschina.net/question/2285044_219206?fromerr=gEGePPMG" target="_blank" rel="noopener">最强开发资源平台大合集</a> —— 各种UI图标库、工具集</li>
<li><a href="http://www.materialpalette.com" target="_blank" rel="noopener">MD 调色板</a></li>
<li><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">阿里矢量图标库</a></li>
<li><a href="https://icomoon.io/app/#/select" target="_blank" rel="noopener">Icon 图标</a> —— 各种icon图标</li>
<li><a href="http://www.flaticon.com" target="_blank" rel="noopener">图标下载库</a> —— 160,428 vector icons grouped in 2,409 packs</li>
<li><a href="https://github.com/l123456789jy/Lazy" target="_blank" rel="noopener">一些常用的开发工具类</a></li>
<li><a href="https://github.com/balsikandar/Android-Studio-Plugins" target="_blank" rel="noopener">Android-Studio-Plugins</a> —— This is a list of all awesome and useful android studio plugins.</li>
</ul>
<h2 id="视频学习网站"><a href="#视频学习网站" class="headerlink" title="视频学习网站"></a>视频学习网站</h2><ul>
<li><a href="http://chinagdg.org/google-videos/" target="_blank" rel="noopener">Google 官方性能优化视频</a> —— GDG中译版</li>
<li><a href="http://www.imooc.com/" target="_blank" rel="noopener">慕课网</a></li>
<li><a href="http://www.jikexueyuan.com/" target="_blank" rel="noopener">极客学院</a></li>
<li><a href="http://www.maiziedu.com/" target="_blank" rel="noopener">麦子学院</a></li>
<li><a href="https://www.udacity.com/courses/android" target="_blank" rel="noopener">Udacity Google 官方视频教程</a></li>
</ul>
<h2 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h2><ul>
<li><a href="https://github.com/CyC2018/Interview-Notebook" target="_blank" rel="noopener">技术面试需要掌握的基础知识整理</a></li>
<li><a href="https://mp.weixin.qq.com/s/pWclfrpvuaCtbxHvRzA73A" target="_blank" rel="noopener">2018 BAT等大厂最全面试题集锦</a></li>
<li><a href="https://github.com/JackyAndroid/AndroidInterview-Q-A/blob/master/README-CN.md" target="_blank" rel="noopener">国内一线互联网公司内部面试题库</a></li>
<li><a href="http://kymjs.com/code/2016/03/08/01/" target="_blank" rel="noopener">面试后的总结</a></li>
<li><a href="http://www.diycode.cc/wiki/androidinterview" target="_blank" rel="noopener">Android 开发工程师面试指南 Wiki</a></li>
<li><a href="http://blog.csdn.net/mc_hust/article/details/49517915" target="_blank" rel="noopener">很详细的 Android 工程师面试题大全</a></li>
<li><a href="https://github.com/android-cn/android-discuss/issues" target="_blank" rel="noopener">Android-discuss，可以作为面试题参考</a></li>
<li><a href="http://www.jianshu.com/p/1bdf7d0e1ac5" target="_blank" rel="noopener">Android 工程师面试题大全</a></li>
<li><a href="http://www.jianshu.com/p/5f6d79323923" target="_blank" rel="noopener">快速了解 Android 重要机制</a></li>
<li><a href="https://www.zhihu.com/question/30070178/answer/92849985" target="_blank" rel="noopener">知乎上回答的腾讯面经</a></li>
<li><a href="http://www.jianshu.com/p/f0d2ed1254a9" target="_blank" rel="noopener">BAT 无线工程师面试流程详细解析</a></li>
<li><a href="http://www.jianshu.com/p/d1efe2f31b6d" target="_blank" rel="noopener">史上最全 Android 面试资料集合</a></li>
<li><a href="http://www.bingjie.me/2016/05/12/扫清面试前的准备.html" target="_blank" rel="noopener">冰姐 - 扫清 Android 面试障碍–面试前的准备</a></li>
<li><a href="https://www.zybuluo.com/Yano/note/321063" target="_blank" rel="noopener">Java 虚拟机面试题全面解析</a></li>
<li><a href="http://www.jianshu.com/p/69141aa52f34?utm_source=desktop&utm_medium=timeline" target="_blank" rel="noopener">关于 Android 性能、架构和技术问题的探索</a></li>
</ul>
<h2 id="Kotlin学习"><a href="#Kotlin学习" class="headerlink" title="Kotlin学习"></a>Kotlin学习</h2><ul>
<li><a href="https://juejin.im/post/591dd9f544d904006c9fbb96" target="_blank" rel="noopener">Kotlin 资源大全 - 学 Kotlin 看这个就够了</a></li>
<li><a href="http://www.liying-cn.net/kotlin/docs/reference/" target="_blank" rel="noopener">Kotlin 参考文档</a></li>
<li><a href="https://github.com/mcxiaoke/awesome-kotlin" target="_blank" rel="noopener">awesome-kotlin</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 开源项目分类汇总</title>
    <url>/2018/01/15/androidhuiong/</url>
    <content><![CDATA[<h1 id="Android-开源项目分类汇总，更全更新可见-codekk-com"><a href="#Android-开源项目分类汇总，更全更新可见-codekk-com" class="headerlink" title="Android 开源项目分类汇总，更全更新可见 codekk.com"></a>Android 开源项目分类汇总，更全更新可见 <a href="http://p.codekk.com/" target="_blank" rel="noopener">codekk.com</a></h1><p>Other: <a href="https://github.com/Trinea/android-open-project/tree/master/English%20Version" target="_blank" rel="noopener">English Version</a>, <a href="https://github.com/Trinea/android-open-project/tree/master/%E7%B9%81%E9%AB%94%E4%B8%AD%E6%96%87%E7%89%88" target="_blank" rel="noopener">繁體版</a>, <a href="http://p.codekk.com/" target="_blank" rel="noopener">Website Version</a>.    </p>
<a id="more"></a>

<blockquote>
<p>我们的微信公众号：codekk。二维码如下：<br> 专注于 Android 开源分享、源码解析、框架设计、Android 内推。<br> <img src="http://www.trinea.cn/wp-content/uploads/2016/01/weixin-codekk-160.jpg" alt="img"><br> 我们的网站：<a href="http://a.codekk.com" target="_blank" rel="noopener">www.codekk.com</a>  </p>
</blockquote>
<h4 id="Android-开发调试效率数倍提升工具——开发助手-App-最新版，可从-Google-Play、应用宝、360-手机助手里搜索”开发助手”下载，或通过网页下载：Google-Play、应用宝、360-手机助手、本地下载"><a href="#Android-开发调试效率数倍提升工具——开发助手-App-最新版，可从-Google-Play、应用宝、360-手机助手里搜索”开发助手”下载，或通过网页下载：Google-Play、应用宝、360-手机助手、本地下载" class="headerlink" title="Android 开发调试效率数倍提升工具——开发助手 App 最新版，可从 Google Play、应用宝、360 手机助手里搜索”开发助手”下载，或通过网页下载：Google Play、应用宝、360 手机助手、本地下载"></a><a href="http://www.trinea.cn/dev-tools/development-tools/features-and-versions/" target="_blank" rel="noopener">Android 开发调试效率数倍提升工具——开发助手 App 最新版</a>，可从 Google Play、应用宝、360 手机助手里搜索”开发助手”下载，或通过网页下载：<a href="https://play.google.com/store/apps/details?id=cn.trinea.android.developertools" target="_blank" title="去 Google Play 下载开发助手">Google Play</a>、<a href="http://android.myapp.com/myapp/detail.htm?apkName=cn.trinea.android.developertools" target="_blank" title="去应用宝下载开发助手">应用宝</a>、<a href="http://zhushou.360.cn/detail/index/soft_id/3644614" target="_blank" title="去 360 手机助手下载开发助手">360 手机助手</a>、<a href="http://trinea.cn/app/dev-tools.apk" target="_blank" title="直接本地下载开发助手">本地下载</a></h4><h4 id="Android-开源项目源码解析-Volley、UIL、Dagger、EventBus、插件化库等分析"><a href="#Android-开源项目源码解析-Volley、UIL、Dagger、EventBus、插件化库等分析" class="headerlink" title="Android 开源项目源码解析(Volley、UIL、Dagger、EventBus、插件化库等分析)"></a><a href="http://a.codekk.com" target="_blank">Android 开源项目源码解析(Volley、UIL、Dagger、EventBus、插件化库等分析)</a></h4><h4 id="Android-职位内部推荐-阿里、腾讯、百度、京东、滴滴、美团、58、华为、网易、魅族等"><a href="#Android-职位内部推荐-阿里、腾讯、百度、京东、滴滴、美团、58、华为、网易、魅族等" class="headerlink" title="Android 职位内部推荐(阿里、腾讯、百度、京东、滴滴、美团、58、华为、网易、魅族等)"></a><a href="http://j.codekk.com" target="_blank">Android 职位内部推荐(阿里、腾讯、百度、京东、滴滴、美团、58、华为、网易、魅族等)</a></h4><h4 id="强大的-Android-开源项目搜索站"><a href="#强大的-Android-开源项目搜索站" class="headerlink" title="强大的 Android 开源项目搜索站"></a><a href="http://p.codekk.com" target="_blank">强大的 Android 开源项目搜索站</a></h4><p>欢迎大家推荐好的 Android 开源项目，开源项目添加到 <a href="http://p.codekk.com/add-project" target="_blank">Android 开源项目集合</a>，可以得到更多朋友的关注和反馈，欢迎<code>Star</code>、<code>Fork</code> :)  </p>
<blockquote>
<p><strong>关于我，欢迎关注</strong><br> 微博：<a title="Android 技术及移动互联网分享" href="http://weibo.com/trinea?s=6cm7D0" target="_blank">Trinea</a>&nbsp;&nbsp;&nbsp;&nbsp;主页：<a title="关注于 Android、Java、性能优化、开源项目" href="http://www.trinea.cn/" target="_blank">trinea.cn</a>  </p>
</blockquote>
<p>更多：<a href="http://www.trinea.cn/android/android-open-project-summary/" target="_blank" rel="noopener">Android 开源库获取途径整理</a><br>分享：<a href="http://service.weibo.com/share/share.php?url=https%3A%2F%2Fgithub.com%2FTrinea%2Fandroid-open-project&title=Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB%EF%BC%8C%E6%B1%87%E9%9B%86250%E5%A4%9A%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%8C%85%E6%8cB%AC%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6%E3%80%81%E5%B7%A5%E5%85%B7%E5%BA%93%E3%80%81%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%E3%80%81%E5%BC%80%E5%8F%91%E5%8F%8A%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E3%80%81%E4%BC%98%E7%A7%80%E4%B8%AA%E4%BA%BA%E5%92%8C%E5%9B%A2%E4%BD%93%40Trinea+&appkey=1657413438&searchPic=true" target="_blank" title="分享到新浪微博" style="width:100%"><img src="http://farm8.staticflickr.com/7342/13103239365_e5cd37fbac_o.png" title="分享到新浪微博"/></a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https%3A%2F%2Fgithub.com%2FTrinea%2Fandroid-open-project&title=Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB%EF%BC%8C%E6%B1%87%E9%9B%86250%E5%A4%9A%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6%E3%80%81%E5%B7%A5%E5%85%B7%E5%BA%93%E3%80%81%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%E3%80%81%E5%BC%80%E5%8F%91%E5%8F%8A%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E3%80%81%E4%BC%98%E7%A7%80%E4%B8%AA%E4%BA%BA%E5%92%8C%E5%9B%A2%E4%BD%93%40Trinea+&desc=&summary=&site=www.trinea.cn" target="_blank" title="分享到 QQ 空间" style="width:100%"><img src="http://farm8.staticflickr.com/7418/13103935825_209bd521f0_o.jpg"/></a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://share.v.t.qq.com/index.php?c=share&a=index&url=https%3A%2F%2Fgithub.com%2FTrinea%2Fandroid-open-project&title=Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB%EF%BC%8C%E6%B1%87%E9%9B%86250%E5%A4%9A%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6%E3%80%81%E5%B7%A5%E5%85%B7%E5%BA%93%E3%80%81%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%E3%80%81%E5%BC%80%E5%8F%91%E5%8F%8A%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E3%80%81%E4%BC%98%E7%A7%80%E4%B8%AA%E4%BA%BA%E5%92%8C%E5%9B%A2%E4%BD%93%40Trinea+&appkey=801404464" target="_blank" title="分享到腾讯微博" style="width:100%"><img src="http://farm8.staticflickr.com/7452/13104204564_f867971a13_o.png"/></a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://twitter.com/intent/tweet?text=Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB%EF%BC%8C%E6%B1%87%E9%9B%86250%E5%A4%9A%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6%E3%80%81%E5%B7%A5%E5%85%B7%E5%BA%93%E3%80%81%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%E3%80%81%E5%BC%80%E5%8F%91%E5%8F%8A%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E3%80%81%E4%BC%98%E7%A7%80%E4%B8%AA%E4%BA%BA%E5%92%8C%E5%9B%A2%E4%BD%93%40trinea_cn+https%3A%2F%2Fgithub.com%2FTrinea%2Fandroid-open-project&pic=" target="_blank" title="Share on twitter" style="width:100%"><img src="http://farm4.staticflickr.com/3764/13104038813_03933d4394_o.png"/></a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fgithub.com%2FTrinea%2Fandroid-open-project&t=Android%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB%EF%BC%8C%E6%B1%87%E9%9B%86250%E5%A4%9A%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6%E3%80%81%E5%B7%A5%E5%85%B7%E5%BA%93%E3%80%81%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%E3%80%81%E5%BC%80%E5%8F%91%E5%8F%8A%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E3%80%81%E4%BC%98%E7%A7%80%E4%B8%AA%E4%BA%BA%E5%92%8C%E5%9B%A2%E4%BD%93%40Trinea+&pic" target="_blank" title="Share on facebook" style="width:100%"><img src="http://farm4.staticflickr.com/3801/13104038583_b03d5cafac_o.png"/></a>  </p>
<h2 id="目前包括："><a href="#目前包括：" class="headerlink" title="目前包括："></a>目前包括：</h2><blockquote>
<p><a href="https://github.com/Trinea/android-open-project#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A7%E4%BB%B6view" target="_blank" rel="noopener">Android 开源项目第一篇——个性化控件(View)篇</a><br><em>&nbsp;&nbsp;包括<a href="https://github.com/Trinea/android-open-project#%E4%B8%80listview" target="_blank" rel="noopener">ListView</a>、<a href="https://github.com/Trinea/android-open-project#%E4%BA%8Cactionbar" target="_blank" rel="noopener">ActionBar</a>、<a href="https://github.com/Trinea/android-open-project#%E4%B8%89menu" target="_blank" rel="noopener">Menu</a>、<a href="https://github.com/Trinea/android-open-project#%E5%9B%9Bviewpager-gallery" target="_blank" rel="noopener">ViewPager</a>、<a href="https://github.com/Trinea/android-open-project#%E5%9B%9Bviewpager-gallery" target="_blank" rel="noopener">Gallery</a>、<a href="https://github.com/Trinea/android-open-project#%E4%BA%94gridview" target="_blank" rel="noopener">GridView</a>、<a href="https://github.com/Trinea/android-open-project#%E5%85%ADimageview" target="_blank" rel="noopener">ImageView</a>、<a href="https://github.com/Trinea/android-open-project#%E4%B8%83progressbar" target="_blank" rel="noopener">ProgressBar</a>、<a href="https://github.com/Trinea/android-open-project#%E5%85%ABtextview" target="_blank" rel="noopener">TextView</a>、<a href="https://github.com/Trinea/android-open-project#%E4%B9%9Dscrollview" target="_blank" rel="noopener">ScrollView</a>、<a href="https://github.com/Trinea/android-open-project#%E5%8D%81timeview" target="_blank" rel="noopener">TimeView</a>、<a href="https://github.com/Trinea/android-open-project#%E5%8D%81%E4%B8%80tipview" target="_blank" rel="noopener">TipView</a>、<a href="https://github.com/Trinea/android-open-project#%E5%8D%81%E4%BA%8Cflipview" target="_blank" rel="noopener">FlipView</a>、<a href="https://github.com/Trinea/android-open-project#%E5%8D%81%E4%B8%89colorpickview" target="_blank" rel="noopener">ColorPickView</a>、<a href="https://github.com/Trinea/android-open-project#%E5%8D%81%E5%9B%9Bgraphview" target="_blank" rel="noopener">GraphView</a>、<a href="https://github.com/Trinea/android-open-project#%E5%8D%81%E4%BA%94ui-style" target="_blank" rel="noopener">UI Style</a>、<a href="https://github.com/Trinea/android-open-project#十六其他" target="_blank" rel="noopener">其他</a></em><br><a href="https://github.com/Trinea/android-open-project#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%B7%A5%E5%85%B7%E5%BA%93" target="_blank" rel="noopener">Android 开源项目第二篇——工具库篇</a><br><em>&nbsp;&nbsp;包括<a href="https://github.com/Trinea/android-open-project#一依赖注入-di" target="_blank" rel="noopener">依赖注入</a>、<a href="https://github.com/Trinea/android-open-project#二图片缓存" target="_blank" rel="noopener">图片缓存</a>、<a href="https://github.com/Trinea/android-open-project#三网络请求" target="_blank" rel="noopener">网络请求</a>、<a href="https://github.com/Trinea/android-open-project#四数据库-orm-工具包" target="_blank" rel="noopener">数据库 ORM 工具包</a>、<a href="https://github.com/Trinea/android-open-project#五android-公共库" target="_blank" rel="noopener">Android 公共库</a>、<a href="https://github.com/Trinea/android-open-project#六android-高版本向低版本兼容" target="_blank" rel="noopener">高版本向低版本兼容库</a>、<a href="https://github.com/Trinea/android-open-project#七多媒体相关" target="_blank" rel="noopener">多媒体</a>、<a href="https://github.com/Trinea/android-open-project#八事件总线订阅者模式" target="_blank" rel="noopener">事件总线</a>、<a href="https://github.com/Trinea/android-open-project#九传感器" target="_blank" rel="noopener">传感器</a>、<a href="https://github.com/Trinea/android-open-project#十安全" target="_blank" rel="noopener">安全</a>、<a href="https://github.com/Trinea/android-open-project#十一插件化" target="_blank" rel="noopener">插件化</a>、<a href="https://github.com/Trinea/android-open-project#十二文件" target="_blank" rel="noopener">文件</a>、<a href="https://github.com/Trinea/android-open-project#十三其他" target="_blank" rel="noopener">其他</a></em><br><a href="https://github.com/Trinea/android-open-project#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE" target="_blank" rel="noopener">Android 开源项目第三篇——优秀项目篇</a><br><em>&nbsp;&nbsp;比较有意思的完整的 Android 项目</em><br><a href="https://github.com/Trinea/android-open-project#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7" target="_blank" rel="noopener">Android 开源项目第四篇——开发及测试工具篇</a><br><em>&nbsp;&nbsp;包括<a href="https://github.com/Trinea/android-open-project#一开发效率工具" target="_blank" rel="noopener">开发效率工具</a>、<a href="https://github.com/Trinea/android-open-project#二开发自测相关" target="_blank" rel="noopener">开发自测相关</a>、<a href="https://github.com/Trinea/android-open-project#三测试工具" target="_blank" rel="noopener">测试工具</a>、<a href="https://github.com/Trinea/android-open-project#四开发及编译环境" target="_blank" rel="noopener">开发及编译环境</a>、<a href="https://github.com/Trinea/android-open-project#五其他" target="_blank" rel="noopener">其他</a></em><br><a href="https://github.com/Trinea/android-open-project#%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86" target="_blank" rel="noopener">Android 开源项目第五篇——优秀个人和团体篇</a><br><em>&nbsp;&nbsp;乐于分享并且有一些很不错的开源项目的<a href="https://github.com/Trinea/android-open-project#一个人" target="_blank" rel="noopener">个人</a>和<a href="https://github.com/Trinea/android-open-project#二组织" target="_blank" rel="noopener">组织</a>，包括 JakeWharton、Chris Banes、Koushik Dutta 等大牛</em>  </p>
</blockquote>
<h2 id="第一部分-个性化控件-View"><a href="#第一部分-个性化控件-View" class="headerlink" title="第一部分 个性化控件(View)"></a>第一部分 个性化控件(View)</h2><p>主要介绍那些不错个性化的 View，包括 ListView、ActionBar、Menu、ViewPager、Gallery、GridView、ImageView、ProgressBar、TextView、ScrollView、TimeView、TipView、FlipView、ColorPickView、GraphView、UI Style 等等。  </p>
<h4 id="一、ListView"><a href="#一、ListView" class="headerlink" title="一、ListView"></a>一、ListView</h4><ol>
<li><p>android-pulltorefresh<br>一个强大的拉动刷新开源项目，支持各种控件下拉刷新，ListView、ViewPager、WebView、ExpandableListView、GridView、ScrollView、Horizontal  ScrollView、Fragment 上下左右拉动刷新，比下面 johannilsson 那个只支持 ListView 的强大的多。并且它实现的下拉刷新 ListView 在 item 不足一屏情况下也不会显示刷新提示，体验更好。<br>项目地址：<a href="https://github.com/chrisbanes/Android-PullToRefresh" target="_blank" rel="noopener">https://github.com/chrisbanes/Android-PullToRefresh</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/pull-to-refreshview-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/pull-to-refreshview-demo.apk?raw=true</a><br>APP 示例：新浪微博各个页面  </p>
</li>
<li><p>android-pulltorefresh-listview<br>下拉刷新 ListView，这个被很多人使用的项目实际有不少 bug，推荐使用 <a href="https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh" target="_blank" rel="noopener">android-Ultra-Pull-to-Refresh</a><br>项目地址：<a href="https://github.com/johannilsson/android-pulltorefresh" target="_blank" rel="noopener">https://github.com/johannilsson/android-pulltorefresh</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/pull-to-refresh-listview-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/pull-to-refresh-listview-demo.apk?raw=true</a>  </p>
</li>
<li><p>android-Ultra-Pull-to-Refresh<br>下拉刷新，第一个项目已经停止维护了，并且使用起来相对复杂，定制性也差。这个是替代和改良方案。这个继承于 ViewGroup 可以包含任何 View。功能甚至比 SwipeRefreshLayout 强大。使用起来非常简单。良好的设计，如果你想定制自己的 UI 样式，非常简单，就像给 ListView 加一个 Header View 那么简单。支持 <code>API LEVEL &gt;= 8</code><br>项目地址：<a href="https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh" target="_blank" rel="noopener">https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh</a><br>原理剖析文档：[android-Ultra-Pull-to-Refresh](<a href="http://a.codekk.com/detail/Android/Grumoon/android-Ultra-Pull-To-Refresh" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/Grumoon/android-Ultra-Pull-To-Refresh</a> 源码解析)<br>Demo 地址：<a href="https://raw.githubusercontent.com/liaohuqiu/android-Ultra-Pull-To-Refresh/master/ptr-demo.apk" target="_blank" rel="noopener">https://raw.githubusercontent.com/liaohuqiu/android-Ultra-Pull-To-Refresh/master/ptr-demo.apk</a><br>效果图：<img src="http://srain-github.qiniudn.com/ultra-ptr/contains-all-of-views.gif" alt="Renderings"><br><a href="http://srain-github.qiniudn.com/ultra-ptr/release-to-refresh.gif" target="_blank" rel="noopener">http://srain-github.qiniudn.com/ultra-ptr/release-to-refresh.gif</a><br><a href="http://srain-github.qiniudn.com/ultra-ptr/auto-refresh.gif" target="_blank" rel="noopener">http://srain-github.qiniudn.com/ultra-ptr/auto-refresh.gif</a><br><a href="http://srain-github.qiniudn.com/ultra-ptr/store-house-string-array.gif" target="_blank" rel="noopener">http://srain-github.qiniudn.com/ultra-ptr/store-house-string-array.gif</a>  </p>
</li>
<li><p>Android-PullToRefreshRecyclerView<br>支持下拉刷新的RecyclerView，同时支持滑动到底部自动加载数据、给RecyclerView添加Header。并且不更改原有RecyclerView的逻辑。<br><img src="https://github.com/HomHomLin/Android-PullToRefreshRecyclerView/blob/master/screenshot.gif" alt="Screenshot"><br>项目地址：<a href="https://github.com/HomHomLin/Android-PullToRefreshRecyclerView" target="_blank" rel="noopener">https://github.com/HomHomLin/Android-PullToRefreshRecyclerView</a><br>Demo地址：<a href="https://github.com/HomHomLin/Android-PullToRefreshRecyclerView/blob/master/sample.apk" target="_blank" rel="noopener">https://github.com/HomHomLin/Android-PullToRefreshRecyclerView/blob/master/sample.apk</a>  </p>
</li>
<li><p>DragSortListView<br>拖动排序的 ListView，同时支持 ListView 滑动 item 删除，各个 Item 高度不一、单选、复选、CursorAdapter 做为适配器、拖动背景变化等<br>项目地址：<a href="https://github.com/bauerca/drag-sort-listview" target="_blank" rel="noopener">https://github.com/bauerca/drag-sort-listview</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.mobeta.android.demodslv" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.mobeta.android.demodslv</a><br>APP 示例：Wordpress Android  </p>
</li>
<li><p>SwipeListView<br>支持定义 ListView 左右滑动事件，支持左右滑动位移，支持定义动画时间<br>项目地址：<a href="https://github.com/47deg/android-swipelistview" target="_blank" rel="noopener">https://github.com/47deg/android-swipelistview</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.fortysevendeg.android.swipelistview" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.fortysevendeg.android.swipelistview</a><br>APP 示例：微信 </p>
</li>
<li><p>Android-SlidingLayout<br>实现类似QQ、微信ListView和WebView的上拉下拉弹跳效果和iOS的ListView的果冻效果。兼容Android自带库和兼容库的所有View组件，包括RecyclerView、ListView、ScrollView以及WebView等等。<br><img src="https://raw.githubusercontent.com/HomHomLin/SlidingLayout/master/pic/list.gif" alt="p1"><br><img src="https://raw.githubusercontent.com/HomHomLin/SlidingLayout/master/pic/webview.gif" alt="p2"><br>项目地址：<a href="https://github.com/HomHomLin/SlidingLayout/。" target="_blank" rel="noopener">https://github.com/HomHomLin/SlidingLayout/。</a><br>Demo地址：<a href="https://github.com/HomHomLin/SlidingLayout/tree/master/demo" target="_blank" rel="noopener">https://github.com/HomHomLin/SlidingLayout/tree/master/demo</a>  </p>
</li>
<li><p>SlideAndDragListView<br>支持ListView的Item的拖动排序、左右滑动事件，可自定义左右滑动显示文字、图标、位移，同时支持onItemClick、onItemLongClick等监听器，提供丰富的回调接口。<br>项目地址：<a href="https://github.com/yydcdut/SlideAndDragListView" target="_blank" rel="noopener">https://github.com/yydcdut/SlideAndDragListView</a><br>Demo 地址：<a href="https://github.com/yydcdut/SlideAndDragListView/blob/master/apk/sdlv.apk?raw=true" target="_blank" rel="noopener">https://github.com/yydcdut/SlideAndDragListView/blob/master/apk/sdlv.apk?raw=true</a><br>APP 示例：Android 手机QQ 5.0<br>效果图：<img src="https://raw.githubusercontent.com/yydcdut/SlideAndDragListView/master/gif/v1.1.gif" alt="Renderings">  </p>
</li>
<li><p>Android-SwipeToDismiss<br>滑动 Item 消失 ListView，支持 3.0 以下版本见：<a href="https://github.com/JakeWharton/SwipeToDismissNOA" target="_blank" rel="noopener">https://github.com/JakeWharton/SwipeToDismissNOA</a><br>项目地址：<a href="https://github.com/romannurik/Android-SwipeToDismiss" target="_blank" rel="noopener">https://github.com/romannurik/Android-SwipeToDismiss</a><br>Demo 地址：<a href="https://github.com/JakeWharton/SwipeToDismissNOA/SwipeToDismissNOA.apk/qr_code" target="_blank" rel="noopener">https://github.com/JakeWharton/SwipeToDismissNOA/SwipeToDismissNOA.apk/qr_code</a>  </p>
</li>
<li><p>RecyclerViewSwipeDismiss<br>轻量级支持 support-v7 中的 RecyclerView 的滑动删除(Swipe to dismiss)行为，不需要修改源代码，只要简单的绑定<code>onTouchListener</code><br>项目地址：<a href="https://github.com/CodeFalling/RecyclerViewSwipeDismiss" target="_blank" rel="noopener">https://github.com/CodeFalling/RecyclerViewSwipeDismiss</a><br>效果图：<img src="https://raw.githubusercontent.com/CodeFalling/RecyclerViewSwipeDismiss/master/RecyclerViewSwipeDismiss.gif" alt="Renderings">  </p>
</li>
<li><p>QuickSideBar<br>帮助快速查阅对应分组的侧边栏，可以配合任意列表，demo中给出配合RecyclerView(浮动分组使用stickyheadersrecyclerview)。<br>项目地址：<a href="https://github.com/saiwu-bigkoo/Android-QuickSideBar" target="_blank" rel="noopener">https://github.com/saiwu-bigkoo/Android-QuickSideBar</a><br>效果图：<img src="https://github.com/saiwu-bigkoo/Android-QuickSideBar/blob/master/preview/quicksidebardemo.gif" alt="Renderings"> </p>
</li>
<li><p>async-expandable-list<br>支持异步加载子列表的 ExpandableListView，包括CollectionView可以显示小标题的列表<br>项目地址：<a href="https://github.com/Ericliu001/async-expandable-list" target="_blank" rel="noopener">https://github.com/Ericliu001/async-expandable-list</a></p>
</li>
</ol>
<p>效果图：</p>
<p><img src="https://cloud.githubusercontent.com/assets/3691022/19348717/0d6c98ec-919b-11e6-97c3-a8ff782a059b.gif" alt="Demo">  <img src="https://cloud.githubusercontent.com/assets/3691022/19406879/cb982648-92da-11e6-86bf-7c82e8505e6c.gif" alt="Demo"></p>
<ol>
<li><p>PinnedHeaderExpandableListView<br>首先它是一个 ExpandableListView，但是它的头部可以固定，其次，在它的上面还有一个头部可以来回伸缩<br>项目地址：<a href="https://github.com/singwhatiwanna/PinnedHeaderExpandableListView" target="_blank" rel="noopener">https://github.com/singwhatiwanna/PinnedHeaderExpandableListView</a><br>效果图：<img src="https://camo.githubusercontent.com/fa7f516b0b6e2921007a17cbc359b3f661f32226/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f32303134303531313135313534363834333f77617465726d61726b2f322f746578742f6148523063446f764c324a736232637559334e6b626935755a58517663326c755a33646f5958527064324675626d453d2f666f6e742f3561364c354c32542f666f6e7473697a652f3430302f66696c6c2f49304a42516b46434d413d3d2f646973736f6c76652f37302f677261766974792f536f75746845617374" alt="Renderings"><br>APP 示例：百度手机卫士垃圾清理界面  </p>
</li>
<li><p>StickyListHeaders<br>GroupName 滑动到顶端时会固定不动直到另外一个 GroupName 到达顶端的 ExpandListView，支持快速滑动，支持 Android2.3 及以上<br>项目地址：<a href="https://github.com/emilsjolander/StickyListHeaders" target="_blank" rel="noopener">https://github.com/emilsjolander/StickyListHeaders</a><br>效果图：<img src="https://raw.github.com/emilsjolander/StickyListHeaders/master/demo.gif" alt="Renderings"><br>APP 示例：Android 4.0 联系人  </p>
</li>
<li><p>pinned-section-listview<br>GroupName 滑动到顶端时会固定不动直到另外一个 GroupName 到达顶端的 ExpandListView<br>项目地址：<a href="https://github.com/beworker/pinned-section-listview" target="_blank" rel="noopener">https://github.com/beworker/pinned-section-listview</a><br>效果图：<img src="https://raw.github.com/beworker/pinned-section-listview/master/screen1.png" alt="Renderings">  </p>
</li>
<li><p>PinnedHeaderListView<br>GroupName 滑动到顶端时会固定不动直到另外一个 GroupName 到达顶端的 ExpandListView<br>项目地址：<a href="https://github.com/JimiSmith/PinnedHeaderListView" target="_blank" rel="noopener">https://github.com/JimiSmith/PinnedHeaderListView</a>  </p>
</li>
<li><p>QuickReturn<br>ListView/ScrollView 的 header 或 footer，当向下滚动时消失，向上滚动时出现<br>项目地址：<a href="https://github.com/lawloretienne/QuickReturn" target="_blank" rel="noopener">https://github.com/lawloretienne/QuickReturn</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.etiennelawlor.quickreturn" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.etiennelawlor.quickreturn</a>  </p>
</li>
<li><p>QuickReturnHeader<br>ListView/ScrollView 的 header 或 footer，当向下滚动时消失，向上滚动时出现<br>项目地址：<a href="https://github.com/ManuelPeinado/QuickReturnHeader" target="_blank" rel="noopener">https://github.com/ManuelPeinado/QuickReturnHeader</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/quick-return-header-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/quick-return-header-demo.apk?raw=true</a><br>APP 示例：google plus  </p>
</li>
<li><p>IndexableListView<br>ListView 右侧会显示 item 首字母快捷索引，点击可快速滑动到某个 item<br>项目地址：<a href="https://github.com/woozzu/IndexableListView" target="_blank" rel="noopener">https://github.com/woozzu/IndexableListView</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/indexable-listview.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/indexable-listview.apk?raw=true</a><br>APP 示例：微信通讯录、小米联系人  </p>
</li>
<li><p>CustomFastScrollView<br>ListView 快速滑动，同时屏幕中间 PopupWindows 显示滑动到的 item 内容或首字母<br>项目地址：<a href="https://github.com/nolanlawson/CustomFastScrollViewDemo" target="_blank" rel="noopener">https://github.com/nolanlawson/CustomFastScrollViewDemo</a><br>效果图：<img src="https://raw.github.com/nolanlawson/CustomFastScrollViewDemo/master/example.png" alt="Renderings">  </p>
</li>
<li><p>Android-ScrollBarPanel<br>ListView 滑动时固定的 Panel 指示显示在 scrollbar 旁边<br>项目地址：<a href="https://github.com/rno/Android-ScrollBarPanel" target="_blank" rel="noopener">https://github.com/rno/Android-ScrollBarPanel</a><br>效果图：<img src="https://github.com/rno/Android-ScrollBarPanel/raw/master/demo_capture.png" alt="Renderings">  </p>
</li>
<li><p>SlideExpandableListView<br>用户点击 listView item 滑出固定区域，其他 item 的区域收缩<br>项目地址：<a href="https://github.com/tjerkw/Android-SlideExpandableListView" target="_blank" rel="noopener">https://github.com/tjerkw/Android-SlideExpandableListView</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/slide-expandable-listView-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/slide-expandable-listView-demo.apk?raw=true</a>  </p>
</li>
<li><p>JazzyListView<br>ListView 及 GridView item 以特殊动画效果进入屏幕，效果包括 grow、cards、curl、wave、flip、fly 等等<br>项目地址：<a href="https://github.com/twotoasters/JazzyListView" target="_blank" rel="noopener">https://github.com/twotoasters/JazzyListView</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.twotoasters.jazzylistview.sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.twotoasters.jazzylistview.sample</a><br>在线演示：<a href="http://lab.hakim.se/scroll-effects/" target="_blank" rel="noopener">http://lab.hakim.se/scroll-effects/</a>  </p>
</li>
<li><p>ListViewAnimations<br>带 Item 显示动画的 ListView，动画包括底部飞入、其他方向斜飞入、下层飞入、渐变消失、滑动删除等<br>项目地址：<a href="https://github.com/nhaarman/ListViewAnimations" target="_blank" rel="noopener">https://github.com/nhaarman/ListViewAnimations</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.haarman.listviewanimations" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.haarman.listviewanimations</a><br>APP 示例：Google plus、Google Now 卡片式进入、小米系统中应用商店、联系人、游戏中心、音乐、文件管理器的 ListView、Ultimate、Light Flow Lite、TreinVerkeer、Running Coach、Pearl Jam Lyrics、Calorie Chart、Car Hire、Super BART、DK FlashCards、Counter Plus、Voorlees Verhaaltjes 2.0  </p>
</li>
<li><p>DevsmartLib-Android<br>横向 ListView<br>项目地址：<a href="https://github.com/dinocore1/DevsmartLib-Android" target="_blank" rel="noopener">https://github.com/dinocore1/DevsmartLib-Android</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/horizontal-listview-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/horizontal-listview-demo.apk?raw=true</a>  </p>
</li>
<li><p>TwoWayView<br>横向 ListView 的效果，继承自 AdapterView<br>项目地址：<a href="https://github.com/lucasr/twoway-view" target="_blank" rel="noopener">https://github.com/lucasr/twoway-view</a>  </p>
</li>
<li><p>HorizontalVariableListView<br>支持 Item 宽度不一致的 ListView<br>项目地址：<a href="https://github.com/sephiroth74/HorizontalVariableListView" target="_blank" rel="noopener">https://github.com/sephiroth74/HorizontalVariableListView</a>  </p>
</li>
<li><p>LinearListView<br>用 LinearLayout 实现的 ListView，可解决多个 ListView 并存等问题。目前自己也有需要，等亲自尝试过后会再具体介绍<br>项目地址：<a href="https://github.com/frankiesardo/LinearListView" target="_blank" rel="noopener">https://github.com/frankiesardo/LinearListView</a>  </p>
</li>
<li><p>MultiChoiceAdapter<br>支持多选的 ListView Adapter<br>项目地址：<a href="https://github.com/ManuelPeinado/MultiChoiceAdapter" target="_blank" rel="noopener">https://github.com/ManuelPeinado/MultiChoiceAdapter</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.manuelpeinado.multichoiceadapter.demo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.manuelpeinado.multichoiceadapter.demo</a>  </p>
</li>
<li><p>EnhancedListView<br>支持横向滑动删除列表项以及撤销删除的 ListView，该项目的前身是<a href="https://github.com/timroes/SwipeToDismissUndoList" target="_blank" rel="noopener">SwipeToDismissUndoList</a><br>项目地址：<a href="https://github.com/timroes/EnhancedListView" target="_blank" rel="noopener">https://github.com/timroes/EnhancedListView</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=de.timroes.android.listviewdemo&amp;rdid=de.timroes.android.listviewdemo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=de.timroes.android.listviewdemo&amp;rdid=de.timroes.android.listviewdemo</a>  </p>
</li>
<li><p>ListBuddies<br>自动滚动的双列 ListView ，两个 ListView 滚动速度不一致，有视差效果<br>项目地址：<a href="https://github.com/jpardogo/ListBuddies" target="_blank" rel="noopener">https://github.com/jpardogo/ListBuddies</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.jpardogo.android.listbuddies" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.jpardogo.android.listbuddies</a><br>效果图：<img src="https://raw.github.com/jpardogo/ListBuddies/master/art/screenshot_listbuddies_2.png" alt="Renderings">  </p>
</li>
<li><p>SwipeMenuListView<br>针对 ListView item 的侧滑菜单<br>项目地址：<a href="https://github.com/baoyongzhang/SwipeMenuListView" target="_blank" rel="noopener">https://github.com/baoyongzhang/SwipeMenuListView</a><br>效果图：<img src="https://raw.githubusercontent.com/baoyongzhang/SwipeMenuListView/master/demo.gif" alt="Renderings"><br>APP 示例：手机 QQV5.0  </p>
</li>
<li><p>PagingListView<br>分页加载的 ListView。当滑动到 ListView 底部最后一个元素时，显示一个进度行，然后加载下一页数据，并显示。<br>项目地址：<a href="https://github.com/nicolasjafelle/PagingListView" target="_blank" rel="noopener">https://github.com/nicolasjafelle/PagingListView</a>  </p>
</li>
<li><p>PullZoomView<br>支持下拉时 HeaderView 缩放的 ListView、ScrollView<br>项目地址：<a href="https://github.com/Frank-Zhu/PullZoomView" target="_blank" rel="noopener">https://github.com/Frank-Zhu/PullZoomView</a><br>效果图：<img src="https://raw.githubusercontent.com/Frank-Zhu/PullZoomView/master/art/pull-to-zoom.gif" alt="Renderings">  </p>
</li>
<li><p>PullToZoomInListView<br>滑动 ListView 时使其 HeaderView 跟随滑动缩放<br>项目地址：<a href="https://github.com/matrixxun/PullToZoomInListView" target="_blank" rel="noopener">https://github.com/matrixxun/PullToZoomInListView</a><br>效果图：<img src="https://github.com/matrixxun/PullToZoomInListView/raw/master/art/pull-to-zoom.gif" alt="Renderings">  </p>
</li>
<li><p>CalendarListview<br>实现每个月一行日历效果的 ListView<br>项目地址：<a href="https://github.com/traex/CalendarListview" target="_blank" rel="noopener">https://github.com/traex/CalendarListview</a><br>原理剖析文档：<a href="http://a.codekk.com/detail/Android/Rogary/CalendarListView%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="noopener">CalendarListview</a><br>效果图：<img src="https://github.com/traex/CalendarListview/raw/master/demo.gif" alt="Renderings">  </p>
</li>
<li><p>sticky-headers-recyclerview<br>GroupName 滑动到顶端时会固定不动直到另外一个 GroupName 到达顶端的 ListView，采用 support-v7 中的 RecyclerView 实现<br>项目地址：<a href="https://github.com/timehop/sticky-headers-recyclerview" target="_blank" rel="noopener">https://github.com/timehop/sticky-headers-recyclerview</a>  </p>
</li>
<li><p>PullSeparateListView<br>到达顶部或底部继续拉动时，实现 Item 间的相互分离，两种模式：(1) 全部分离的模式，即屏幕内所有 Item 都会分离 (2)部分分离模式，以点击位置为分界点，部分 item 分离<br>项目地址：<a href="https://github.com/chiemy/PullSeparateListView" target="_blank" rel="noopener">https://github.com/chiemy/PullSeparateListView</a><br>效果图：<img src="https://github.com/chiemy/PullSeparateListView/raw/master/capture.gif" alt="Renderings">  </p>
</li>
<li><p>ExpandableLayout<br>Header 和 Content Item 都可以展开的 ExpandableListview<br>项目地址：<a href="https://github.com/traex/ExpandableLayout" target="_blank" rel="noopener">https://github.com/traex/ExpandableLayout</a>  </p>
</li>
<li><p>PagedHeadListView<br>支持 paginated header 以及 material page indicator 的 ListView.<br>项目地址：<a href="https://github.com/JorgeCastilloPrz/PagedHeadListView" target="_blank" rel="noopener">https://github.com/JorgeCastilloPrz/PagedHeadListView</a><br>效果图：<img src="https://raw.githubusercontent.com/JorgeCastilloPrz/PagedHeadListView/master/app/src/main/res/raw/preview1.gif" alt="Renderings">  </p>
</li>
<li><p>CustomSwipeListView<br>支持左滑弹出自定义菜单，右滑删除且允许撤销，同时可以自定义滑动动画时间和滑动触发事件的时机等。<br>项目地址：<a href="https://github.com/xyczero/Android-CustomSwipeListView" target="_blank" rel="noopener">https://github.com/xyczero/Android-CustomSwipeListView</a><br>Demo 地址：<a href="http://7u2jsw.com1.z0.glb.clouddn.com/githubCustomSwipeListView.apk" target="_blank" rel="noopener">Download here</a><br>效果图：<img src="http://7u2jsw.com1.z0.glb.clouddn.com/githubCustomSwipeListview_Set.PNG" alt="Renderings">  </p>
</li>
<li><p>Pull-to-Refresh.Rentals-Android<br>提供一个简单可以自定义的下拉刷新实现，<a href="http://yalantis.com/" target="_blank" rel="noopener">Yalantis</a> 出品。<br>项目地址：<a href="https://github.com/Yalantis/Pull-to-Refresh.Rentals-Android" target="_blank" rel="noopener">https://github.com/Yalantis/Pull-to-Refresh.Rentals-Android</a><br>效果图：<img src="https://camo.githubusercontent.com/d406ac5a03a2b1fa5cf41fadc8d2408cb8709bdc/68747470733a2f2f6431337961637572716a676172612e636c6f756466726f6e742e6e65742f75736572732f3132353035362f73637265656e73686f74732f313635303331372f7265616c6573746174652d70756c6c5f312d322d332e676966" alt="Renderings">  </p>
</li>
<li><p>ScrollerCalendar<br>实现每行显示一年的 12 个月份的 RecyclerView 年历<br>项目地址：<a href="https://github.com/guanchao/ScrollerCalendar" target="_blank" rel="noopener">https://github.com/guanchao/ScrollerCalendar</a><br>效果图：<img src="https://raw.githubusercontent.com/guanchao/ScrollerCalendar/master/images/sample2.gif" alt="Renderings">  </p>
</li>
<li><p>ExtractWordView<br>一个可以提取单词的 ListView,支持”放大镜”效果。<br>项目地址：<a href="https://github.com/jcodeing/ExtractWordView" target="_blank" rel="noopener">https://github.com/jcodeing/ExtractWordView</a><br>Demo 地址：<a href="https://raw.githubusercontent.com/jcodeing/ExtractWordView/master/ExtractWordView-demo.apk" target="_blank" rel="noopener">Download here</a><br><img src="https://raw.githubusercontent.com/jcodeing/ExtractWordView/master/lookme.gif" alt="Renderings">  </p>
</li>
<li><p>FlyRefresh<br>支持 ListView, GridView, RecyclerView, ScrollView 的下拉刷新<br>项目地址：<a href="https://github.com/race604/FlyRefresh" target="_blank" rel="noopener">https://github.com/race604/FlyRefresh</a><br>效果图：<img src="https://raw.githubusercontent.com/race604/FlyRefresh/master/images/flyrefresh.gif" alt="Renderings">  </p>
</li>
<li><p>MVCHelper<br>实现下拉刷新，滚动底部自动加载更多，分页加载，自动切换显示网络失败布局，暂无数据布局，支持任意 view，真正的 MVC 架构<br>支持切换主流下拉刷新框架 Android-PullToRefresh-Library,android-Ultra-Pull-To-Refresh-library，SwipeRefreshLayout<br>项目地址：<a href="https://github.com/LuckyJayce/MVCHelper" target="_blank" rel="noopener">https://github.com/LuckyJayce/MVCHelper</a><br>Demo 地址：<a href="https://github.com/LuckyJayce/MVCHelper/blob/master/raw/MVCHelper_Demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/LuckyJayce/MVCHelper/blob/master/raw/MVCHelper_Demo.apk?raw=true</a>  </p>
</li>
<li><p>RecyclerViewSwipeDismiss<br>支持滑动 Item 操作、点击展开、拖动排序、展开后拖动排序等特性的 RecyclerView<br>项目地址：<a href="https://play.google.com/store/apps/details?id=com.h6ah4i.android.example.advrecyclerview" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.h6ah4i.android.example.advrecyclerview</a><br>视频：<a href="http://www.youtube.com/watch?feature=player_embedded&amp;v=S7cSwMArjUQ" target="_blank" rel="noopener">http://www.youtube.com/watch?feature=player_embedded&amp;v=S7cSwMArjUQ</a>  </p>
</li>
<li><p>WaterDropListView<br>模仿 iOS 下拉刷新“水滴”效果，支持下拉刷新和上拉加载<br>项目地址：<a href="https://github.com/THEONE10211024/WaterDropListView" target="_blank" rel="noopener">https://github.com/THEONE10211024/WaterDropListView</a><br>效果图：<img src="https://github.com/THEONE10211024/WaterDropListView/blob/master/demo/demo.gif" alt="Renderings">  </p>
</li>
<li><p>PopupListView<br>實現ListItem 點擊後置頂並可顯示客製化添加的item的內部View 的ListView<br>项目地址：<a href="https://github.com/s8871404/PopupListView" target="_blank" rel="noopener">https://github.com/s8871404/PopupListView</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.baobomb.popuplistview_sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.baobomb.popuplistview_sample</a><br>效果图：<img src="https://github.com/s8871404/PopupListView/blob/master/example.gif" alt="Renderings">   </p>
</li>
<li><p>CircleRefreshLayout<br>一个包含有趣的动画的自定义下拉刷新布局<br>项目地址：<a href="https://github.com/tuesda/CircleRefreshLayout" target="_blank" rel="noopener">https://github.com/tuesda/CircleRefreshLayout</a><br>效果图：<br><img src="https://raw.githubusercontent.com/tuesda/CircleRefreshLayout/master/gif/circlerefresh.gif" alt="Renderings">   </p>
</li>
<li><p>EasyRecyclerView<br>一款简单易用的EasyRecyclerView</p>
</li>
<li><p>提供EasyRecyclerView，不需要写太多RecyclerView的配置代码  </p>
</li>
<li><p>提供好一个可以适配单布局和多布局的RecyclerViewAdapter  </p>
</li>
<li><p>提供了分割线的实现类，只需要传入一个DrawableId<br>项目地址：<a href="https://github.com/CaMnter/EasyRecyclerView" target="_blank" rel="noopener">https://github.com/CaMnter/EasyRecyclerView</a>  </p>
</li>
<li><p>CanRefresh<br>可适配所有视图的下拉刷新上拉加载，并支持各种风格<br>项目地址：<a href="https://github.com/canyinghao/CanRefresh" target="_blank" rel="noopener">https://github.com/canyinghao/CanRefresh</a><br>效果图：<br><img src="https://raw.githubusercontent.com/canyinghao/CanRefresh/master/pic/CanRefresh.gif" alt="Renderings">   </p>
</li>
<li><p>NestRefreshLayout<br>下拉刷新及加载更多控件，支持多种View，可以自定义Header和Footer<br>由于实现了NestedScrollingChild和NestedScrollingParent所以与Support-Design兼容，可以配合CollapsingToolbarLayout使用<br>项目地址：<a href="https://github.com/anzewei/NestRefreshLayout" target="_blank" rel="noopener">https://github.com/anzewei/NestRefreshLayout</a><br>Demo 地址：<a href="https://github.com/anzewei/NestRefreshLayout/blob/master/ext/sample-debug.apk?raw=true" target="_blank" rel="noopener">https://github.com/anzewei/NestRefreshLayout/blob/master/ext/sample-debug.apk?raw=true</a></p>
</li>
<li><p>SnappingSwipingRecyclerView<br>实现了类似微信读书首页的长按之后滑动删除的特效和动画</p>
<img src="https://raw.githubusercontent.com/CarlLee/SnappingSwipingRecyclerView/master/preview.gif" height="480" width="320" >
项目地址:https://github.com/CarlLee/SnappingSwipingRecyclerView

</li>
</ol>
<h4 id="二、ActionBar"><a href="#二、ActionBar" class="headerlink" title="二、ActionBar"></a>二、ActionBar</h4><ol>
<li><p>ActionBarSherlock<br>为 Android 所有版本提供统一的 ActionBar，解决 4.0 以下 ActionBar 的适配问题<br>项目地址：<a href="https://github.com/JakeWharton/ActionBarSherlock" target="_blank" rel="noopener">https://github.com/JakeWharton/ActionBarSherlock</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.actionbarsherlock.sample.demos" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.actionbarsherlock.sample.demos</a><br>标签：兼容库, ActionBar  </p>
</li>
<li><p>ActionBar-PullToRefresh<br>下拉刷新，ActionBar 出现加载中提示<br>项目地址：<a href="https://github.com/chrisbanes/ActionBar-PullToRefresh" target="_blank" rel="noopener">https://github.com/chrisbanes/ActionBar-PullToRefresh</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=uk.co.senab.actionbarpulltorefresh.samples.stock" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=uk.co.senab.actionbarpulltorefresh.samples.stock</a><br>APP 示例：Gmail，Google Plus，知乎等  </p>
</li>
<li><p>FadingActionBar<br>ListView 向下滚动逐渐显现的 ActionBar<br>项目地址：<a href="https://github.com/ManuelPeinado/FadingActionBar" target="_blank" rel="noopener">https://github.com/ManuelPeinado/FadingActionBar</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.manuelpeinado.fadingactionbar.demo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.manuelpeinado.fadingactionbar.demo</a><br>APP 示例：google music，知乎  </p>
</li>
<li><p>NotBoringActionBar<br>google music 下拉收缩的 ActionBar<br>项目地址：<a href="https://github.com/flavienlaurent/NotBoringActionBar" target="_blank" rel="noopener">https://github.com/flavienlaurent/NotBoringActionBar</a><br>Demo 地址：<a href="http://flavienlaurent.com/blog/2013/11/20/making-your-action-bar-not-boring/" target="_blank" rel="noopener">http://flavienlaurent.com/blog/2013/11/20/making-your-action-bar-not-boring/</a><br>APP 示例：Google 音乐  </p>
</li>
<li><p>RefreshActionItem<br>带进度显示和刷新按钮的 ActionBar<br>项目地址：<a href="https://github.com/ManuelPeinado/RefreshActionItem" target="_blank" rel="noopener">https://github.com/ManuelPeinado/RefreshActionItem</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.manuelpeinado.refreshactionitem.demo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.manuelpeinado.refreshactionitem.demo</a><br>APP 示例：The New York Times，DevAppsDirect  </p>
</li>
<li><p>GlassActionBar<br>类似玻璃的有一定透明度的 ActionBar<br>项目地址：<a href="https://github.com/ManuelPeinado/GlassActionBar" target="_blank" rel="noopener">https://github.com/ManuelPeinado/GlassActionBar</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.manuelpeinado.glassactionbardemo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.manuelpeinado.glassactionbardemo</a><br>APP 示例：google music  </p>
</li>
</ol>
<h4 id="三、Menu"><a href="#三、Menu" class="headerlink" title="三、Menu"></a>三、Menu</h4><ol>
<li><p>MenuDrawer<br>滑出式菜单，通过拖动屏幕边缘滑出菜单，支持屏幕上下左右划出，支持当前 View 处于上下层，支持 Windows 边缘、ListView 边缘、ViewPager 变化划出菜单等。<br>项目地址：<a href="https://github.com/SimonVT/android-menudrawer" target="_blank" rel="noopener">https://github.com/SimonVT/android-menudrawer</a><br>Demo 地址：<a href="http://simonvt.github.io/android-menudrawer/" target="_blank" rel="noopener">http://simonvt.github.io/android-menudrawer/</a><br>APP 示例：Gmail、Google Music 等大部分 google app  </p>
</li>
<li><p>SlidingMenu<br>滑出式菜单，通过拖动屏幕边缘滑出菜单，支持屏幕左右划出，支持菜单 zoom、scale、slide up 三种动画样式出现。与 MenuDrawer 相比而言，SlidingMenu 支持菜单动画样式出现，MenuDrawer 支持菜单 view 处于内容的上下层<br>项目地址：<a href="https://github.com/jfeinstein10/SlidingMenu" target="_blank" rel="noopener">https://github.com/jfeinstein10/SlidingMenu</a><br>原理剖析文档：[SlidingMenu](<a href="http://a.codekk.com/detail/Android/huxian99/SlidingMenu" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/huxian99/SlidingMenu</a> 源码解析)<br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.slidingmenu.example" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.slidingmenu.example</a><br>APP 示例：Foursquare, LinkedIn, Zappos, Rdio, Evernote Food, Plume, VLC for Android, ESPN ScoreCenter, MLS MatchDay, 9GAG, Wunderlist 2, The Verge, MTG Familiar, Mantano Reader, Falcon Pro (BETA), MW3 Barracks  </p>
</li>
<li><p>ArcMenu<br>支持类似 Path 的左下角动画旋转菜单及横向划出菜单、圆心弹出菜单<br>项目地址：<a href="https://github.com/daCapricorn/ArcMenu" target="_blank" rel="noopener">https://github.com/daCapricorn/ArcMenu</a><br>效果图：<img src="https://dl.dropboxusercontent.com/u/11369687/preview0.png" alt="Renderings"><br><a href="https://dl.dropboxusercontent.com/u/11369687/preview1.png" target="_blank" rel="noopener">https://dl.dropboxusercontent.com/u/11369687/preview1.png</a><br><a href="https://dl.dropboxusercontent.com/u/11369687/raymenu.png" target="_blank" rel="noopener">https://dl.dropboxusercontent.com/u/11369687/raymenu.png</a><br>APP 示例：Path  </p>
</li>
<li><p>android-satellite-menu<br>类似 Path 的左下角动画旋转菜单<br>项目地址：<a href="https://github.com/siyamed/android-satellite-menu" target="_blank" rel="noopener">https://github.com/siyamed/android-satellite-menu</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/satellite-menu-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/satellite-menu-demo.apk?raw=true</a><br>APP 示例：Path  </p>
</li>
<li><p>radial-menu-widget<br>圆形菜单，支持二级菜单<br>项目地址：<a href="https://code.google.com/p/radial-menu-widget/" target="_blank" rel="noopener">https://code.google.com/p/radial-menu-widget/</a><br>效果图：<img src="http://farm8.staticflickr.com/7377/11621125154_d1773c2dcc_o.jpg" alt="Renderings">  </p>
</li>
<li><p>Android Wheel Menu<br>圆形旋转选取菜单<br>项目地址：<a href="https://github.com/anupcowkur/Android-Wheel-Menu" target="_blank" rel="noopener">https://github.com/anupcowkur/Android-Wheel-Menu</a><br>效果图：<img src="https://raw.github.com/anupcowkur/Android-Wheel-Menu/master/graphics/wheel.gif" alt="Renderings">  </p>
</li>
<li><p>FoldingNavigationDrawer<br>滑动并以折叠方式打开菜单<br>项目地址：<a href="https://github.com/tibi1712/FoldingNavigationDrawer-Android" target="_blank" rel="noopener">https://github.com/tibi1712/FoldingNavigationDrawer-Android</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.ptr.folding.sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.ptr.folding.sample</a><br>效果图：<img src="https://lh6.ggpht.com/VnKUZenAozQ0KFAm5blFTGqMaKFjvX-BK2JH-jrX1sIXVTqciACqRhqFH48hc4pm2Q=h310-rw" alt="Renderings">  </p>
</li>
<li><p>AndroidResideMenu<br>仿 Dribbble 的边栏菜单<br>项目地址：<a href="https://github.com/SpecialCyCi/AndroidResideMenu" target="_blank" rel="noopener">https://github.com/SpecialCyCi/AndroidResideMenu</a><br>效果图：<img src="https://github.com/SpecialCyCi/AndroidResideMenu/raw/master/2.gif" alt="Renderings">  </p>
</li>
<li><p>CircularFloatingActionMenu<br>一个可定制的圆形的浮动菜单控件，类似于 Path 的圆形菜单。这个控件的可定制性更强，可以很容易的定制菜单出现消失时的动画，起始角度和半径。<br>项目地址：<a href="https://github.com/oguzbilgener/CircularFloatingActionMenu" target="_blank" rel="noopener">https://github.com/oguzbilgener/CircularFloatingActionMenu</a><br>原理剖析文档：[CircularFloatingActionMenu](<a href="http://a.codekk.com/detail/Android/cpacm/CircularFloatingActionMenu" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/cpacm/CircularFloatingActionMenu</a> 源码解析)<br>Demo 地址：<a href="https://github.com/oguzbilgener/CircularFloatingActionMenu/tree/master/samples" target="_blank" rel="noopener">https://github.com/oguzbilgener/CircularFloatingActionMenu/tree/master/samples</a><br>效果图：<img src="https://raw.githubusercontent.com/oguzbilgener/CircularFloatingActionMenu/master/assets/circularfab.gif" alt="Renderings">  </p>
</li>
<li><p>NavigationDrawerSI<br>Navigation Drawer 的一个简单实现，滑动并以折叠方式打开菜单<br>项目地址：<a href="https://github.com/mmBs/NavigationDrawerSI" target="_blank" rel="noopener">https://github.com/mmBs/NavigationDrawerSI</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=mmbialas.pl.navigationdrawersi" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=mmbialas.pl.navigationdrawersi</a><br>效果图：<img src="https://raw.githubusercontent.com/mmBs/NavigationDrawerSI/master/images/screens.png" alt="Renderings"><br>APP 示例：<a href="https://play.google.com/store/apps/details?id=mmbialas.pl.navigationdrawersi" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=mmbialas.pl.navigationdrawersi</a>  </p>
</li>
<li><p>DragLayout<br>使用 support.v4 包下的 ViewDragHelper 实现 QQ5.0 侧滑<br>项目地址：<a href="https://github.com/BlueMor/DragLayout" target="_blank" rel="noopener">https://github.com/BlueMor/DragLayout</a><br>效果图：<img src="https://github.com/BlueMor/DragLayout/raw/master/screenshots/123.gif" alt="Renderings">  </p>
</li>
<li><p>LDrawer<br>Material Design 形式的展开折叠 Icon<br>项目地址：<a href="https://github.com/ikimuhendis/LDrawer" target="_blank" rel="noopener">https://github.com/ikimuhendis/LDrawer</a><br>效果图：<img src="https://raw.githubusercontent.com/IkiMuhendis/LDrawer/master/images/animated.gif" alt="Renderings">  </p>
</li>
<li><p>Floating Action Button<br>悬浮的圆形菜单栏，支持组建滚动时自动隐藏及其他设置<br>项目地址：<a href="https://github.com/shamanland/floating-action-button" target="_blank" rel="noopener">https://github.com/shamanland/floating-action-button</a><br>效果图：<img src="https://camo.githubusercontent.com/c679cb23cf62830b0d4037e17cf2d8d4090bc3c8/68747470733a2f2f64726976652e676f6f676c652e636f6d2f75633f69643d3042776830534e4c506d6a5142526b466f5a4530345646393051324d" alt="Renderings">  </p>
</li>
<li><p>Side-Menu.Android<br>分类侧滑菜单，<a href="http://yalantis.com/" target="_blank" rel="noopener">Yalantis</a> 出品。<br>项目地址：<a href="https://github.com/Yalantis/Side-Menu.Android" target="_blank" rel="noopener">https://github.com/Yalantis/Side-Menu.Android</a><br>原理剖析文档：[Side-Menu.Android](<a href="http://a.codekk.com/detail/Android/cpacm/Side" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/cpacm/Side</a> Menu.Android 源码解析)<br>效果图：<img src="https://camo.githubusercontent.com/cb6caa7a392d01d46bca9d9485c01fc173f55fac/68747470733a2f2f6431337961637572716a676172612e636c6f756466726f6e742e6e65742f75736572732f3132353035362f73637265656e73686f74732f313638393932322f6576656e74732d6d656e755f312d312d362e676966" alt="Renderings">  </p>
</li>
<li><p>Context-Menu.Android<br>可以方便快速集成漂亮带有动画效果的上下文菜单，<a href="http://yalantis.com/" target="_blank" rel="noopener">Yalantis</a>出品。<br>项目地址：<a href="https://github.com/Yalantis/Context-Menu.Android" target="_blank" rel="noopener">https://github.com/Yalantis/Context-Menu.Android</a><br>效果图：<img src="https://camo.githubusercontent.com/46c15734b552ce3afefa7efd1518909046b4677e/68747470733a2f2f6431337961637572716a676172612e636c6f756466726f6e742e6e65742f75736572732f3132353035362f73637265656e73686f74732f313738353237342f39396d696c65732d70726f66696c652d6c696768745f312d312d342e676966" alt="Renderings">  </p>
</li>
<li><p>Droppy<br>支持多种样式的下拉菜单<br>项目地址：<a href="https://github.com/shehabic/Droppy" target="_blank" rel="noopener">https://github.com/shehabic/Droppy</a>  </p>
</li>
<li><p>MaterialDrawer<br>Material Design 风格的导航抽屉，提供简便且强大的定制功能<br>项目地址：<a href="https://github.com/mikepenz/MaterialDrawer" target="_blank" rel="noopener">https://github.com/mikepenz/MaterialDrawer</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details？id=com.mikepenz.materialdrawer.app" target="_blank" rel="noopener">https://play.google.com/store/apps/details？id=com.mikepenz.materialdrawer.app</a><br>效果图：<img src="https://raw.githubusercontent.com/mikepenz/MaterialDrawer/master/DEV/screenshots/screenshot1_small.png" alt="Renderings">  </p>
</li>
<li><p>SlideBottomPanel<br>底部划出菜单，滑动时背景图透明度渐变，支持嵌套 LiewView 或 ScrollView<br>项目地址：<a href="https://github.com/kingideayou/SlideBottomPanel" target="_blank" rel="noopener">https://github.com/kingideayou/SlideBottomPanel</a><br>Demo 地址：<a href="https://github.com/kingideayou/SlideBottomPanel/raw/master/apk/SlideBottomPanelDemo.apk" target="_blank" rel="noopener">SlideBottomPanelDemo 下载</a><br>效果图：<img src="https://github.com/kingideayou/SlideBottomPanel/blob/master/imgs/demo_list_view.gif" alt="Renderings">  </p>
</li>
<li><p>FlowingDrawer<br>带手势流动效果侧滑菜单<br>项目地址：<a href="https://github.com/mxn21/FlowingDrawer" target="_blank" rel="noopener">https://github.com/mxn21/FlowingDrawer</a><br>效果图：<img src="https://github.com/mxn21/FlowingDrawer/raw/master/screen.gif" alt="Renderings">  </p>
</li>
<li><p>FloatingActionMenu-Animation<br>扩展FloatingActionMenu库，自定义菜单图标，动画滚动时<br>项目地址: <a href="https://github.com/toanvc/FloatingActionMenu-Animation" target="_blank" rel="noopener">https://github.com/toanvc/FloatingActionMenu-Animation</a><br>效果图: <img src="https://github.com/toanvc/FloatingActionMenu-Animation/raw/master/screenshots/scale.gif" alt="Renderings">    </p>
</li>
</ol>
<h4 id="四、ViewPager-、Gallery"><a href="#四、ViewPager-、Gallery" class="headerlink" title="四、ViewPager 、Gallery"></a>四、ViewPager 、Gallery</h4><ol>
<li><p>AdvancedPagerSlidingTabStrip<br>一个完美兼容ViewPager的导航栏组件；可以自定义TabView；能动态加载Tab上的Icon图片； 能显示Tab的消息数量和提示小圆点；支持自定义为微博形式的可滑动tab。<br><img src="https://raw.githubusercontent.com/HomHomLin/AdvancedPagerSlidingTabStrip/master/Pic/Screen_20160216163404.png" alt="p1"><br><img src="https://raw.githubusercontent.com/HomHomLin/AdvancedPagerSlidingTabStrip/master/Pic/Screen_20160411141706.png" alt="p2"><br>项目地址：<a href="https://github.com/HomHomLin/AdvancedPagerSlidingTabStrip。" target="_blank" rel="noopener">https://github.com/HomHomLin/AdvancedPagerSlidingTabStrip。</a>  </p>
</li>
<li><p>ConvenientBanner<br>通用的广告栏控件，让你轻松实现广告头效果。支持无限循环，可以设置自动翻页和时间(而且非常智能，手指触碰则暂停翻页，离开自动开始翻页。你也可以设置在界面onPause的时候不进行自动翻页，onResume之后继续自动翻页)，并且提供多种翻页特效。 对比其他广告栏控件，大多都需要对源码进行改动才能加载网络图片，或者帮你集成不是你所需要的图片缓存库。而这个库能让有代码洁癖的你欢喜，不需要对库源码进行修改你就可以使用任何你喜欢的网络图片库进行配合。<br>项目地址：<a href="https://github.com/saiwu-bigkoo/Android-ConvenientBanner" target="_blank" rel="noopener">https://github.com/saiwu-bigkoo/Android-ConvenientBanner</a><br>效果图：<img src="https://github.com/saiwu-bigkoo/Android-ConvenientBanner/blob/master/preview/convenientbannerdemo.gif" alt="Renderings">  </p>
</li>
<li><p>Android-ViewPagerIndicator<br>配合 ViewPager 使用的 Indicator，支持各种位置和样式<br>项目地址：<a href="https://github.com/JakeWharton/Android-ViewPagerIndicator" target="_blank" rel="noopener">https://github.com/JakeWharton/Android-ViewPagerIndicator</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.viewpagerindicator.sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.viewpagerindicator.sample</a><br>APP 示例：太多了。。  </p>
</li>
<li><p>JazzyViewPager<br>支持 Fragment 切换动画的 ViewPager，动画包括转盘、淡入淡出、翻页、层叠、旋转、方块、翻转、放大缩小等，效果类似桌面左右切换的各种效果，不过桌面并非用 ViewPager 实现而已<br>项目地址：<a href="https://github.com/jfeinstein10/JazzyViewPager" target="_blank" rel="noopener">https://github.com/jfeinstein10/JazzyViewPager</a><br>Demo 地址：<a href="https://github.com/jfeinstein10/JazzyViewPager/blob/master/JazzyViewPager.apk?raw=true" target="_blank" rel="noopener">https://github.com/jfeinstein10/JazzyViewPager/blob/master/JazzyViewPager.apk?raw=true</a>  </p>
</li>
<li><p>JellyViewPager<br>特殊切换动画的 ViewPager<br>项目地址：<a href="https://github.com/chiemy/JellyViewPager" target="_blank" rel="noopener">https://github.com/chiemy/JellyViewPager</a><br>效果图：<img src="https://github.com/chiemy/JellyViewPager/raw/master/capture.gif" alt="Renderings">  </p>
</li>
<li><p>Android-DirectionalViewPager<br>支持横向和纵向(垂直)的 ViewPager<br>项目地址：<a href="https://github.com/JakeWharton/Android-DirectionalViewPager" target="_blank" rel="noopener">https://github.com/JakeWharton/Android-DirectionalViewPager</a><br>Demo 地址：<a href="https://market.android.com/details?id=com.directionalviewpager.sample" target="_blank" rel="noopener">https://market.android.com/details?id=com.directionalviewpager.sample</a>  </p>
</li>
<li><p>FancyCoverFlow<br>支持 Item 切换动画效果的类似 Gallery View<br>项目地址：<a href="https://github.com/davidschreiber/FancyCoverFlow" target="_blank" rel="noopener">https://github.com/davidschreiber/FancyCoverFlow</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=at.technikum.mti.fancycoverflow.samples" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=at.technikum.mti.fancycoverflow.samples</a><br>效果图：<img src="https://github-camo.global.ssl.fastly.net/ef5ced52b7b54652b50499521ed797c0188c7a6b/687474703a2f2f64617669647363687265696265722e6769746875622e696f2f46616e6379436f766572466c6f772f73637265656e73686f74322e706e67" alt="Renderings">  </p>
</li>
<li><p>AndroidTouchGallery<br>支持双击或双指缩放的 Gallery(用 ViewPager 实现)，相比下面的 PhotoView，在被放大后依然能滑到下一个 item，并且支持直接从 url 和文件中获取图片，<br>项目地址：<a href="https://github.com/Dreddik/AndroidTouchGallery" target="_blank" rel="noopener">https://github.com/Dreddik/AndroidTouchGallery</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/touch-gallery-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/touch-gallery-demo.apk?raw=true</a><br>APP 示例：类似微信中查看聊天记录图片时可双击放大，并且放大情况下能正常左右滑动到前后图片  </p>
</li>
<li><p>Android Auto Scroll ViewPager<br>Android 自动滚动 轮播循环的 ViewPager<br>项目地址：<a href="https://github.com/Trinea/android-auto-scroll-view-pager" target="_blank" rel="noopener">https://github.com/Trinea/android-auto-scroll-view-pager</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=cn.trinea.android.demo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=cn.trinea.android.demo</a><br>文档介绍：<a href="http://www.trinea.cn/android/auto-scroll-view-pager/" target="_blank" rel="noopener">http://www.trinea.cn/android/auto-scroll-view-pager/</a>  </p>
</li>
<li><p>Android PagerSlidingTabStrip<br>配合 ViewPager 使用的 Indicator，支持 ViewPager Scroll 时 Indicator 联动<br>项目地址：<a href="https://github.com/astuetz/PagerSlidingTabStrip" target="_blank" rel="noopener">https://github.com/astuetz/PagerSlidingTabStrip</a><br>原理剖析文档：[Android PagerSlidingTabStrip](<a href="http://a.codekk.com/detail/Android/ayyb1988/PagerSlidingTabStrip" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/ayyb1988/PagerSlidingTabStrip</a> 源码解析)<br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.astuetz.viewpager.extensions.sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.astuetz.viewpager.extensions.sample</a>  </p>
</li>
<li><p>ViewPager3D<br>ViewPager3D 效果<br>项目地址：<a href="https://github.com/inovex/ViewPager3D" target="_blank" rel="noopener">https://github.com/inovex/ViewPager3D</a>  </p>
</li>
<li><p>AnimaTabsview<br>仿网易云音乐标签切换的动画,带透明小三角<br>项目地址：<a href="https://github.com/wuyexiong/transparent-over-animtabsview" target="_blank" rel="noopener">https://github.com/wuyexiong/transparent-over-animtabsview</a><br>在线演示：<a href="http://v.youku.com/v_show/id_XNzA4MjY5NjA0.html" target="_blank" rel="noopener">http://v.youku.com/v_show/id_XNzA4MjY5NjA0.html</a>  </p>
</li>
<li><p>LoopingViewPager<br>无限循环的 ViewPager<br>项目地址：<a href="https://github.com/imbryk/LoopingViewPager" target="_blank" rel="noopener">https://github.com/imbryk/LoopingViewPager</a>  </p>
</li>
<li><p>android_page_curl<br>翻书卷曲效果<br>项目地址：<a href="https://github.com/harism/android_page_curl" target="_blank" rel="noopener">https://github.com/harism/android_page_curl</a><br>在线演示：<a href="https://www.youtube.com/watch?v=iwu7P5PCpsw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=iwu7P5PCpsw</a><br>APP 示例：iReader  </p>
</li>
<li><p>ViewPagerIndicator<br>简化并实现 android 的 TabHost 效果，顶部滑动 tab，引导页，支持自定义 tab 样式,自定义滑动块样式和位置,自定义切换 tab 的过渡动画,子界面的预加载和界面缓存,设置界面是否可滑动<br>项目地址：<a href="https://github.com/LuckyJayce/ViewPagerIndicator" target="_blank" rel="noopener">https://github.com/LuckyJayce/ViewPagerIndicator</a>  </p>
</li>
<li><p>ScreenSlideIndicator<br>轻量级的圆形 Indicadtor，位置可以自由调整，不会对 ViewPager 产生任何影响。<br>项目地址：<a href="https://github.com/LyndonChin/Android-ScreenSlidePager" target="_blank" rel="noopener">ScreenSlidePager</a><br>效果图：<img src="https://github.com/LyndonChin/AndroidScreenSlidePager/raw/master/art/sample.gif" alt="Renderings">  </p>
</li>
<li><p>SmartTabLayout<br>自定义的 Tab title strip，基于 Google Samples 中的 android-SlidingTabBasic 项目，滑动时 Indicator 可平滑过渡。<br>项目地址：<a href="https://github.com/ogaclejapan/SmartTabLayout" target="_blank" rel="noopener">https://github.com/ogaclejapan/SmartTabLayout</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.ogaclejapan.smarttablayout.demo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.ogaclejapan.smarttablayout.demo</a><br>效果图：<img src="https://raw.githubusercontent.com/ogaclejapan/SmartTabLayout/master/art/demo1.gif" alt="Renderings">  </p>
</li>
<li><p>AndroidImageSlider<br>Android 图片滑动<br>项目地址：<a href="https://github.com/daimajia/AndroidImageSlider" target="_blank" rel="noopener">https://github.com/daimajia/AndroidImageSlider</a><br>效果图：<img src="https://camo.githubusercontent.com/f64413139bbaa918131384d3597c33e39333aa7f/687474703a2f2f7777332e73696e61696d672e636e2f6d773639302f36313064633033346a773165677a6f7236366f6a64673230393530666b6e70652e676966" alt="Renderings"><br>App<br>示例：<a href="https://github.com/daimajia/AndroidImageSlider/releases/download/v1.0.8/demo-1.0.8.apk" target="_blank" rel="noopener">https://github.com/daimajia/AndroidImageSlider/releases/download/v1.0.8/demo-1.0.8.apk</a>  </p>
</li>
<li><p>RecyclerViewPager<br>完全继承自 RecyclerView，可以自定义触发翻页的距离，可自定义翻页速度，支持垂直方向的 ViewPager，支持 Fragment。<br>项目地址：<a href="https://github.com/lsjwzh/RecyclerViewPager" target="_blank" rel="noopener">RecyclerViewPager</a><br>效果图：<img src="https://github.com/lsjwzh/RecyclerViewPager/blob/master/fragment.gif" alt="Renderings">  </p>
</li>
<li><p>CircleIndicator<br>轻量级ViewPager指示器,支持三种不同的模式<br>项目地址：<a href="https://github.com/THEONE10211024/CircleIndicator" target="_blank" rel="noopener">CircleIndicator</a><br>效果图：<img src="https://github.com/THEONE10211024/CircleIndicator/blob/master/demo/inside.gif" alt="Renderings"><br><img src="https://github.com/THEONE10211024/CircleIndicator/blob/master/demo/outside.gif" alt="Renderings"><br><img src="https://github.com/THEONE10211024/CircleIndicator/blob/master/demo/solo.gif" alt="Renderings">    </p>
</li>
<li><p>EasySlidingTabs<br>一款简单、易用的滑动标签页<br>项目地址： <a href="https://github.com/CaMnter/EasySlidingTabs" target="_blank" rel="noopener">https://github.com/CaMnter/EasySlidingTabs</a><br>效果图：<br><img src="https://raw.githubusercontent.com/CaMnter/EasySlidingTabs/master/readme/readme_easy_sliding_tabs_1.png" alt="Renderings">   </p>
</li>
<li><p>ParallaxViewPager<br>ViewPager页面切换视差效果<br>项目地址：<a href="https://github.com/ybq/ParallaxViewPager" target="_blank" rel="noopener">https://github.com/ybq/ParallaxViewPager</a><br>效果图：<br><img src="https://github.com/ybq/ParallaxViewPager/raw/master/art/screen.gif" alt="Renderings">   </p>
</li>
</ol>
<h4 id="五、GridView"><a href="#五、GridView" class="headerlink" title="五、GridView"></a>五、GridView</h4><ol>
<li><p>StaggeredGridView<br>允许非对齐行的 GridView，类似 Pinterest 的瀑布流，并且跟 ListView 一样自带 View 缓存，继承自 ViewGroup<br>项目地址：<a href="https://github.com/maurycyw/StaggeredGridView" target="_blank" rel="noopener">https://github.com/maurycyw/StaggeredGridView</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/staggered-gridview-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/staggered-gridview-demo.apk?raw=true</a><br>APP 示例：Pinterest 等  </p>
</li>
<li><p>AndroidStaggeredGrid<br>允许非对齐行的 GridView，类似 Pinterest 的瀑布流，继承自 AbsListView<br>项目地址：<a href="https://github.com/etsy/AndroidStaggeredGrid" target="_blank" rel="noopener">https://github.com/etsy/AndroidStaggeredGrid</a><br>APP 示例：Pinterest 等  </p>
</li>
<li><p>PinterestLikeAdapterView<br>允许非对齐行的 GridView，类似 Pinterest 的瀑布流，允许下拉刷新<br>项目地址：<a href="https://github.com/GDG-Korea/PinterestLikeAdapterView" target="_blank" rel="noopener">https://github.com/GDG-Korea/PinterestLikeAdapterView</a><br>APP 示例：Pinterest 等  </p>
</li>
<li><p>DraggableGridView<br>Item 可拖动交换位置的 GridView，实际是自己继承 ViewGroup 实现，类似桌面的单屏效果，可屏幕自动上下滚动进行 Item 移动交换，多屏效果见下面 PagedDragDropGrid<br>项目地址：<a href="https://github.com/thquinn/DraggableGridView" target="_blank" rel="noopener">https://github.com/thquinn/DraggableGridView</a><br>Demo 地址：<a href="https://github.com/thquinn/DraggableGridView/blob/master/bin/DraggableGridViewSample.apk?raw=true" target="_blank" rel="noopener">https://github.com/thquinn/DraggableGridView/blob/master/bin/DraggableGridViewSample.apk?raw=true</a><br>也可自定义item的宽高和每行的个数，同时修改了交换逻辑，当移动到另一个item时就进行交换，并删除滚动逻辑。<br>项目地址：<a href="https://github.com/andyken/DraggableGridView" target="_blank" rel="noopener">DraggableGridView</a><br>效果图：<br><img src="https://github.com/andyken/DraggableGridView/blob/master/sample/sample.gif" alt="Renderings"></p>
</li>
<li><p>DividedDraggableView<br>一个带有分割区域的可拖动 view ,可屏幕自动上下滚动进行 Item 移动交换。<br>项目地址：<a href="https://github.com/andyken/DividedDraggableView" target="_blank" rel="noopener">https://github.com/andyken/DividedDraggableView</a><br>效果图：<br><img src="https://github.com/andyken/DividedDraggableView/blob/master/app/sample.gif" alt="Renderings"></p>
</li>
<li><p>StickyGridHeaders<br>GroupName 滑动到顶端时会固定不动直到另外一个 GroupName 到达顶端的 GridView<br>项目地址：<a href="https://github.com/TonicArtos/StickyGridHeaders" target="_blank" rel="noopener">https://github.com/TonicArtos/StickyGridHeaders</a><br>效果图：<img src="https://github-camo.global.ssl.fastly.net/90b57e9383704c400706545225d439e057c6fcc0/687474703a2f2f342e62702e626c6f6773706f742e636f6d2f2d535f4262685758367754592f55517057306377554745492f41414141414141414776552f7a7a4a586a2d50635662592f73313630302f73637265656e2d6c616e6473636170652d736d616c6c65722e706e67" alt="Renderings">  </p>
</li>
<li><p>PagedDragDropGrid<br>Item 可拖动交换位置、拖动删除的自定义控件，实际是自己继承 ViewGroup 实现，类似桌面的多屏效果，可拖动到屏幕边缘，屏幕自动左右滚动进行 Item 移动交换，可拖动进行删除，单屏效果见上面 DraggableGridView<br>项目地址：<a href="https://github.com/mrKlar/PagedDragDropGrid" target="_blank" rel="noopener">https://github.com/mrKlar/PagedDragDropGrid</a><br>在线演示：<a href="http://youtu.be/FYTSRfthSuQ" target="_blank" rel="noopener">http://youtu.be/FYTSRfthSuQ</a>  </p>
</li>
<li><p>Android-DraggableGridViewPager<br>Item 可拖动交换位置的 GridView，实际是自己继承 ViewGroup 实现，类似桌面的多屏效果，可屏幕自动左右滚动进行 Item 移动交换，单屏效果见上面 DraggableGridView<br>项目地址：<a href="https://github.com/zzhouj/Android-DraggableGridViewPager" target="_blank" rel="noopener">https://github.com/zzhouj/Android-DraggableGridViewPager</a><br>Demo 地址：<a href="https://github.com/Trinea/trinea-download/blob/master/draggable-grid-viewpager-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/trinea-download/blob/master/draggable-grid-viewpager-demo.apk?raw=true</a>  </p>
</li>
<li><p>TwoWayGridView<br>可横向滚动的 GridView<br>项目地址：<a href="https://github.com/jess-anders/two-way-gridview" target="_blank" rel="noopener">https://github.com/jess-anders/two-way-gridview</a>  </p>
</li>
<li><p>PagingGridView<br>分页加载的 GridView。当滑动到 GridView 底部最后一个行时，显示一个进度行，然后加载下一页数据，并显示。<br>项目地址：<a href="https://github.com/nicolasjafelle/PagingGridView" target="_blank" rel="noopener">https://github.com/nicolasjafelle/PagingGridView</a>  </p>
</li>
<li><p>AsymmetricGridView<br>一个支持跨行和跨列可变 Item 大小的 GridView<br>项目地址：<a href="https://github.com/felipecsl/AsymmetricGridView" target="_blank" rel="noopener">https://github.com/felipecsl/AsymmetricGridView</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.felipecsl.asymmetricgridview.app" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.felipecsl.asymmetricgridview.app</a><br>效果图：<img src="https://raw.githubusercontent.com/felipecsl/AsymmetricGridView/master/screenshots/ss_5_cols.png" alt="Renderings">  </p>
</li>
<li><p>GridView with Header and Footer<br>和<code>ListView</code>一样带头部和底部的<code>GridView</code>，用法和<code>ListView</code>一样<br>项目地址：<a href="https://github.com/liaohuqiu/android-GridViewWithHeaderAndFooter" target="_blank" rel="noopener">https://github.com/liaohuqiu/android-GridViewWithHeaderAndFooter</a><br>效果图：<img src="https://raw.githubusercontent.com/liaohuqiu/android-GridViewWithHeaderAndFooter/master/screen-shot.png" alt="Renderings">  </p>
</li>
</ol>
<h4 id="六、ImageView"><a href="#六、ImageView" class="headerlink" title="六、ImageView"></a>六、ImageView</h4><ol>
<li><p>PhotoView<br>支持双击或双指缩放的 ImageView，在 ViewPager 等 Scrolling view 中正常使用，相比上面的 AndroidTouchGallery，不仅支持 ViewPager，同时支持单个 ImageView<br>项目地址：<a href="https://github.com/chrisbanes/PhotoView" target="_blank" rel="noopener">https://github.com/chrisbanes/PhotoView</a><br>原理剖析文档：[PhotoView](<a href="http://a.codekk.com/detail/Android/dkmeteor/PhotoView" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/dkmeteor/PhotoView</a> 源码解析)<br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=uk.co.senab.photoview.sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=uk.co.senab.photoview.sample</a><br>APP 示例：photup  </p>
</li>
<li><p>Fresco-ImageView<br>Fresco-ImageView是一种Android平台的图像控件，底层是对Fresco的封装，可以异步加载网络图片、项目资源和本地图片，并且支持双指缩放、图片的基本处理以及Fresco的所有特性。<br>项目地址：<a href="https://github.com/HomHomLin/FrescoImageView" target="_blank" rel="noopener">https://github.com/HomHomLin/FrescoImageView</a>  </p>
</li>
<li><p>android-gif-drawable<br>支持 gif 显示的 view，用 jni 实现的，编译生成 so 库后直接 xml 定义 view 即可，而且本身不依赖于其他开源项目所以相对下面的 ImageViewEx 简单的多<br>项目地址：<a href="https://github.com/koral--/android-gif-drawable" target="_blank" rel="noopener">https://github.com/koral--/android-gif-drawable</a>  </p>
</li>
<li><p>ImageViewEx<br>支持 Gif 显示的 ImageView，依赖很多，编译过程很繁琐<br>项目地址：<a href="https://github.com/frapontillo/ImageViewEx" target="_blank" rel="noopener">https://github.com/frapontillo/ImageViewEx</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/imageviewex-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/imageviewex-demo.apk?raw=true</a>  </p>
</li>
<li><p>RoundedImageView<br>带圆角的 ImageView<br>项目地址：<a href="https://github.com/vinc3m1/RoundedImageView" target="_blank" rel="noopener">https://github.com/vinc3m1/RoundedImageView</a><br>效果图：<img src="https://raw.github.com/makeramen/RoundedImageView/master/screenshot.png" alt="Renderings">  </p>
</li>
<li><p>SelectableRoundedImageView<br>ImageView 允许四个角的每一个有不同的半径值。也允许椭圆形、圆形的形状或者边<br>项目地址：<a href="https://github.com/pungrue26/SelectableRoundedImageView" target="_blank" rel="noopener">https://github.com/pungrue26/SelectableRoundedImageView</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.joooonho" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.joooonho</a><br>效果图：<img src="https://camo.githubusercontent.com/25d2e5fb8783b5dd09c00b03091172a79c69350e/687474703a2f2f692e696d6775722e636f6d2f55355653376d322e706e673f31" alt="Renderings">  </p>
</li>
<li><p>ColorArt<br>根据图片的均色设置背景色显示文字和图片，类似 itune11 中效果<br>项目地址：<a href="https://github.com/MichaelEvans/ColorArt" target="_blank" rel="noopener">https://github.com/MichaelEvans/ColorArt</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/color-art-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/color-art-demo.apk?raw=true</a>  </p>
</li>
<li><p>CircleImageView<br>圆形的 ImageView<br>项目地址：<a href="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="noopener">https://github.com/hdodenhof/CircleImageView</a><br>效果图：<img src="https://raw.github.com/hdodenhof/CircleImageView/master/screenshot.png" alt="Renderings">  </p>
</li>
<li><p>ImageViewZoom<br>支持放大和平移的 ImageView<br>项目地址：<a href="https://github.com/sephiroth74/ImageViewZoom" target="_blank" rel="noopener">https://github.com/sephiroth74/ImageViewZoom</a><br>APP 示例：<a href="https://play.google.com/store/apps/details?id=com.aviary.android.feather" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.aviary.android.feather</a>  </p>
</li>
<li><p>KenBurnsView<br>实现 Ken Burns effect 效果，达到身临其境效果的 ImageView<br>项目地址：<a href="https://github.com/flavioarfaria/KenBurnsView" target="_blank" rel="noopener">https://github.com/flavioarfaria/KenBurnsView</a>  </p>
</li>
<li><p>CustomShapeImageView<br>各种形状的 ImageView, 相比上面的圆形 ImageView，多了更多形状<br>项目地址：<a href="https://github.com/MostafaGazar/CustomShapeImageView" target="_blank" rel="noopener">https://github.com/MostafaGazar/CustomShapeImageView</a><br>效果图：<img src="https://raw.github.com/MostafaGazar/CustomShapeImageView/master/Screenshot_2013-11-05-23-08-12.png" alt="Renderings">  </p>
</li>
<li><p>Shape Image View<br>可以自定义各种形状的 ImageView, 并且支持边框<br>项目地址：<a href="https://github.com/siyamed/android-shape-imageview" target="_blank" rel="noopener">https://github.com/siyamed/android-shape-imageview</a><br>效果图：<img src="https://github.com/siyamed/android-shape-imageview/raw/master/images/shader-buble.png" alt="Renderings"><br><a href="https://github.com/siyamed/android-shape-imageview/raw/master/images/all-samples.png" target="_blank" rel="noopener">https://github.com/siyamed/android-shape-imageview/raw/master/images/all-samples.png</a>  </p>
</li>
<li><p>TextDrawable<br>一个用于生成带有文本或者字母的图片的轻量级库。扩展自 Drawable，因此可用于现有/自定义/网络等 ImageView 类，并且包含一个流接口用于创建 drawables 以及一个定制的 ColorGenerator<br>项目地址：<a href="https://github.com/amulyakhare/TextDrawable" target="_blank" rel="noopener">https://github.com/amulyakhare/TextDrawable</a><br>效果图：<img src="https://raw.githubusercontent.com/amulyakhare/TextDrawable/master/screens/screen7.png" alt="Renderings">  </p>
</li>
<li><p>android-smart-image-view<br>可从 URL 或 contact address book 加载图片的 ImageView，支持缓存<br>项目地址：<a href="https://github.com/loopj/android-smart-image-view" target="_blank" rel="noopener">https://github.com/loopj/android-smart-image-view</a>  </p>
</li>
<li><p>PhotoView<br>支持双指/双击缩放的ImageView,支持从一个PhotoView缩放到另外一个PhotoView(点击图片放大预览),相对于其他PhototView有更加平滑的缩放,平移的动画,并且支持所有的ScaleType,可以作为普通的ImageView使用<br>项目地址：<a href="https://github.com/bm-x/PhotoView" target="_blank" rel="noopener">https://github.com/bm-x/PhotoView</a><br>效果图：<img src="https://github.com/bm-x/PhotoView/raw/master/demo1.gif" alt="Renderings">  </p>
</li>
<li><p>TextWithImageDrawable<br>一个可以同时包含图片和文字的drawable,使用方式类似TextView和它的drawableLeft之类的方法,功能比较全面,可以代替TextView或是解决一些非得需要在ImageView中同时显示文字和图片的问题<br>项目地址：<a href="https://github.com/wuseal/TextWithImageDrawable" target="_blank" rel="noopener">https://github.com/wuseal/TextWithImageDrawable</a>  </p>
</li>
<li><p>AnchorImageView<br>一个可以锚点定位的ImageView(根据像素点)<br>Demo中通过AnchorImageView简单的实现了一个课本点读的功能<br>项目地址：<a href="https://github.com/jcodeing/AnchorImageView" target="_blank" rel="noopener">https://github.com/jcodeing/AnchorImageView</a><br>Demo 地址：<a href="https://raw.githubusercontent.com/jcodeing/AnchorImageView/master/AnchorImageView-debug.apk" target="_blank" rel="noopener">Download here</a><br><img src="https://raw.githubusercontent.com/jcodeing/AnchorImageView/master/lookme.gif" alt="Renderings"></p>
</li>
</ol>
<h4 id="七、ProgressBar"><a href="#七、ProgressBar" class="headerlink" title="七、ProgressBar"></a>七、ProgressBar</h4><ol>
<li><p>SmoothProgressBar<br>水平进度条<br>项目地址：<a href="https://github.com/castorflex/SmoothProgressBar" target="_blank" rel="noopener">https://github.com/castorflex/SmoothProgressBar</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=fr.castorflex.android.smoothprogressbar.sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=fr.castorflex.android.smoothprogressbar.sample</a>  </p>
</li>
<li><p>MaterialProgessBar<br>Material Design 的进度条，支持 Android 4.0<br>项目地址：<a href="https://github.com/DreaminginCodeZH/MaterialProgressBar" target="_blank" rel="noopener">https://github.com/DreaminginCodeZH/MaterialProgressBar</a><br>Demo 地址：<a href="https://github.com/DreaminginCodeZH/MaterialProgressBar/blob/master/dist/sample.apk" target="_blank" rel="noopener">https://github.com/DreaminginCodeZH/MaterialProgressBar/blob/master/dist/sample.apk</a>  </p>
</li>
<li><p>ProgressWheel<br>支持进度显示的圆形 ProgressBar<br>项目地址：<a href="https://github.com/Todd-Davies/ProgressWheel" target="_blank" rel="noopener">https://github.com/Todd-Davies/ProgressWheel</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/progress-wheel-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/progress-wheel-demo.apk?raw=true</a>  </p>
</li>
<li><p>android-square-progressbar<br>在图片周围显示进度<br>项目地址：<a href="https://github.com/mrwonderman/android-square-progressbar" target="_blank" rel="noopener">https://github.com/mrwonderman/android-square-progressbar</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=net.yscs.android.square_progressbar_example" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=net.yscs.android.square_progressbar_example</a><br>效果图：<img src="https://googledrive.com/host/0BwESwPCuXtw7eExwSFVLQkR2TTg/newscreen1.png" alt="Renderings"><br>APP 示例：square  </p>
</li>
<li><p>HoloCircularProgressBar<br>Android4.1 时钟 App 样式<br>项目地址：<a href="https://github.com/passsy/android-HoloCircularProgressBar" target="_blank" rel="noopener">https://github.com/passsy/android-HoloCircularProgressBar</a><br>效果图：<img src="https://raw.github.com/passsy/android-HoloCircularProgressBar/master/raw/screenshot1.png" alt="Renderings"><br>APP 示例：Android4.1 时钟 App  </p>
</li>
<li><p>ProgressButton<br>通过图钉的不同状态显示进度<br>项目地址：<a href="https://github.com/f2prateek/progressbutton" target="_blank" rel="noopener">https://github.com/f2prateek/progressbutton</a><br>文档介绍：<a href="http://f2prateek.com/progressbutton/" target="_blank" rel="noopener">http://f2prateek.com/progressbutton/</a><br>效果图：<img src="http://f2prateek.com/progressbutton/static/states.png" alt="Renderings">  </p>
</li>
<li><p>GoogleProgressBar<br>类似 google 多个圆形卡片翻转的 progressBar<br>项目地址：<a href="https://github.com/jpardogo/GoogleProgressBar" target="_blank" rel="noopener">https://github.com/jpardogo/GoogleProgressBar</a><br>效果图：<img src="https://raw.githubusercontent.com/jpardogo/GoogleProgressBar/master/art/GoogleProgressBar.gif" alt="Renderings">  </p>
</li>
<li><p>TH-ProgressButton<br>带圆形进度显示的按钮<br>项目地址：<a href="https://github.com/torryharris/TH-ProgressButton" target="_blank" rel="noopener">https://github.com/torryharris/TH-ProgressButton</a><br>效果图：<img src="https://raw.github.com/Vyshakh-K/TH-ProgressButton/master/screenshots/progressshot1.png" alt="Renderings"><br><a href="https://raw.github.com/Vyshakh-K/TH-ProgressButton/master/screenshots/progressshot2.png" target="_blank" rel="noopener">https://raw.github.com/Vyshakh-K/TH-ProgressButton/master/screenshots/progressshot2.png</a>  </p>
</li>
<li><p>NumberProgressBar<br>带数字进度的进度条<br>项目地址：<a href="https://github.com/daimajia/NumberProgressBar" target="_blank" rel="noopener">https://github.com/daimajia/NumberProgressBar</a><br>效果图：<img src="https://camo.githubusercontent.com/0c92568af7ec4e04e2e1503acdd2ca99854ab0b5/687474703a2f2f7777332e73696e61696d672e636e2f6d773639302f36313064633033346a77316566797264386e376937673230637a30326d7135662e676966" alt="Renderings">  </p>
</li>
<li><p>CircularProgressDrawable<br>带圆形进度显示的进度条<br>项目地址：<a href="https://github.com/Sefford/CircularProgressDrawable" target="_blank" rel="noopener">https://github.com/Sefford/CircularProgressDrawable</a><br>效果图：<img src="https://raw.githubusercontent.com/Sefford/CircularProgressDrawable/master/overshoot.gif" alt="Renderings">  </p>
</li>
<li><p>Android-RoundCornerProgressBar<br>Android 圆角 ProgressBar，可自定义圆角颜色和半径，包括带 Icon 和不带 Icon 两种类型。<br>项目地址：<a href="https://github.com/akexorcist/Android-RoundCornerProgressBar" target="_blank" rel="noopener">https://github.com/akexorcist/Android-RoundCornerProgressBar</a><br>效果图：<img src="https://raw.githubusercontent.com/akexorcist/Android-RoundCornerProgressBar/master/image/screenshot_02.png" alt="Renderings">  </p>
</li>
<li><p>circular-progress-button<br>带进度显示的 Button<br>项目地址：<a href="https://github.com/dmytrodanylyk/circular-progress-button" target="_blank" rel="noopener">https://github.com/dmytrodanylyk/circular-progress-button</a><br>效果图：<img src="https://raw.githubusercontent.com/dmytrodanylyk/circular-progress-button/master/screenshots/intro.gif" alt="Renderings">  </p>
</li>
<li><p>WaveView<br>一个波纹效果的 View，可用来做 ProgressBar<br>项目地址：<a href="https://github.com/john990/WaveView" target="_blank" rel="noopener">https://github.com/john990/WaveView</a><br>Demo 地址：<a href="https://raw.github.com/john990/WaveView/master/screenshot%26apk/demo.unaligned.apk" target="_blank" rel="noopener">https://raw.github.com/john990/WaveView/master/screenshot%26apk/demo.unaligned.apk</a><br>效果图：<img src="https://camo.githubusercontent.com/60722e9d4f2d2daa78a8650cb27a32adea82bdd4/68747470733a2f2f7261772e6769746875622e636f6d2f6a6f686e3939302f57617665566965772f6d61737465722f73637265656e73686f7425323661706b2f73637265656e73686f742e676966" alt="Renderings">  </p>
</li>
<li><p>MaterialLoadingProgressBar<br>抽取自 SwipeRefreshLayout 的 Material Design 进度指示器<br>项目地址：<a href="https://github.com/lsjwzh/MaterialLoadingProgressBar" target="_blank" rel="noopener">https://github.com/lsjwzh/MaterialLoadingProgressBar</a><br>效果图：<img src="https://github.com/lsjwzh/MaterialLoadingProgressBar/raw/master/screen.gif" alt="Renderings">  </p>
</li>
<li><p>MetaballLoading<br>A 2d metaball loading<br>项目地址：<a href="https://github.com/dodola/MetaballLoading" target="_blank" rel="noopener">https://github.com/dodola/MetaballLoading</a><br>效果图：<img src="https://github.com/dodola/MetaballLoading/blob/master/metaball.gif" alt="Renderings"><br>效果图：<img src="https://github.com/dodola/MetaballLoading/blob/master/metaball2.gif" alt="Renderings"> </p>
</li>
<li><p>SectorProgressView<br>一个圆形或环形的进度显示控件，用圆中扇形的角度大小来表示进度信息<br/><br>项目地址：<a href="https://github.com/timqi/SectorProgressView" target="_blank" rel="noopener">https://github.com/timqi/SectorProgressView</a><br/><br>Demo：<a href="https://github.com/timqi/SectorProgressView/raw/master/art/example.apk" target="_blank" rel="noopener">apk download</a> <br/><br>效果图：<br/><img src="https://github.com/timqi/SectorProgressView/raw/master/art/colorfulringprogressview.demo.gif" alt="ColorfulRingProgressView"> <img src="https://github.com/timqi/SectorProgressView/raw/master/art/sectorprogressview.demo.gif" alt="SectorProgressView"></p>
</li>
<li><p>CircularFillableLoaders<br>一个可以用于闪屏或者其他地方加载的控件<br/><br>项目地址：<a href="https://github.com/lopspower/CircularFillableLoaders" target="_blank" rel="noopener">https://github.com/lopspower/CircularFillableLoaders</a><br/><br>Demo地址：(<a href="https://play.google.com/store/apps/details?id=com.mikhaellopez.circularfillableloaderssample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.mikhaellopez.circularfillableloaderssample</a>) <br/><br>效果图：<br/><img src="https://camo.githubusercontent.com/b8e510f51d0781c1ac41a01713d81beb93ff30a9/687474703a2f2f6936362e74696e797069632e636f6d2f357a6771776e2e706e67" alt="CircularFillableLoaders"> <img src="https://lh3.googleusercontent.com/QUzoUjzTGirHKnGSmvziRfh230FRph12TPfEqUdZs9HXAgDnB79pSP6aCDLVpU9QvRZA=h310-rw" alt="CircularFillableLoaders"></p>
</li>
<li><p>PinWheel<br>一个旋转的大风车Dialog<br>项目地址：<a href="https://github.com/codingWang/PinWheel" target="_blank" rel="noopener">https://github.com/codingWang/PinWheel</a><br/><br>效果图：<img src="https://github.com/codingWang/PinWheel/blob/master/gif/pinwheel.gif" alt="Renderings"> </p>
</li>
<li><p>ColorArcProgressBar<br>一个可定制的圆形进度条，通过xml参数配置可实现QQ健康中步数的弧形进度显示、仪盘表显示速度、最常见的下载进度条等功能。<br/><br>项目地址：<a href="https://github.com/Shinelw/ColorArcProgressBar" target="_blank" rel="noopener">https://github.com/Shinelw/ColorArcProgressBar</a><br/><br>效果图：<br/><img src="https://raw.githubusercontent.com/Shinelw/ColorArcProgressBar/master/Demo.gif" alt="ColorArcProgressBar"></p>
</li>
<li><p>LoadingDrawable<br>一些酷炫的android加载动画，可以与任何组件配合使用作为加载的组件或者ProgressBar。<br><br>项目地址：<a href="https://github.com/dinuscxj/LoadingDrawable" target="_blank" rel="noopener">https://github.com/dinuscxj/LoadingDrawable</a><br>效果图：<br/><br><img src="https://raw.githubusercontent.com/dinuscxj/LoadingDrawable/master/Preview/AnimalDrawable.gif?width=300" alt="LoadingDrawable"><br><img src="https://raw.githubusercontent.com/dinuscxj/LoadingDrawable/master/Preview/SceneryDrawable.gif?width=300" alt="LoadingDrawable"><br><img src="https://raw.githubusercontent.com/dinuscxj/LoadingDrawable/master/Preview/CircleJumpDrawable.gif?width=300" alt="LoadingDrawable"><br><img src="https://raw.githubusercontent.com/dinuscxj/LoadingDrawable/master/Preview/CircleRotateDrawable.gif?width=300" alt="LoadingDrawable"></p>
</li>
<li><p>Android-SpinKit<br>Android加载动画库<br>项目地址：<a href="https://github.com/ybq/Android-SpinKit" target="_blank" rel="noopener">https://github.com/ybq/Android-SpinKit</a><br>效果图：<br><img src="https://raw.githubusercontent.com/ybq/AndroidSpinKit/master/art/screen.gif" alt="Renderings">  </p>
</li>
</ol>
<h4 id="八、TextView"><a href="#八、TextView" class="headerlink" title="八、TextView"></a>八、TextView</h4><p>包括 TextView 及所有继承自 TextView 控件，如 EditText、Button、RadioButton  </p>
<ol>
<li><p>android-flowtextview<br>文字自动环绕其他 View 的 Layout<br>项目地址：<a href="https://github.com/deano2390/FlowTextView" target="_blank" rel="noopener">https://github.com/deano2390/FlowTextView</a><br>效果图：<img src="http://i949.photobucket.com/albums/ad332/vostroman1500/1.png" alt="Renderings">  </p>
</li>
<li><p>Android Form EditText<br>验证输入合法性的编辑框，支持输入、英文、ip、url 等多种正则验证<br>项目地址：<a href="https://github.com/vekexasia/android-edittext-validator" target="_blank" rel="noopener">https://github.com/vekexasia/android-edittext-validator</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.andreabaccega.edittextformexample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.andreabaccega.edittextformexample</a>  </p>
</li>
<li><p>Emojicon<br>支持 emojis 的 TextView 和 EditText<br>项目地址：<a href="https://github.com/rockerhieu/emojicon" target="_blank" rel="noopener">https://github.com/rockerhieu/emojicon</a><br>文档介绍：<a href="http://rockerhieu.com/emojicon/" target="_blank" rel="noopener">http://rockerhieu.com/emojicon/</a>  </p>
</li>
<li><p>android-circlebutton<br>Android 圆形按钮，实际实现是继承自 ImageView<br>项目地址：<a href="https://github.com/markushi/android-circlebutton" target="_blank" rel="noopener">https://github.com/markushi/android-circlebutton</a><br>Demo 地址：<a href="https://github.com/markushi/android-circlebutton/blob/master/example/example.apk" target="_blank" rel="noopener">https://github.com/markushi/android-circlebutton/blob/master/example/example.apk</a>  </p>
</li>
<li><p>Segmented Radio Buttons for Android<br>iOS’s segmented controls 的实现<br>项目地址：<a href="https://github.com/vinc3m1/android-segmentedradiobutton" target="_blank" rel="noopener">https://github.com/vinc3m1/android-segmentedradiobutton</a><br>Demo 地址：<a href="https://github.com/thquinn/DraggableGridView/blob/master/bin/DraggableGridViewSample.apk?raw=true" target="_blank" rel="noopener">https://github.com/thquinn/DraggableGridView/blob/master/bin/DraggableGridViewSample.apk?raw=true</a><br>效果图：<img src="https://raw.github.com/vinc3m1/android-segmentedradiobutton/master/screens/segmentedradio.png" alt="Renderings">  </p>
</li>
<li><p>Chips EditText Library<br>支持国家名字联想从而选择显示该国国旗的 EditText，实际就是通过 SpannableStringBuilder 实现<br>项目地址：<a href="https://github.com/kpbird/chips-edittext-library" target="_blank" rel="noopener">https://github.com/kpbird/chips-edittext-library</a><br>Demo 地址：<a href="https://github.com/kpbird/chips-edittext-library/tree/master/ChipsEditTextDemo/bin" target="_blank" rel="noopener">https://github.com/kpbird/chips-edittext-library/tree/master/ChipsEditTextDemo/bin</a>  </p>
</li>
<li><p>AutoFitTextView<br>可固定边界内容字体大小自适应的 TextView<br>项目地址：<a href="https://github.com/grantland/android-autofittextview" target="_blank" rel="noopener">https://github.com/grantland/android-autofittextview</a>  </p>
</li>
<li><p>Shimmer for Android<br>文字发淡光的 TextView<br>项目地址：<a href="https://github.com/RomainPiel/Shimmer-android" target="_blank" rel="noopener">https://github.com/RomainPiel/Shimmer-android</a>  </p>
</li>
<li><p>Titanic<br>可以显示水位上升下降(不知道该怎么描述 囧)的 TextView<br>项目地址：<a href="https://github.com/RomainPiel/Titanic" target="_blank" rel="noopener">https://github.com/RomainPiel/Titanic</a><br>效果图：<img src="https://github.com/RomainPiel/Titanic/raw/master/titanic.gif" alt="Renderings">  </p>
</li>
<li><p>android-iconify<br>提供带 Icon 的 TextView,Menu,Button 等<br>项目地址：<a href="https://github.com/JoanZapata/android-iconify" target="_blank" rel="noopener">https://github.com/JoanZapata/android-iconify</a>  </p>
</li>
<li><p>Calligraphy<br>让我们在 android 开发中使用自定义字体变得更加简单<br>项目地址：<a href="https://github.com/chrisjenx/Calligraphy" target="_blank" rel="noopener">https://github.com/chrisjenx/Calligraphy</a><br>效果图：<img src="https://github.com/chrisjenx/Calligraphy/raw/master/screenshot.png" alt="Renderings">  </p>
</li>
<li><p>CreditsRoll<br>类似星球大战字幕效果的 TextView<br>项目地址：<a href="https://github.com/frakbot/CreditsRoll" target="_blank" rel="noopener">https://github.com/frakbot/CreditsRoll</a>  </p>
</li>
<li><p>android-process-buton<br>带加载或提交进度的 Button<br>项目地址：<a href="https://github.com/dmytrodanylyk/android-process-buton" target="_blank" rel="noopener">https://github.com/dmytrodanylyk/android-process-buton</a>  </p>
</li>
<li><p>FButton<br>扁平化的 Button<br>项目地址：<a href="https://github.com/hoang8f/android-flat-button" target="_blank" rel="noopener">https://github.com/hoang8f/android-flat-button</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=info.hoang8f.fbutton.demo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=info.hoang8f.fbutton.demo</a>  </p>
</li>
<li><p>FloatingActionButton<br>一个类似 Android 版 Google+浮动功能按钮的控件，可以响应 ListView 的滚动事件。当列表向上滚动的时候会自动显示，向下滚动的时候自动隐藏。<br>项目地址：<a href="https://github.com/makovkastar/FloatingActionButton" target="_blank" rel="noopener">https://github.com/makovkastar/FloatingActionButton</a><br>Demo 地址：<a href="https://github.com/makovkastar/FloatingActionButton/tree/master/" target="_blank" rel="noopener">https://github.com/makovkastar/FloatingActionButton/tree/master/</a><br>效果图：<img src="https://raw.githubusercontent.com/makovkastar/FloatingActionButton/master/art/demo.gif" alt="Renderings">  </p>
</li>
<li><p>Android Saripaar<br>Android 表单验证<br>项目地址：<a href="https://github.com/ragunathjawahar/android-saripaar/" target="_blank" rel="noopener">https://github.com/ragunathjawahar/android-saripaar/</a>  </p>
</li>
<li><p>JumpingBeans<br>文字像 Mexican beans 一样跳动<br>项目地址：<a href="https://github.com/frakbot/JumpingBeans" target="_blank" rel="noopener">https://github.com/frakbot/JumpingBeans</a><br>Demo 地址：<a href="http://play.google.com/store/apps/details?id=net.frakbot.jumpingbeans.demo" target="_blank" rel="noopener">http://play.google.com/store/apps/details?id=net.frakbot.jumpingbeans.demo</a><br>效果图：<img src="https://github.com/frakbot/JumpingBeans/blob/master/art/jumpingdots.gif" alt="Renderings">  </p>
</li>
<li><p>FancyButtons<br>一个不用图片就可以帮助我们创建出漂亮按钮的库。<br>项目地址：<a href="https://github.com/medyo/fancybuttons" target="_blank" rel="noopener">https://github.com/medyo/fancybuttons</a><br>Demo 地址：<a href="https://github.com/medyo/fancybuttons/tree/master/samples" target="_blank" rel="noopener">https://github.com/medyo/fancybuttons/tree/master/samples</a><br>效果图：<img src="https://camo.githubusercontent.com/8c5800ef180f69d302237132906737bf71a52caf/68747470733a2f2f7261772e6769746875622e636f6d2f6d6564796f2f66616e6379627574746f6e732f6d61737465722f73637265656e73686f74732f66616e63792e706e67" alt="Renderings"><br><a href="https://raw.githubusercontent.com/medyo/fancybuttons/master/screenshots/fancy2.png" target="_blank" rel="noopener">https://raw.githubusercontent.com/medyo/fancybuttons/master/screenshots/fancy2.png</a>  </p>
</li>
<li><p>Android-RobotoTextView<br>一个实现了所有 Roboto 字体的 TextView，包括新出的 Roboto Slab 字体。<br>项目地址：<a href="https://github.com/johnkil/Android-RobotoTextView" target="_blank" rel="noopener">https://github.com/johnkil/Android-RobotoTextView</a><br>Demo 地址：<a href="http://play.google.com/store/apps/details?id=com.devspark.robototextview" target="_blank" rel="noopener">http://play.google.com/store/apps/details?id=com.devspark.robototextview</a><br>Demo 项目：<a href="https://github.com/johnkil/Android-RobotoTextView/tree/master/robototextview-sample" target="_blank" rel="noopener">https://github.com/johnkil/Android-RobotoTextView/tree/master/robototextview-sample</a><br>效果图：<img src="https://camo.githubusercontent.com/f058c810055e1ff12fa995346059ad399d9c0f95/687474703a2f2f6934362e74696e797069632e636f6d2f6239646736392e706e67" alt="Renderings">  </p>
</li>
<li><p>Android-WizardPager<br>一个表单向导库<br>项目地址：<a href="https://github.com/romannurik/android-wizardpager" target="_blank" rel="noopener">https://github.com/romannurik/android-wizardpager</a><br>Demo 项目：<a href="https://github.com/str4d/android-wizardpager/tree/textfield" target="_blank" rel="noopener">https://github.com/str4d/android-wizardpager/tree/textfield</a><br>效果图：<img src="https://camo.githubusercontent.com/685a1eee3b9b7eb6a0409061031654ea7d6b0b17/68747470733a2f2f6c68352e676f6f676c6575736572636f6e74656e742e636f6d2f2d664944555a3074514373632f554a4e4c6a6e504c5447492f41414141414141416f4f382f784b63654f61746c6a50302f773431332d683638392d6e6f2f322e706e67" alt="Renderings">  </p>
</li>
<li><p>RippleView<br>一个实现了 Android L 上才引入的点击按钮后出现水波纹效果的按钮<br>项目地址：<a href="https://github.com/siriscac/RippleView" target="_blank" rel="noopener">https://github.com/siriscac/RippleView</a><br>Demo 项目：<a href="https://github.com/siriscac/RippleView/tree/master/RippleViewExample" target="_blank" rel="noopener">https://github.com/siriscac/RippleView/tree/master/RippleViewExample</a><br>效果图：<img src="https://camo.githubusercontent.com/eec41193900aad4803dcf18bc9915fafa3f7d1cf/68747470733a2f2f7261772e6769746875622e636f6d2f73697269736361632f526970706c65566965772f6d61737465722f53637265656e732f53637265656e2e676966" alt="Renderings">  </p>
</li>
<li><p>RippleEffect<br>一个实现 Material Design Ripple 效果的库，支持 Android API 9+以上版本。<br>项目地址：<a href="https://github.com/traex/RippleEffect" target="_blank" rel="noopener">https://github.com/traex/RippleEffect</a><br>Demo 项目：<a href="https://github.com/traex/RippleEffect/tree/master/sample" target="_blank" rel="noopener">https://github.com/traex/RippleEffect/tree/master/sample</a><br>效果图：<img src="https://raw.githubusercontent.com/traex/RippleEffect/master/header.png" alt="Renderings">  </p>
</li>
<li><p>RippleCompat<br>使用易于移植的方式为UI控件实现波纹效应，可以适配控件原背景及Palette支持。api简单，可自定义效果，兼容至Android API 7+。<br>项目地址：<a href="https://github.com/desmond1121/RippleCompat" target="_blank" rel="noopener">https://github.com/desmond1121/RippleCompat</a><br>Demo 项目：<a href="https://github.com/desmond1121/RippleCompat/tree/master/app" target="_blank" rel="noopener">https://github.com/desmond1121/RippleCompat/tree/master/app</a><br>效果图：<br><img src="https://raw.githubusercontent.com/desmond1121/RippleCompat/master/demo/Demo.gif" alt="Renderings"></p>
</li>
</ol>
<p>palette效果：<br><img src="https://raw.githubusercontent.com/desmond1121/RippleCompat/master/demo/Demo1.gif" alt="Renderings"></p>
<ol>
<li><p>Android Floating Label Widgets<br>包含一系列控件，这些控件特点是：有默认值，当值不为空时默认值浮动到上面变为提示<br>项目地址：<a href="https://github.com/marvinlabs/android-floatinglabel-widgets" target="_blank" rel="noopener">https://github.com/marvinlabs/android-floatinglabel-widgets</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.marvinlabs.widget.floatinglabel.demo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.marvinlabs.widget.floatinglabel.demo</a><br>在线演示：<a href="http://www.youtube.com/watch?v=hpZD9gJcRg0&amp;feature=youtu.be" target="_blank" rel="noopener">http://www.youtube.com/watch?v=hpZD9gJcRg0&amp;feature=youtu.be</a>  </p>
</li>
<li><p>MaterialEditText<br>EditText 的 Material Design 实现。包含 <a href="http://www.google.com/design/spec/components/text-fields.html" target="_blank" rel="noopener">Google Material Design Spec</a>中的 UI 效果和一些新增特性。<br>项目地址：<a href="https://github.com/rengwuxian/MaterialEditText" target="_blank" rel="noopener">https://github.com/rengwuxian/MaterialEditText</a>  </p>
</li>
<li><p>MaterialEditText<br>实现 <a href="http://www.google.com/design/spec/components/text-fields.html" target="_blank" rel="noopener">Material Design</a> 中 Ripple 效果线条背景的 EditText。直接替换原生 EditText 即可集成。<br>项目地址：<a href="https://github.com/DreamingInCodeZH/MaterialEditText" target="_blank" rel="noopener">https://github.com/DreamingInCodeZH/MaterialEditText</a>    </p>
</li>
<li><p>MultiActionTextView<br>可以分别给 TextView 中的某几个字设置点击事件的 TextView<br>项目地址：<a href="https://github.com/ajaysahani/MultiActionTextView" target="_blank" rel="noopener">https://github.com/ajaysahani/MultiActionTextView</a><br>效果图：<img src="https://camo.githubusercontent.com/1223e37d084e84ec0e22a1b27e7513661d0e1b39/687474703a2f2f692e696d6775722e636f6d2f773934576f53582e706e67" alt="Renderings">  </p>
</li>
<li><p>ToggleButton<br>状态切换的 Button，类似 iOS，用 View 实现<br>项目地址：<a href="https://github.com/zcweng/ToggleButton" target="_blank" rel="noopener">https://github.com/zcweng/ToggleButton</a><br>效果图：<img src="https://github.com/zcweng/ToggleButton/raw/master/ToggleButtonSample/21879.gif" alt="Renderings">  </p>
</li>
<li><p>SwitchButton<br>状态切换的 Button，类似 iOS，拥有良好的用户界面<br>项目地址：<a href="https://github.com/kyleduo/SwitchButton" target="_blank" rel="noopener">https://github.com/kyleduo/SwitchButton</a><br>效果图：<img src="https://raw.githubusercontent.com/kyleduo/SwitchButton/master/preview/demo_131.jpg" alt="Renderings">  </p>
</li>
<li><p>SlideSwitch<br>状态切换的开关，可以设置为类似 IOS 的圆形，也可以设置为矩形，用 View 实现<br>项目地址：<a href="https://github.com/Leaking/SlideSwitch" target="_blank" rel="noopener">https://github.com/Leaking/SlideSwitch</a><br>效果图：<img src="https://github.com/Leaking/SlideSwitch/blob/master/Example/TestLibs/res/drawable-hdpi/slide_c.gif" alt="Renderings">  </p>
</li>
<li><p>ExpandableTextView<br>可展开和收缩内容的 TextView。<br>项目地址：<a href="https://github.com/Manabu-GT/ExpandableTextView" target="_blank" rel="noopener">https://github.com/Manabu-GT/ExpandableTextView</a><br>效果图：<img src="https://camo.githubusercontent.com/8bf46083b3bd152c2051ae4c234649dbbb975376/68747470733a2f2f7261772e6769746875622e636f6d2f4d616e6162752d47542f457870616e6461626c6554657874566965772f6d61737465722f6172742f726561646d655f64656d6f2e676966" alt="Renderings">  </p>
</li>
<li><p>TagCloudView(支持 SingleLine 模式的标签云)<br>标签云效果，只需要一行代码即可设置为 SingleLine 模式，轻松实现知乎问题话题列表效果。SingleLine 模式时末尾文字及图片可自定义。<br>项目地址：<a href="https://github.com/kingideayou/TagCloudView" target="_blank" rel="noopener">https://github.com/kingideayou/TagCloudView</a><br>示例APK地址：<a href="https://github.com/kingideayou/TagCloudView/raw/master/apk/Demo.apk" target="_blank" rel="noopener">https://github.com/kingideayou/TagCloudView/raw/master/apk/Demo.apk</a><br>APP示例：知乎<br>效果图：<img src="https://raw.githubusercontent.com/kingideayou/TagCloudView/master/imgs/tagCloudView_3.gif" alt="Renderings">  </p>
</li>
<li><p>BubbleTextView<br>Android Bubble View<br>项目地址：<a href="https://github.com/dupengtao/BubbleTextView" target="_blank" rel="noopener">https://github.com/dupengtao/BubbleTextView</a><br>效果图：<img src="https://camo.githubusercontent.com/3b8c44089da79868cb45a4da372f2eaae0f3341b/687474703a2f2f3764397069632e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f627562626c65775f766965772e706e67" alt="Renderings">  </p>
</li>
<li><p>shadow-layout<br>Android Shadow Layout<br>解决了<code>CardView</code>：1.不能画圆的阴影。2.设置阴影的位置。3.设置阴影颜色。<br>项目地址：<a href="https://github.com/dmytrodanylyk/shadow-layout" target="_blank" rel="noopener">https://github.com/dmytrodanylyk/shadow-layout</a><br>效果图：<br><img src="https://raw.githubusercontent.com/dmytrodanylyk/shadow-layout/master/screenshots/intro.png" alt="Renderings">  </p>
</li>
<li><p>MoneyTextView<br>一个支持加法运算的金额输入TextView<br>项目地址：<a href="https://github.com/andyken/MoneyTextView" target="_blank" rel="noopener">https://github.com/andyken/MoneyTextView</a><br>效果图：<br><img src="https://github.com/andyken/MoneyTextView/blob/master/sample/sample1.gif" alt="Renderings">  </p>
</li>
</ol>
<h4 id="九、ScrollView"><a href="#九、ScrollView" class="headerlink" title="九、ScrollView"></a>九、ScrollView</h4><ol>
<li><p>Discrollview<br>支持滚动时 Item 淡入淡出，平移，缩放效果的 ScrollView<br>项目地址：<a href="https://github.com/flavienlaurent/discrollview" target="_blank" rel="noopener">https://github.com/flavienlaurent/discrollview</a><br>Demo 地址：<a href="https://github.com/flavienlaurent/discrollview/raw/master/sample.apk" target="_blank" rel="noopener">https://github.com/flavienlaurent/discrollview/raw/master/sample.apk</a>  </p>
</li>
<li><p>PullScrollView<br>仿照新浪微博 Android 客户端个人中心的 ScrollView，下拉背景伸缩回弹效果。<br>项目地址：<a href="https://github.com/MarkMjw/PullScrollView" target="_blank" rel="noopener">https://github.com/MarkMjw/PullScrollView</a><br>效果图：<img src="https://raw.github.com/MarkMjw/PullScrollView/master/Screenshots/1.png" alt="Renderings">  </p>
</li>
<li><p>ArcLayout<br>一个非常简单的弧布局库<br>项目地址：<a href="https://github.com/ogaclejapan/ArcLayout" target="_blank" rel="noopener">https://github.com/ogaclejapan/ArcLayout</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.ogaclejapan.arclayout.demo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.ogaclejapan.arclayout.demo</a><br>效果图：<img src="https://raw.githubusercontent.com/ogaclejapan/ArcLayout/master/art/demo1.gif" alt="Renderings"><br><a href="https://raw.githubusercontent.com/ogaclejapan/ArcLayout/master/art/demo2.gif" target="_blank" rel="noopener">https://raw.githubusercontent.com/ogaclejapan/ArcLayout/master/art/demo2.gif</a>  </p>
</li>
<li><p>ParallaxScrollView<br>支持视差滚动的 ScrollView ，背景图片的滚动速度小于 ScrollView 中子控件的滚动速度<br>项目地址：<a href="https://github.com/chrisjenx/ParallaxScrollView" target="_blank" rel="noopener">https://github.com/chrisjenx/ParallaxScrollView</a><br>Demo 地址：<a href="http://cloud.github.com/downloads/chrisjenx/ParallaxScrollView/ParallaxScrollViewDemo-v1.0.5.apk" target="_blank" rel="noopener">http://cloud.github.com/downloads/chrisjenx/ParallaxScrollView/ParallaxScrollViewDemo-v1.0.5.apk</a>  </p>
</li>
<li><p>AKParallax-Android<br>支持视差滚动的 ScrollView<br>项目地址：<a href="https://github.com/ideaismobile/AKParallax-Android" target="_blank" rel="noopener">https://github.com/ideaismobile/AKParallax-Android</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.appkraft.parallax_sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.appkraft.parallax_sample</a>  </p>
</li>
<li><p>Android-ObservableScrollView<br>监听滚动视图滚动事件的库，帮助与 Toolbar 的交互动效处理与 Material Design 的实现<br>项目地址：<a href="https://github.com/ksoichiro/Android-ObservableScrollView" target="_blank" rel="noopener">https://github.com/ksoichiro/Android-ObservableScrollView</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.github.ksoichiro.android.observablescrollview.samples2" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.github.ksoichiro.android.observablescrollview.samples2</a>  </p>
</li>
<li><p>OverScrollView<br>有弹性的 ScrollView，实现了当手指滑动到 ScrollView 的顶部、底部时，可以继续的向上、向下拉伸。当释放手指的时候，向上、下回弹<br>项目地址：<a href="https://github.com/EverythingMe/OverScrollView" target="_blank" rel="noopener">https://github.com/EverythingMe/OverScrollView</a>  </p>
</li>
</ol>
<h4 id="十、TimeView"><a href="#十、TimeView" class="headerlink" title="十、TimeView"></a>十、TimeView</h4><p>包括 TimePicker、DatePicker、CalendarView、Clock 等时间相关控件  </p>
<ol>
<li><p>android-times-square<br>Android 日历时间部件，支持选取单个日期，多个日期，及日期区间段和对话框形式显示<br>项目地址：<a href="https://github.com/square/android-times-square" target="_blank" rel="noopener">https://github.com/square/android-times-square</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/times-square-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/times-square-demo.apk?raw=true</a>  </p>
</li>
<li><p>android-calendar-card<br>日历<br>项目地址：<a href="https://github.com/kenumir/android-calendar-card" target="_blank" rel="noopener">https://github.com/kenumir/android-calendar-card</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.wt.calendarcardsample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.wt.calendarcardsample</a><br>效果图：<img src="https://raw.github.com/kenumir/android-calendar-card/master/calendar-card-sample/_work/device-2013-10-12-151801.png" alt="Renderings">  </p>
</li>
<li><p>AndroidWheel<br>Android Wheel 支持城市、多种日期时间、密码、图片<br>项目地址：<a href="https://code.google.com/p/android-wheel/" target="_blank" rel="noopener">https://code.google.com/p/android-wheel/</a><br>效果图：<img src="http://farm6.staticflickr.com/5532/11621528786_220c040ba5_o.jpg" alt="Renderings">  </p>
</li>
<li><p>GoogleDateTimePickers<br>时间选择部件<br>项目地址：<a href="https://github.com/Mirkoddd/GoogleDateTimePickers" target="_blank" rel="noopener">https://github.com/Mirkoddd/GoogleDateTimePickers</a><br>文档介绍：<a href="https://play.google.com/store/apps/details?id=com.mirko.sample&amp;hl=it" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.mirko.sample&amp;hl=it</a>  </p>
</li>
<li><p>DateTimePicker<br>日期选择部件(Google Agenda 的样式风格)<br>项目地址：<a href="https://github.com/flavienlaurent/datetimepicker" target="_blank" rel="noopener">https://github.com/flavienlaurent/datetimepicker</a><br>Demo 地址：<a href="https://raw.github.com/biboune/datetimepicker/master/datetimepicker-sample.apk" target="_blank" rel="noopener">https://raw.github.com/biboune/datetimepicker/master/datetimepicker-sample.apk</a><br>效果图：<img src="https://camo.githubusercontent.com/493edeea3eb553ad0d0b121dbead0d7ec6a858f2/68747470733a2f2f7261772e6769746875622e636f6d2f6269626f756e652f6461746574696d657069636b65722f6d61737465722f67726170686963732f696d67312e706e67" alt="Renderings">  </p>
</li>
<li><p>android-betterpickers<br>提供日期、数字、时间（数字方式和钟表方式）、重复周期（闹钟的周期重复）、HMS（时、分、秒）的选择，支持以 DialogFragment 的弹窗选择<br>项目地址：<a href="https://github.com/derekbrameyer/android-betterpickers" target="_blank" rel="noopener">https://github.com/derekbrameyer/android-betterpickers</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.doomonafireball.betterpickers.sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.doomonafireball.betterpickers.sample</a><br>效果图：<img src="https://camo.githubusercontent.com/897ae3c71b49c4366565f3480719647687b1804a/68747470733a2f2f7261772e6769746875622e636f6d2f646572656b6272616d657965722f616e64726f69642d6265747465727069636b6572732f6d61737465722f73616d706c652f696d61676572792f7765625f666561747572655f677261706869632e706e67" alt="Renderings">  </p>
</li>
<li><p>Android Week View<br>日期控件，支持周，天视图，支持自定义样式<br>项目地址：<a href="https://github.com/alamkanak/Android-Week-View" target="_blank" rel="noopener">https://github.com/alamkanak/Android-Week-View</a><br>效果图：<img src="https://github.com/alamkanak/Android-Week-View/blob/master/images/screen-shot.png" alt="Renderings">  </p>
</li>
<li><p>PickerView<br>仿 iOS 的 PickerView 控件，有时间选择和选项选择并支持一二三级联动效果，TimePopupWindow 时间选择器，支持年月日时分，年月日，时分等格式；OptionsPopupWindow 选项选择器，支持一，二，三级选项选择，并且可以设置是否联动<br>项目地址：<a href="https://github.com/saiwu-bigkoo/Android-PickerView" target="_blank" rel="noopener">https://github.com/saiwu-bigkoo/Android-PickerView</a><br>效果图：<img src="https://github.com/saiwu-bigkoo/PickerView/blob/master/preview/pickerdemo.gif" alt="Renderings">  </p>
</li>
<li><p>CountdownView<br>Android 倒计时控件，使用Canvas绘制，支持多种样式<br>项目地址：<a href="https://github.com/iwgang/CountdownView" target="_blank" rel="noopener">https://github.com/iwgang/CountdownView</a><br>效果图：<img src="https://raw.githubusercontent.com/iwgang/CountdownView/master/screenshot/screenshot.gif" alt="Renderings"></p>
</li>
</ol>
<h4 id="十一、TipView"><a href="#十一、TipView" class="headerlink" title="十一、TipView"></a>十一、TipView</h4><p>包括 Toast、角标、UndoBar 等提示性控件  </p>
<ol>
<li><p>SVProgressHUD<br>SVProgressHUD For Android 精仿iOS的提示库 SVProgressHUD，api也几乎一样。<br>项目地址：<a href="https://github.com/saiwu-bigkoo/Android-SVProgressHUD" target="_blank" rel="noopener">https://github.com/saiwu-bigkoo/Android-SVProgressHUD</a><br>效果图：<img src="https://github.com/saiwu-bigkoo/Android-SVProgressHUD/raw/master/preview/svprogresshuddemo.gif" alt="Renderings">  </p>
</li>
<li><p>Crouton<br>丰富样式的 Toast，允许 alert、comfirm、info 样式及点击消失样式，允许设置 Toast 显示时间，允许自定义 View。 本文 32. SuperToasts 为其扩展版<br>项目地址：<a href="https://github.com/keyboardsurfer/Crouton" target="_blank" rel="noopener">https://github.com/keyboardsurfer/Crouton</a><br>Demo 地址：<a href="http://play.google.com/store/apps/details?id=de.keyboardsurfer.app.demo.crouton" target="_blank" rel="noopener">http://play.google.com/store/apps/details?id=de.keyboardsurfer.app.demo.crouton</a>  </p>
</li>
<li><p>supertooltips<br>带动画效果的 Tips 显示<br>项目地址：<a href="https://github.com/nhaarman/supertooltips" target="_blank" rel="noopener">https://github.com/nhaarman/supertooltips</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.haarman.supertooltips" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.haarman.supertooltips</a>  </p>
</li>
<li><p>Android ViewBadger<br>为其他 View 添加角标（消息圆点）等<br>项目地址：<a href="https://github.com/jgilfelt/android-viewbadger" target="_blank" rel="noopener">https://github.com/jgilfelt/android-viewbadger</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/android-viewbadger.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/android-viewbadger.apk?raw=true</a><br>效果图：<img src="http://www.jeffgilfelt.com/viewbadger/vb-1a.png" alt="Renderings">  </p>
</li>
<li><p>SuperToasts<br>更丰富样式的 toast，支持 Button、Progress、Horizontal Progress 样式、支持进入动画、支持撤销及其动画设置<br>项目地址：<a href="https://github.com/JohnPersano/SuperToasts" target="_blank" rel="noopener">https://github.com/JohnPersano/SuperToasts</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.supertoastsdemo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.supertoastsdemo</a><br>效果图：<img src="http://i1331.photobucket.com/albums/w597/JohnPersano/supertoasts_githubimage_zps8a5ceb7c.png" alt="Renderings">  </p>
</li>
<li><p>UndoBar<br>屏幕底部显示取消或是确认的 PopupWindows<br>项目地址：<a href="https://github.com/soarcn/UndoBar" target="_blank" rel="noopener">https://github.com/soarcn/UndoBar</a><br>效果图：<img src="https://github.com/soarcn/UndoBar/blob/master/art/redo.png?raw=true" alt="Renderings">  </p>
</li>
<li><p>UndoBar<br>屏幕底部显示取消或是确认某操作<br>项目地址：<a href="https://github.com/jenzz/Android-UndoBar" target="_blank" rel="noopener">https://github.com/jenzz/Android-UndoBar</a><br>效果图：<img src="https://raw.github.com/jenzz/Android-UndoBar/master/assets/Screenshot2.png" alt="Renderings">  </p>
</li>
<li><p>Android-ActionItemBadge<br>可以在 ActionBar 的 MenuItem 上显示一个小角标<br>项目地址：<a href="https://github.com/mikepenz/Android-ActionItemBadge" target="_blank" rel="noopener">https://github.com/mikepenz/Android-ActionItemBadge</a><br>效果图：<img src="https://raw.githubusercontent.com/mikepenz/Android-ActionItemBadge/master/DEV/screenshot/screenshot1_small.png" alt="Renderings">  </p>
</li>
<li><p>SnackBar<br>Material Design 风格的 Toast，类似 Google inbox 中的提示<br>项目地址：<a href="https://github.com/MrEngineer13/SnackBar" target="_blank" rel="noopener">https://github.com/MrEngineer13/SnackBar</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.mrengineer13.snackbar.sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.mrengineer13.snackbar.sample</a><br>效果图：<img src="https://camo.githubusercontent.com/67a39af16f3d46631567c1f7bd7dcddeb3c4c9e9/687474703a2f2f6d6174657269616c2d64657369676e2e73746f726167652e676f6f676c65617069732e636f6d2f696d616765732f636f6d706f6e656e74732d746f617374732d73706563732d737065635f746f6173745f30335f315f6c617267655f6d6470692e706e67" alt="Renderings">  </p>
</li>
<li><p>HeadsUp<br>在 2.3 上使用 android  5.0 的 HeadsUp 效果<br>项目地址：<a href="https://github.com/zzz40500/HeadsUp" target="_blank" rel="noopener">https://github.com/zzz40500/HeadsUp</a><br>效果图：<img src="gif%5D(http://upload-images.jianshu.io/upload_images/166866-543a5d26ab71d0f6.gif" alt="Renderings">  </p>
</li>
</ol>
<h4 id="十二、FlipView"><a href="#十二、FlipView" class="headerlink" title="十二、FlipView"></a>十二、FlipView</h4><ol>
<li><p>android-flip<br>类似 Flipboard 翻转动画的实现<br>项目地址：<a href="https://github.com/openaphid/android-flip" target="_blank" rel="noopener">https://github.com/openaphid/android-flip</a><br>Demo 地址：<a href="https://github.com/openaphid/android-flip/blob/master/FlipView/Demo/APK/Aphid-FlipView-Demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/openaphid/android-flip/blob/master/FlipView/Demo/APK/Aphid-FlipView-Demo.apk?raw=true</a><br>APP 示例：flipboard  </p>
</li>
<li><p>FlipImageView<br>支持 x、y、z 及动画选择的翻转动画的实现<br>项目地址：<a href="https://github.com/castorflex/FlipImageView" target="_blank" rel="noopener">https://github.com/castorflex/FlipImageView</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=fr.castorflex.android.flipimageview" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=fr.castorflex.android.flipimageview</a>  </p>
</li>
<li><p>FoldableLayout<br>Flip 翻转效果的 ListView，目前还不支持 ListView 缓存<br>项目地址：<a href="https://github.com/alexvasilkov/FoldableLayout" target="_blank" rel="noopener">https://github.com/alexvasilkov/FoldableLayout</a><br>Demo 地址：<a href="http://play.google.com/store/apps/details?id=com.alexvasilkov.foldablelayout.sample" target="_blank" rel="noopener">http://play.google.com/store/apps/details?id=com.alexvasilkov.foldablelayout.sample</a>  </p>
</li>
<li><p>FlipViewPager.Draco<br>Flip 翻转效果的 ViewPager<br>项目地址：<a href="https://github.com/Yalantis/FlipViewPager.Draco" target="_blank" rel="noopener">https://github.com/Yalantis/FlipViewPager.Draco</a><br>效果：<img src="https://camo.githubusercontent.com/db312e031e5f5a445b548d35986b0498caa261d3/68747470733a2f2f6431337961637572716a676172612e636c6f756466726f6e742e6e65742f75736572732f3132353035362f73637265656e73686f74732f313735383239382f39396d696c65732d66696e642d667269656e64732d696e746572666163652d616e696d6174696f6e2e676966" alt="flip.gif">  </p>
</li>
</ol>
<h4 id="十三、ColorPickView"><a href="#十三、ColorPickView" class="headerlink" title="十三、ColorPickView"></a>十三、ColorPickView</h4><ol>
<li><p>ColorPickerView<br>颜色选择器，支持 PopupWindows 或新的 Activity 中打开<br>项目地址：<a href="https://code.google.com/p/color-picker-view/" target="_blank" rel="noopener">https://code.google.com/p/color-picker-view/</a><br>效果图：<img src="http://oi41.tinypic.com/33c6mm8.jpg" alt="Renderings">  </p>
</li>
<li><p>HoloColorPicker<br>颜色选择器<br>项目地址：<a href="https://github.com/LarsWerkman/HoloColorPicker" target="_blank" rel="noopener">https://github.com/LarsWerkman/HoloColorPicker</a><br>Demo 地址：<a href="https://docs.google.com/file/d/0BwclyDTlLrdXRzVnTGJvTlRfU2s/edit" target="_blank" rel="noopener">https://docs.google.com/file/d/0BwclyDTlLrdXRzVnTGJvTlRfU2s/edit</a>  </p>
</li>
<li><p>ColorPickerPreference<br>颜色选择器<br>项目地址：<a href="https://github.com/attenzione/android-ColorPickerPreference" target="_blank" rel="noopener">https://github.com/attenzione/android-ColorPickerPreference</a><br>效果图：<img src="https://github.com/attenzione/android-ColorPickerPreference/raw/master/screen_2.png" alt="Renderings">  </p>
</li>
<li><p>ColorPicker<br>颜色选择器（Google Agenda 中的样式风格）<br>项目地址：<a href="https://github.com/flavienlaurent/colorpicker" target="_blank" rel="noopener">https://github.com/flavienlaurent/colorpicker</a><br>Demo 地址：<a href="https://raw.github.com/biboune/colorpicker/master/colorpicker-sample.apk" target="_blank" rel="noopener">https://raw.github.com/biboune/colorpicker/master/colorpicker-sample.apk</a><br>效果图：<img src="https://camo.githubusercontent.com/a42581e637ca379004855d69e262d85ea966fa35/68747470733a2f2f7261772e6769746875622e636f6d2f6269626f756e652f636f6c6f727069636b65722f6d61737465722f67726170686963732f696d67312e706e67" alt="Renderings">  </p>
</li>
</ol>
<h4 id="十四、GraphView"><a href="#十四、GraphView" class="headerlink" title="十四、GraphView"></a>十四、GraphView</h4><ol>
<li><p>MPAndroidChart<br>强大的图表绘制工具，支持折线图、面积图、散点图、时间图、柱状图、条图、饼图、气泡图、圆环图、范围（高至低）条形图、网状图等；支持图的拖拽缩放；支持 Android 2.2 以上，支持横纵轴缩放，多指缩放，展现动画、高亮、保存到 sdcard、从文件读取图表<br>项目地址：<a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="noopener">https://github.com/PhilJay/MPAndroidChart</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.xxmassdeveloper.mpchartexample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.xxmassdeveloper.mpchartexample</a><br>Demo 项目：<a href="https://github.com/PhilJay/MPAndroidChart/tree/master/MPChartExample" target="_blank" rel="noopener">https://github.com/PhilJay/MPAndroidChart/tree/master/MPChartExample</a><br>效果图：<img src="https://camo.githubusercontent.com/a9eaa5fc7fb6c1e70b22acd09385055e0f5c4fe7/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d5043686172742f6d61737465722f73637265656e73686f74732f73696d706c6564657369676e5f6c696e656368617274342e706e67" alt="Renderings"><br><a href="https://camo.githubusercontent.com/78b4bc4e50e151970961daf56e81c4c0db72d27c/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d5043686172742f6d61737465722f73637265656e73686f74732f73696d706c6564657369676e5f6261726368617274332e706e67" target="_blank" rel="noopener">https://camo.githubusercontent.com/78b4bc4e50e151970961daf56e81c4c0db72d27c/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d5043686172742f6d61737465722f73637265656e73686f74732f73696d706c6564657369676e5f6261726368617274332e706e67</a><br><a href="https://camo.githubusercontent.com/65f51783ec05038730b481ed614b57a94e867d86/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d5043686172742f6d61737465722f73637265656e73686f74732f626172636861727432642e706e67" target="_blank" rel="noopener">https://camo.githubusercontent.com/65f51783ec05038730b481ed614b57a94e867d86/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d5043686172742f6d61737465722f73637265656e73686f74732f626172636861727432642e706e67</a><br><a href="https://camo.githubusercontent.com/f66a35bf430b12480d3e2ed8e3bc8d7a17db950f/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d5043686172742f6d61737465722f73637265656e73686f74732f626172636861727433642e706e67" target="_blank" rel="noopener">https://camo.githubusercontent.com/f66a35bf430b12480d3e2ed8e3bc8d7a17db950f/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d5043686172742f6d61737465722f73637265656e73686f74732f626172636861727433642e706e67</a><br><a href="https://camo.githubusercontent.com/60bd0d71462ad577df775b956944b191e939728a/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d50416e64726f696443686172742f6d61737465722f73637265656e73686f74732f70696563686172745f686f6c657261646975735f73706163652e706e67" target="_blank" rel="noopener">https://camo.githubusercontent.com/60bd0d71462ad577df775b956944b191e939728a/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d50416e64726f696443686172742f6d61737465722f73637265656e73686f74732f70696563686172745f686f6c657261646975735f73706163652e706e67</a><br><a href="https://camo.githubusercontent.com/6b254aa699df7f9464967009129c3017de721b77/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d50416e64726f696443686172742f6d61737465722f73637265656e73686f74732f7363617474657263686172742e706e67" target="_blank" rel="noopener">https://camo.githubusercontent.com/6b254aa699df7f9464967009129c3017de721b77/68747470733a2f2f7261772e6769746875622e636f6d2f5068696c4a61792f4d50416e64726f696443686172742f6d61737465722f73637265656e73686f74732f7363617474657263686172742e706e67</a><br>在线演示：<a href="https://www.youtube.com/watch?v=ufaK_Hd6BpI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ufaK_Hd6BpI</a>  </p>
</li>
<li><p>achartengine<br>强大的图表绘制工具，支持折线图、面积图、散点图、时间图、柱状图、条图、饼图、气泡图、圆环图、范围（高至低）条形图、拨号图/表、立方线图及各种图的结合<br>项目地址：<a href="https://code.google.com/p/achartengine/" target="_blank" rel="noopener">https://code.google.com/p/achartengine/</a><br>效果图：<img src="http://www.achartengine.org/dimages/average_temperature.png" alt="Renderings"><br><a href="http://www.achartengine.org/dimages/sales_line_and_area_chart.png" target="_blank" rel="noopener">http://www.achartengine.org/dimages/sales_line_and_area_chart.png</a><br><a href="http://www.achartengine.org/dimages/temperature_range_chart.png" target="_blank" rel="noopener">http://www.achartengine.org/dimages/temperature_range_chart.png</a><br><a href="http://www.achartengine.org/dimages/combined_chart.png" target="_blank" rel="noopener">http://www.achartengine.org/dimages/combined_chart.png</a><br><a href="http://www.achartengine.org/dimages/budget_chart.png" target="_blank" rel="noopener">http://www.achartengine.org/dimages/budget_chart.png</a><br>官网网址：<a href="http://www.achartengine.org/" target="_blank" rel="noopener">http://www.achartengine.org/</a><br>APP 示例：Wordpress Android，Google Analytics  </p>
</li>
<li><p>GraphView<br>绘制图表和曲线图的 View，可用于 Android 上的曲形图、柱状图、波浪图展示<br>项目地址：<a href="https://github.com/jjoe64/GraphView" target="_blank" rel="noopener">https://github.com/jjoe64/GraphView</a><br>Demo 项目：<a href="https://github.com/jjoe64/GraphView-Demos" target="_blank" rel="noopener">https://github.com/jjoe64/GraphView-Demos</a><br>APP 示例：Wordpress Android，Google Analytics  </p>
</li>
<li><p>HoloGraphLibrary<br>绘制现状图、柱状图、饼状图<br>项目地址：<a href="https://bitbucket.org/danielnadeau/holographlibrary/src" target="_blank" rel="noopener">https://bitbucket.org/danielnadeau/holographlibrary/src</a><br>文档介绍：<a href="https://bitbucket.org/danielnadeau/holographlibrary/wiki/Home" target="_blank" rel="noopener">https://bitbucket.org/danielnadeau/holographlibrary/wiki/Home</a>  </p>
</li>
<li><p>XCL-Charts<br>XCL-Charts 基于原生的 Canvas 来绘制各种图表,在设计时，尽量在保证开发效率的同时，给使用者提供足够多的定制化能力。因此使用简便,同时具有相当灵活的定制能力。目前支持 3D/非 3D 柱形图(Bar Chart)、3D/非 3D 饼图(Pie Chart)、堆积图(Stacked Bar Chart)、面积图(Area Chart)、 折线图(Line Chart)、曲线图(Spline Chart)、环形图(Dount Chart)、南丁格尔玫瑰图(Rose Chart)、仪表盘(Dial Chart)、刻度盘(Gauge Chart)、雷达图(Radar Chart)、圆形图(Circle Chart)等图表。其它特性还包括支持图表缩放、手势移动、动画显示效果、高密度柱形显示、图表分界定制线、多图表的混合显示及同数据源不同类型图表切换等。<br>项目地址：<a href="https://github.com/xcltapestry/XCL-Charts" target="_blank" rel="noopener">https://github.com/xcltapestry/XCL-Charts</a><br>Demo 地址：<a href="https://github.com/xcltapestry/XCL-Charts/blob/master/XCL-Charts-demo/bin/XCL-Charts-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/xcltapestry/XCL-Charts/blob/master/XCL-Charts-demo/bin/XCL-Charts-demo.apk?raw=true</a>  </p>
</li>
<li><p>EazeGraph<br>Android 图表库，支持柱状图、分层柱状图、饼状图、线性图<br>项目地址：<a href="https://github.com/blackfizz/EazeGraph" target="_blank" rel="noopener">https://github.com/blackfizz/EazeGraph</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=org.eazegraph.app" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=org.eazegraph.app</a>  </p>
</li>
<li><p>WilliamChart<br>绘制图表的库，支持 LineChartView、BarChartView 和 StackBarChartView 三中图表类型，并且支持 Android 2.2 及以上的系统。<br>项目地址：<a href="https://github.com/diogobernardino/WilliamChart" target="_blank" rel="noopener">https://github.com/diogobernardino/WilliamChart</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.db.williamchartdemo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.db.williamchartdemo</a><br>Demo 项目：<a href="https://github.com/diogobernardino/WilliamChart/tree/master/sample" target="_blank" rel="noopener">https://github.com/diogobernardino/WilliamChart/tree/master/sample</a><br>效果图：<img src="https://github.com/diogobernardino/WilliamChart/raw/master/art/linechart.gif" alt="Renderings">)<img src="https://github.com/diogobernardino/WilliamChart/raw/master/art/barchart.gif" alt="Renderings">)<img src="https://github.com/diogobernardino/WilliamChart/raw/master/art/stackbarchart.gif" alt="Renderings">  </p>
</li>
<li><p>HelloCharts for Android<br>支持折线图、柱状图、饼图、气泡图、组合图；支持预览、放大缩小，滚动，部分图表支持动画；支持 Android 2.2 以上<br>项目地址：<a href="https://github.com/lecho/hellocharts-android" target="_blank" rel="noopener">https://github.com/lecho/hellocharts-android</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=lecho.lib.hellocharts.samples" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=lecho.lib.hellocharts.samples</a><br>在线演示：<a href="https://www.youtube.com/watch?v=xbSBjyjH2SY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=xbSBjyjH2SY</a>  </p>
</li>
<li><p>PieChartView<br>比较简单直接的饼状统计报表图，使用方便，设置相应的属性参数即可<br>项目地址：<a href="https://github.com/wuseal/PieChartView" target="_blank" rel="noopener">https://github.com/wuseal/PieChartView</a><br>Demo 地址：<a href="https://github.com/wuseal/PieChartView" target="_blank" rel="noopener">https://github.com/wuseal/PieChartView</a><br>效果图：<br><img src="https://github.com/wuseal/PieChartView/blob/master/demo.png?raw=true" alt="Renderings">  </p>
</li>
</ol>
<h4 id="十五、UI-Style"><a href="#十五、UI-Style" class="headerlink" title="十五、UI Style"></a>十五、UI Style</h4><p>不同样式的系统 UI 风格，如 IOS、Bootstrap 风格  </p>
<ol>
<li><p>UITableView<br>ios 风格控件，包括 Button、ListView、TableView<br>项目地址：<a href="https://github.com/thiagolocatelli/android-uitableview" target="_blank" rel="noopener">https://github.com/thiagolocatelli/android-uitableview</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/ui-tableview-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/ui-tableview-demo.apk?raw=true</a>  </p>
</li>
<li><p>ATableView<br>ios 风格控件<br>项目地址：<a href="https://github.com/dmacosta/ATableView" target="_blank" rel="noopener">https://github.com/dmacosta/ATableView</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.nakardo.atableview.demo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.nakardo.atableview.demo</a>  </p>
</li>
<li><p>Cards-UI<br>卡片式 View，支持单个卡片，item 为卡片的 ListView<br>项目地址：<a href="https://github.com/afollestad/Cards-UI" target="_blank" rel="noopener">https://github.com/afollestad/Cards-UI</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/cards-ui-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/cards-ui-demo.apk?raw=true</a>  </p>
</li>
<li><p>cardslib<br>卡片式 View，支持单个卡片，item 为卡片的 ListView 和 GridView<br>项目地址：<a href="https://github.com/gabrielemariotti/cardslib" target="_blank" rel="noopener">https://github.com/gabrielemariotti/cardslib</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=it.gmariotti.cardslib.demo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=it.gmariotti.cardslib.demo</a>  </p>
</li>
<li><p>Android-Bootstrap<br>Bootstrap 风格的按钮<br>项目地址：<a href="https://github.com/Bearded-Hen/Android-Bootstrap" target="_blank" rel="noopener">https://github.com/Bearded-Hen/Android-Bootstrap</a><br>效果图：<img src="https://raw.github.com/Bearded-Hen/Android-Bootstrap/master/images/device_image.png" alt="Renderings">  </p>
</li>
<li><p>Material Design Android Library<br>Android L 中 Material Design 风格的组件适配到 Android 2.2+<br>项目地址：<a href="https://github.com/navasmdc/MaterialDesignLibrary" target="_blank" rel="noopener">https://github.com/navasmdc/MaterialDesignLibrary</a>  </p>
</li>
<li><p>Android FlatUI<br>Android 扁平化风格的组件，支持一些自定义样式<br>项目地址：<a href="https://github.com/eluleci/FlatUI" target="_blank" rel="noopener">https://github.com/eluleci/FlatUI</a><br>效果图：<img src="https://camo.githubusercontent.com/590d4a2ac322417b71f83223bd58b83903d58343/68747470733a2f2f7261772e6769746875622e636f6d2f656c756c6563692f466c617455492f6d61737465722f73616d706c652d696d616765732f73686f77636173652e706e67" alt="Renderings">  </p>
</li>
<li><p>cheesesquare<br>全新 Android 设计库演示 Demo，包括 Collapsing Toolbar、FloatingActionButton、View anchoring、NavigationView、Snackbar<br>项目地址：<a href="https://github.com/chrisbanes/cheesesquare" target="_blank" rel="noopener">https://github.com/chrisbanes/cheesesquare</a><br>效果图：<img src="http://7xikfc.com1.z0.glb.clouddn.com/Screenshot_2015-07-17-12-22-07.png" alt="Renderings">  </p>
</li>
</ol>
<h4 id="十六、其他"><a href="#十六、其他" class="headerlink" title="十六、其他"></a>十六、其他</h4><ol>
<li><p>SnappingStepper<br>一种漂亮的UI控件，能更灵活的控制数字的增减。可用于购物车商品数量控制。<br>项目地址：<a href="https://github.com/saiwu-bigkoo/Android-SnappingStepper" target="_blank" rel="noopener">https://github.com/saiwu-bigkoo/Android-SnappingStepper</a><br>效果图：<img src="https://github.com/saiwu-bigkoo/Android-SnappingStepper/blob/master/preview/snappingstepperdemo.gif" alt="Renderings">  </p>
</li>
<li><p>SwipeBackLayout<br>左右或向上滑动返回的 Activity<br>项目地址：<a href="https://github.com/Issacw0ng/SwipeBackLayout" target="_blank" rel="noopener">https://github.com/Issacw0ng/SwipeBackLayout</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=me.imid.swipebacklayout.demo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=me.imid.swipebacklayout.demo</a><br>APP 示例：知乎  </p>
</li>
<li><p>ParallaxBackLayout<br>视差滑动返回的 Activity<br>项目地址：<a href="https://github.com/anzewei/ParallaxBackLayout" target="_blank" rel="noopener">https://github.com/anzewei/ParallaxBackLayout</a><br>Demo 地址：<a href="https://github.com/anzewei/ParallaxBackLayout/blob/master/ext/demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/anzewei/ParallaxBackLayout/blob/master/ext/demo.apk?raw=true</a><br>效果图：<img src="https://github.com/anzewei/ParallaxBackLayout/blob/master/ext/v0.2.gif" alt="Renderings">  </p>
</li>
<li><p>android-styled-dialogs<br>可自定义样式的 dialog，默认与 Holo 主题样式一致，在 Android2.2 以上同一样式<br>项目地址：<a href="https://github.com/inmite/android-styled-dialogs" target="_blank" rel="noopener">https://github.com/inmite/android-styled-dialogs</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/styled-dialogs-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/styled-dialogs-demo.apk?raw=true</a>  </p>
</li>
<li><p>Android Sliding Up Panel<br>可拖动的 View，能在当前 Activity 上扶起一个可拖动的 Panel<br>项目地址：<a href="https://github.com/umano/AndroidSlidingUpPanel" target="_blank" rel="noopener">https://github.com/umano/AndroidSlidingUpPanel</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.sothree.umano" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.sothree.umano</a><br>APP 示例：Google Music 精简播放栏  </p>
</li>
<li><p>TableFixHeaders<br>第一列固定的 Table<br>项目地址：<a href="https://github.com/InQBarna/TableFixHeaders" target="_blank" rel="noopener">https://github.com/InQBarna/TableFixHeaders</a><br>Demo 地址：<a href="http://bit.ly/13buAIq" target="_blank" rel="noopener">http://bit.ly/13buAIq</a>  </p>
</li>
<li><p>Inscription<br>可用于展示应用 change 和 new feature 信息<br>项目地址：<a href="https://github.com/MartinvanZ/Inscription" target="_blank" rel="noopener">https://github.com/MartinvanZ/Inscription</a>  </p>
</li>
<li><p>ActivityTransition<br>Activity 切换动画，包括渐变、flip、某个位置进入等等<br>项目地址：<a href="https://github.com/ophilbert/ActivityTransition" target="_blank" rel="noopener">https://github.com/ophilbert/ActivityTransition</a><br>文档介绍：<a href="https://github.com/jfeinstein10/JazzyViewPager/blob/master/JazzyViewPager.apk?raw=true" target="_blank" rel="noopener">https://github.com/jfeinstein10/JazzyViewPager/blob/master/JazzyViewPager.apk?raw=true</a>  </p>
</li>
<li><p>EasyAndroidAnimations<br>针对 View 的各种动画<br>项目地址：<a href="https://github.com/2359media/EasyAndroidAnimations" target="_blank" rel="noopener">https://github.com/2359media/EasyAndroidAnimations</a>  </p>
</li>
<li><p>ViewAnimation<br>对android view 动画进行封装,实现起更简单，自带三种常见运动路径，其他的可自定义<br>项目地址：<a href="https://github.com/guohuanwen/ViewAniamtion" target="_blank" rel="noopener">https://github.com/guohuanwen/ViewAniamtion</a><br>效果图：<img src="https://github.com/guohuanwen/ViewAniamtion/blob/master/sreenshots/AnimationGif.gif" alt="ViewAnimation"><br>APP 示例：QQ名片圈圈效果  </p>
</li>
<li><p>AndroidLoadingAnimation<br>多种android加载动画<br>项目地址：<a href="https://github.com/guohuanwen/AndroidLoadingAnimation" target="_blank" rel="noopener">https://github.com/guohuanwen/AndroidLoadingAnimation</a><br>效果图：<img src="https://github.com/guohuanwen/AndroidLoadingAnimation/blob/master/screenshots/taiji1.gif" alt="TaiJIView">  </p>
</li>
</ol>
<ol>
<li><p>android-lockpattern<br>Android 的图案密码解锁<br>项目地址：<a href="https://code.google.com/p/android-lockpattern/" target="_blank" rel="noopener">https://code.google.com/p/android-lockpattern/</a><br>原理剖析文档：[android-lockpattern](<a href="http://a.codekk.com/detail/Android/爱早起/Android" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/爱早起/Android</a> Lock Pattern 源码解析)<br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=group.pals.android.lib.ui.lockpattern.demo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=group.pals.android.lib.ui.lockpattern.demo</a><br>文档介绍：<a href="https://code.google.com/p/android-lockpattern/wiki/QuickUse" target="_blank" rel="noopener">https://code.google.com/p/android-lockpattern/wiki/QuickUse</a><br>APP 示例：Android 开机的图案密码解锁，支付宝的密码解锁  </p>
</li>
<li><p>PatternLock<br>另一个 Android 图案解锁库<br>项目地址：<a href="https://github.com/DreaminginCodeZH/PatternLock" target="_blank" rel="noopener">https://github.com/DreaminginCodeZH/PatternLock</a><br>Demo 地址：<a href="https://github.com/DreaminginCodeZH/PatternLock/raw/master/dist/sample.apk" target="_blank" rel="noopener">https://github.com/DreaminginCodeZH/PatternLock/raw/master/dist/sample.apk</a><br>效果图：<img src="https://github.com/DreaminginCodeZH/PatternLock/raw/master/image/sample_small.png" alt="Renderings"><br>APP 示例：Android 开机的图案密码解锁，支付宝的密码解锁  </p>
</li>
<li><p>RangeBar<br>类似于 SeekBar，不同的是可以选择一个范围内的值而不是单个值<br>项目地址：<a href="https://github.com/edmodo/range-bar" target="_blank" rel="noopener">https://github.com/edmodo/range-bar</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/range-bar-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/range-bar-demo.apk?raw=true</a><br>效果图：<img src="http://i.imgur.com/q85GhRjl.png" alt="Renderings">  </p>
</li>
<li><p>ChromeView<br>利用 Chromium 实现的 WebView，解决各个 Android 版本 WebView 不同的问题，同时利用最新 Chrome 代码<br>项目地址：<a href="https://github.com/pwnall/chromeview" target="_blank" rel="noopener">https://github.com/pwnall/chromeview</a>  </p>
</li>
<li><p>android-phased-seek-bar<br>支持预先定义状态的 SeekBar<br>项目地址：<a href="https://github.com/ademar111190/android-phased-seek-bar" target="_blank" rel="noopener">https://github.com/ademar111190/android-phased-seek-bar</a><br>效果图：<img src="https://raw.githubusercontent.com/ademar111190/android-phased-seek-bar/master/images/sample.gif" alt="Renderings">  </p>
</li>
<li><p>Android Slider Preference Library<br>可添加到设置中的基于对话框的 RankBar 小部件<br>项目地址：<a href="https://github.com/jayschwa/AndroidSliderPreference" target="_blank" rel="noopener">https://github.com/jayschwa/AndroidSliderPreference</a>  </p>
</li>
<li><p>ShowcaseView library<br>用于高亮显示应用程序的特定部分，从而突出突出重点<br>项目地址：<a href="https://github.com/amlcurran/ShowcaseView" target="_blank" rel="noopener">https://github.com/amlcurran/ShowcaseView</a>  </p>
</li>
<li><p>android-segmented-control<br>Android 上的 Segmented Controls，相当于 RadioButton 组<br>项目地址：<a href="https://github.com/hoang8f/android-segmented-control" target="_blank" rel="noopener">https://github.com/hoang8f/android-segmented-control</a>  </p>
</li>
<li><p>Swipeable Cards<br>类似 Tinder 的卡片效果，可以加载图片并动画效果展示，向左滑动表示喜欢，向右表示不喜欢<br>项目地址：<a href="https://github.com/kikoso/Swipeable-Cards" target="_blank" rel="noopener">https://github.com/kikoso/Swipeable-Cards</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=info.hoang8f.fbutton.demo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=info.hoang8f.fbutton.demo</a>  </p>
</li>
<li><p>EdgeEffectOverride<br>改变 ScrollView, ListView, ExpandableListView, GridView, ViewPager 等滚动控件滚动到边缘的颜色效果<br>项目地址：<a href="https://github.com/AndroidAlliance/EdgeEffectOverride" target="_blank" rel="noopener">https://github.com/AndroidAlliance/EdgeEffectOverride</a>  </p>
</li>
<li><p>android-pinned-header-listviews<br>使 ExpandListView 的 Group 滑动到顶端时会固定不动直到另外一个 Group 到达顶端<br>项目地址：<a href="https://github.com/rtyley/android-pinned-header-listviews" target="_blank" rel="noopener">https://github.com/rtyley/android-pinned-header-listviews</a>  </p>
</li>
<li><p>AndroidSwipeLayout<br>滑动 Layout，支持单个 View，ListView，GridView<br>项目地址：<a href="https://github.com/daimajia/AndroidSwipeLayout" target="_blank" rel="noopener">https://github.com/daimajia/AndroidSwipeLayout</a><br>Demo 地址：<a href="https://github.com/daimajia/AndroidSwipeLayout/releases/download/v1.0.0/AndroidSwipeLayout-Demo-1.0.1-snapshot.apk" target="_blank" rel="noopener">Download Demo</a><br>效果图：<img src="http://ww2.sinaimg.cn/mw690/610dc034jw1ejoplapwtqg208n0e74dx.gif" alt="Renderings">  </p>
</li>
<li><p>DynamicCardLayout<br>在 Android 中实现的类似 Windows8 的瓷片布局<br>项目地址：<a href="https://github.com/dodola/DynamicCardLayout" target="_blank" rel="noopener">https://github.com/dodola/DynamicCardLayout</a><br>效果图：<img src="https://github.com/dodola/DynamicCardLayout/blob/master/pic1.png?raw=true" alt="Renderings">  </p>
</li>
<li><p>Emoticons-Keyboard<br>带表情情符号的自定义键盘<br>项目地址：<a href="https://github.com/chiragjain/Emoticons-Keyboard" target="_blank" rel="noopener">https://github.com/chiragjain/Emoticons-Keyboard</a><br>效果图：<img src="https://github.com/chiragjain/Emoticons-Keyboard/raw/master/s2.png" alt="Renderings">  </p>
</li>
<li><p>Android Typeface Helper<br>可以帮你轻松实现自定义字体的库<br>项目地址：<a href="https://github.com/norbsoft/android-typeface-helper" target="_blank" rel="noopener">https://github.com/norbsoft/android-typeface-helper</a><br>效果图：<img src="https://camo.githubusercontent.com/b8e7d4f4ab84ff96a3919ea264e2a83aca46e04e/68747470733a2f2f7261772e6769746875622e636f6d2f6e6f7262736f66742f616e64726f69642d74797065666163652d68656c7065722f6d61737465722f726561646d655f73637265656e2e706e67" alt="Renderings">  </p>
</li>
<li><p>Android-Anim-Playground<br>几个动画效果，其中第二个基于 android-svg 的绘制效果非常好<br>项目地址：<a href="https://github.com/Tibolte/Android-Anim-Playground" target="_blank" rel="noopener">https://github.com/Tibolte/Android-Anim-Playground</a><br>效果图：<img src="https://raw.githubusercontent.com/Tibolte/Android-Anim-Playground/master/androiddemosvg.gif" alt="Renderings">  </p>
</li>
<li><p>AlertView<br>仿iOS的AlertViewController 几乎完美还原iOS 的 AlertViewController ，同时支持Alert和ActionSheet模式，每一个细节都是精雕细琢，并把api封装成懒到极致模式，一行代码就可以进行弹窗.<br>项目地址：<a href="https://github.com/saiwu-bigkoo/Android-AlertView" target="_blank" rel="noopener">https://github.com/saiwu-bigkoo/Android-AlertView</a><br>效果图：<img src="https://github.com/saiwu-bigkoo/Android-AlertView/blob/master/preview/alertviewdemo.gif" alt="Renderings">  </p>
</li>
<li><p>NiftyDialogEffects<br>支持自定义飞入动画样式的 Dialog<br>项目地址：<a href="https://github.com/sd6352051/NiftyDialogEffects" target="_blank" rel="noopener">https://github.com/sd6352051/NiftyDialogEffects</a><br>效果图：<img src="https://camo.githubusercontent.com/456687ac516bb07f1076928d635bfddf6b90d5ec/687474703a2f2f696d67302e70682e3132362e6e65742f69433436653162586b55316631724966555a6f3939773d3d2f363539373632303632313938343031393430382e676966" alt="Renderings"><br>在线演示：<a href="http://tympanus.net/Development/ModalWindowEffects/" target="_blank" rel="noopener">http://tympanus.net/Development/ModalWindowEffects/</a>  </p>
</li>
<li><p>PostOffice<br>创建 Holo 及 Material Design 样式的 Dialog<br>项目地址：<a href="https://github.com/r0adkll/PostOffice" target="_blank" rel="noopener">https://github.com/r0adkll/PostOffice</a><br>效果图：<img src="https://github.com/r0adkll/PostOffice/raw/master/images/po_2.png" alt="Renderings">  </p>
</li>
<li><p>Swipecards<br>类似 Tinder 的卡片效果，可以加载图片并动画效果展示，向左滑动表示喜欢，向右表示不喜欢，根据 Kikoso’s Swipeable-Cards 改造而来<br>项目地址：<a href="https://github.com/Diolor/Swipecards" target="_blank" rel="noopener">https://github.com/Diolor/Swipecards</a>  </p>
</li>
<li><p>SeekArc<br>圆形的 SeekBar<br>项目地址：<a href="https://github.com/TriggerTrap/SeekArc" target="_blank" rel="noopener">https://github.com/TriggerTrap/SeekArc</a><br>效果图：<img src="https://camo.githubusercontent.com/6a5091cb39a50d4c49b8d2f08684cb260db55aa7/68747470733a2f2f7261772e6769746875622e636f6d2f6e65696c643030312f5365656b4172632f6d61737465722f7261772f6172635f7377656570732e706e67" alt="Renderings">  </p>
</li>
<li><p>BlurDialogFragment<br>显示  DialogFragment 时背景模糊效果<br>项目地址：<a href="https://github.com/tvbarthel/BlurDialogFragment" target="_blank" rel="noopener">https://github.com/tvbarthel/BlurDialogFragment</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=fr.tvbarthel.lib.blurdialogfragment.sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=fr.tvbarthel.lib.blurdialogfragment.sample</a>  </p>
</li>
<li><p>range-seek-bar<br>随机值选取的 SeekBar<br>项目地址：<a href="https://github.com/yahoo/android-range-seek-bar" target="_blank" rel="noopener">https://github.com/yahoo/android-range-seek-bar</a><br>效果图：<img src="https://github.com/yahoo/android-range-seek-bar/raw/master/demo_screenshot.png" alt="Renderings">  </p>
</li>
<li><p>MaterialRangeBar<br>可以选择一个范围内的值而不是单个值的 SeekBar，RangeBar 的 Material Design 风格适配<br>项目地址：<a href="https://github.com/oli107/material-range-bar" target="_blank" rel="noopener">https://github.com/oli107/material-range-bar</a><br>效果图：<img src="https://github.com/oli107/material-range-bar/raw/master/Screenshots/pin%20expand.gif" alt="Renderings">  </p>
</li>
<li><p>MaterialList<br>Material Design 风格的 CardView<br>项目地址：<a href="https://github.com/dexafree/MaterialList" target="_blank" rel="noopener">https://github.com/dexafree/MaterialList</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.dexafree.materiallistviewexample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.dexafree.materiallistviewexample</a><br>效果图：<img src="https://camo.githubusercontent.com/b71bb064807465b7c9132d7f6072e2064f01fb85/687474703a2f2f692e696d6775722e636f6d2f454e78554741772e706e67" alt="Renderings">  </p>
</li>
<li><p>road-trip<br>设置 path 的各种动画效果，以及如何实现复杂路径动画，类似于 ios 中的指纹注册界面的指纹动画效果<br>项目地址：<a href="https://github.com/romainguy/road-trip" target="_blank" rel="noopener">https://github.com/romainguy/road-trip</a><br>效果图：<img src="https://github.com/zhangxin1989/RoadTrip/raw/master/screenshot/Road-Trip-200.gif" alt="Renderings">  </p>
</li>
<li><p>dialogplus<br>一个简单的 Android 对话框，支持不同的弹出模式<br>项目地址：<a href="https://github.com/orhanobut/dialogplus" target="_blank" rel="noopener">https://github.com/orhanobut/dialogplus</a><br>效果图：<img src="https://github.com/nr4bt/dialogplus/raw/master/art/dialogplus.gif" alt="Renderings">  </p>
</li>
<li><p>FlowLayout<br>一个简单的流式布局，用法类似 LinearLayout，但是能够让子元素根据宽度自动换行<br>项目地址：<a href="https://github.com/LyndonChin/AndroidFlowLayout" target="_blank" rel="noopener">FLowLayout</a><br>效果图：<img src="http://img02.taobaocdn.com/imgextra/i2/160310864/TB2MH8.bVXXXXa3XXXXXXXXXXXX_!!160310864.png" alt="Renderings">  </p>
</li>
<li><p>CircleSeekbar<br>一个环形Seekbar组件,支持叠加复合使用<br>项目地址：<a href="https://github.com/feeeei/CircleSeekbar" target="_blank" rel="noopener">CircleSeekbar</a><br>效果图：<br><img src="https://github.com/feeeei/CircleSeekbar/blob/master/gifs/withtext.gif" alt="Renderings"><br><img src="https://github.com/feeeei/CircleSeekbar/raw/master/gifs/union.gif" alt="Renderings"></p>
</li>
<li><p>FinestWebView<br>美麗的和可定制的Android的活動，顯示在一個應用程序的網頁。<br>项目地址: <a href="https://github.com/TheFinestArtist/FinestWebView-Android" target="_blank" rel="noopener">https://github.com/TheFinestArtist/FinestWebView-Android</a><br>Sample 地址: <a href="https://play.google.com/store/apps/details?id=com.thefinestartist.finestwebview.sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.thefinestartist.finestwebview.sample</a><br>效果图: <img src="https://github.com/TheFinestArtist/FinestWebView-Android/blob/master/art/screenshots.png?raw=true" alt="Renderings"></p>
</li>
<li><p>YouTubePlayerActivity<br>只需通過一個URL來在新的活動播放YouTube視頻。它支持屏幕方向，媒體音量控制等。<br>项目地址: <a href="https://github.com/TheFinestArtist/YouTubePlayerActivity" target="_blank" rel="noopener">https://github.com/TheFinestArtist/YouTubePlayerActivity</a><br>Sample 地址: <a href="https://play.google.com/store/apps/details?id=com.thefinestartist.ytpa.sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.thefinestartist.ytpa.sample</a><br>效果图: <img src="https://github.com/thefinestartist/YouTubePlayerActivity/blob/master/art/preview.gif" alt="Renderings">  </p>
</li>
<li><p>material-camera<br>material风格的camera。能使camera使用起来更简单的库。<br>项目地址：<a href="https://github.com/afollestad/material-camera" target="_blank" rel="noopener">https://github.com/afollestad/material-camera</a><br>效果图：<br><img src="https://raw.githubusercontent.com/afollestad/material-camera/master/art/deviceart.png" alt="Renderings">    </p>
</li>
<li><p>material-dialogs<br>各种material风格的dialog。<br>漂亮的的、易于使用的和可定制的Dialog API，你能够使用Material designed风格的Dialog到API 8。<br>项目地址：<a href="https://github.com/afollestad/material-dialogs" target="_blank" rel="noopener">https://github.com/afollestad/material-dialogs</a><br>Sample地址：<a href="https://github.com/afollestad/material-dialogs/blob/master/sample/sample.apk" target="_blank" rel="noopener">https://github.com/afollestad/material-dialogs/blob/master/sample/sample.apk</a><br>效果图：<br><img src="https://raw.githubusercontent.com/afollestad/material-dialogs/master/art/mddemoshowcase.png" alt="Renderings">    </p>
</li>
<li><p>NotifyUtil<br>最常见的通知样式库<br>项目地址:<a href="https://github.com/wenmingvs/NotifyUtil" target="_blank" rel="noopener">https://github.com/wenmingvs/NotifyUtil</a><br>demo地址：<a href="https://github.com/wenmingvs/NotifyUtil#notifydemo" target="_blank" rel="noopener">https://github.com/wenmingvs/NotifyUtil#notifydemo</a>  </p>
</li>
<li><p>CanPhotos<br>使用fresco选取多张图片并可预览图片<br>项目地址：<a href="https://github.com/canyinghao/CanPhotos" target="_blank" rel="noopener">https://github.com/canyinghao/CanPhotos</a><br>效果图：<br><img src="https://raw.githubusercontent.com/canyinghao/CanPhotos/master/pic/CanPhotos.gif" alt="Renderings"> </p>
</li>
<li><p>CanDialog<br>仿照系统Dialog所写，继承于FrameLayout，添加一些动画，一些显示类型。<br>项目地址：<a href="https://github.com/canyinghao/CanDialog" target="_blank" rel="noopener">https://github.com/canyinghao/CanDialog</a><br>效果图：<br><img src="https://raw.githubusercontent.com/canyinghao/CanDialog/master/pic/CanDialog.gif" alt="Renderings"> </p>
</li>
<li><p>WindRoseDiagramView<br>一个风力玫瑰图的 View 组件，项目地址：<img src="https://github.com/timqi/WindRoseDiagramView/" alt="https://github.com/timqi/WindRoseDiagramView/"><br><img src="https://github.com/timqi/WindRoseDiagramView/raw/master/art/WindRoseDiagram.gif" alt="效果图"> </p>
</li>
<li><p>MaterialRatingBar<br>与 Google 系应用设计相同、支持拉伸、修正原生实现诸多问题的星级评分条。可直接替换 RatingBar。<br>项目地址：<a href="https://github.com/DreaminginCodeZH/MaterialRatingBar" target="_blank" rel="noopener">https://github.com/DreaminginCodeZH/MaterialRatingBar</a><br>Demo 地址：<a href="https://github.com/DreaminginCodeZH/MaterialRatingBar/releases/download/v1.0.2/sample-release.apk" target="_blank" rel="noopener">https://github.com/DreaminginCodeZH/MaterialRatingBar/releases/download/v1.0.2/sample-release.apk</a><br><img src="https://github.com/DreaminginCodeZH/MaterialRatingBar/raw/master/screenshot/sample_app.jpg" alt="效果图">  </p>
</li>
<li><p>Spotlight<br>Android图书馆点亮项目的教程或漫步等…<br>項目地址：<a href="https://github.com/TakuSemba/Spotlight" target="_blank" rel="noopener">https://github.com/TakuSemba/Spotlight</a></p>
</li>
</ol>
<p>效果圖: <img src="https://raw.githubusercontent.com/takusemba/spotlight/master/arts/customTarget.gif" alt="Renderings">  </p>
<ol>
<li>SpeedView<br>Android的动态车速表和量规。 惊人，强大，多形 :zap:<br>項目地址: <a href="https://github.com/anastr/SpeedView" target="_blank" rel="noopener">https://github.com/anastr/SpeedView</a><br>效果圖:<br><img src="https://raw.githubusercontent.com/anastr/SpeedView/master/images/AwesomeSpeedometer.gif" alt="Renderings">  </li>
</ol>
<h2 id="第二部分-工具库"><a href="#第二部分-工具库" class="headerlink" title="第二部分 工具库"></a>第二部分 工具库</h2><p>主要包括那些不错的开发库，包括依赖注入框架、图片缓存、网络请求、数据库 ORM 建模、Android 公共库、Android 高版本向低版本兼容、多媒体相关及其他。  </p>
<h4 id="一、依赖注入-DI"><a href="#一、依赖注入-DI" class="headerlink" title="一、依赖注入 DI"></a>一、依赖注入 DI</h4><p>通过依赖注入减少 View、服务、资源简化初始化，事件绑定等重复繁琐工作  </p>
<ol>
<li><p>AndroidAnnotations(Code Diet)<br>android 快速开发框架<br>项目地址：<a href="https://github.com/excilys/androidannotations" target="_blank" rel="noopener">https://github.com/excilys/androidannotations</a><br>文档介绍：<a href="https://github.com/excilys/androidannotations/wiki" target="_blank" rel="noopener">https://github.com/excilys/androidannotations/wiki</a><br>官网网址：<a href="http://androidannotations.org/" target="_blank" rel="noopener">http://androidannotations.org/</a><br>特点：(1) 依赖注入：包括 view，extras，系统服务，资源等等<br>(2) 简单的线程模型，通过 annotation 表示方法运行在 ui 线程还是后台线程<br>(3) 事件绑定：通过 annotation 表示 view 的响应事件，不用在写内部类<br>(4) REST 客户端：定义客户端接口，自动生成 REST 请求的实现<br>(5) 没有你想象的复杂：AndroidAnnotations 只是在在编译时生成相应子类<br>(6) 不影响应用性能：仅 50kb，在编译时完成，不会对运行时有性能影响。<br>其他：与 roboguice 的比较：roboguice 通过运行时读取 annotations 进行反射，所以可能影响应用性能，而 AndroidAnnotations 在编译时生成子类，所以对性能没有影响  </p>
</li>
<li><p>roboguice<br>帮你处理了很多代码异常，利用 annotation 使得更少的代码完成项目<br>项目地址：<a href="https://github.com/roboguice/roboguice" target="_blank" rel="noopener">https://github.com/roboguice/roboguice</a><br>文档介绍：<a href="https://github.com/roboguice/roboguice/wiki" target="_blank" rel="noopener">https://github.com/roboguice/roboguice/wiki</a>  </p>
</li>
<li><p>butterknife<br>利用 annotation 帮你快速完成 View 的初始化，减少代码<br>项目地址：<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">https://github.com/JakeWharton/butterknife</a><br>文档介绍：<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">http://jakewharton.github.io/butterknife/</a>  </p>
</li>
<li><p>Dagger<br>依赖注入，适用于 Android 和 Java<br>项目地址：<a href="https://github.com/square/dagger" target="_blank" rel="noopener">https://github.com/square/dagger</a><br>原理剖析文档：[Dagger](<a href="http://a.codekk.com/detail/Android/扔物线/Dagger" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/扔物线/Dagger</a> 源码解析)<br>文档介绍：<a href="http://square.github.io/dagger/" target="_blank" rel="noopener">http://square.github.io/dagger/</a>  </p>
</li>
<li><p>AutoParcel<br>注解自动生成Parcelable实现代码的库<br>项目地址：<a href="https://github.com/frankiesardo/auto-parcel" target="_blank" rel="noopener">https://github.com/frankiesardo/auto-parcel</a><br>这篇文章详细介绍了它的使用方法：<a href="https://passy.svbtle.com/simpler-android-apis-with-autoparcel" target="_blank" rel="noopener">AutoParcel</a><br>作者认为使用AutoParcel的好处是，可以简化构造函数，方便IDE代码自动完成，方便测试，前向兼容，生成不可变的对象。<br>文档介绍：<a href="https://github.com/frankiesardo/auto-parcel" target="_blank" rel="noopener">https://github.com/frankiesardo/auto-parcel</a></p>
</li>
</ol>
<h4 id="二、图片缓存"><a href="#二、图片缓存" class="headerlink" title="二、图片缓存"></a>二、图片缓存</h4><ol>
<li><p>Android-Universal-Image-Loader<br>图片缓存，目前使用最广泛的图片缓存，支持主流图片缓存的绝大多数特性。<br>项目地址：<a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="noopener">https://github.com/nostra13/Android-Universal-Image-Loader</a><br>原理剖析文档：[Android-Universal-Image-Loader](<a href="http://a.codekk.com/detail/Android/huxian99/Android" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/huxian99/Android</a> Universal Image Loader 源码分析)<br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/universal-imageloader-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/universal-imageloader-demo.apk?raw=true</a><br>文档介绍：<a href="http://www.intexsoft.com/blog/item/74-universal-image-loader-part-3.html" target="_blank" rel="noopener">http://www.intexsoft.com/blog/item/74-universal-image-loader-part-3.html</a>  </p>
</li>
<li><p>picasso<br>square 开源的图片缓存<br>项目地址：<a href="https://github.com/square/picasso" target="_blank" rel="noopener">https://github.com/square/picasso</a><br>文档介绍：<a href="http://square.github.io/picasso/" target="_blank" rel="noopener">http://square.github.io/picasso/</a><br>特点：(1)可以自动检测 adapter 的重用并取消之前的下载<br>(2)图片变换<br>(3)可以加载本地资源<br>(4)可以设置占位资源<br>(5)支持 debug 模式  </p>
</li>
<li><p>Cube ImageLoader<br>阿里巴巴一淘使用的图片加载，综合了 Android-Universal-Image-Loader 和 square 等组件优点，简单易用，良好的中文文档支持<br>项目地址：<a href="https://github.com/etao-open-source/cube-sdk" target="_blank" rel="noopener">https://github.com/etao-open-source/cube-sdk</a><br>Demo 地址：<a href="https://github.com/liaohuqiu/cube-sdk/raw/master/cube-sdk-sample.apk" target="_blank" rel="noopener">https://github.com/liaohuqiu/cube-sdk/raw/master/cube-sdk-sample.apk</a><br>文档介绍：<a href="http://cube-sdk.liaohuqiu.net/" target="_blank" rel="noopener">http://cube-sdk.liaohuqiu.net/</a><br>效果图：<img src="https://raw.githubusercontent.com/etao-open-source/cube-sdk/dev/screen-shot.png" alt="Renderings">  </p>
</li>
<li><p>fresco<br>一款强大的图片缓存工具，由 Facebook 开发<br>项目地址：<a href="https://github.com/facebook/fresco" target="_blank" rel="noopener">https://github.com/facebook/fresco</a><br>文档介绍：<a href="http://frescolib.org/" target="_blank" rel="noopener">http://frescolib.org/</a><br>特点：(1) 两个内存缓存加上磁盘缓存构成了三级缓存<br>(2) 支持流式，可以类似网页上模糊渐进式显示图片<br>(3) 对多帧动画图片支持更好，如 Gif、WebP<br>(4) 更多样的显示，如圆角、进度条、点击重试、自定义对焦点<br>(5) 更多样的加载，如支持 EXIF、全面支持 WebP<br>(6) 支持 Android 2.3+  </p>
</li>
<li><p>Glide<br>Glide 是一个 android 平台上的快速和高效的开源的多媒体资源管理库,提供 多媒体文件的压缩,内存和磁盘缓存, 资源池的接口。<br>它可以最大性能地在 Android 设备上读取、解码、显示图片和视频。Glide 可以将远程的图片、视频、动画图片等缓存在设备本地便于提高用户浏览图片的流畅体验。<br>项目地址：<a href="https://github.com/bumptech/glide" target="_blank" rel="noopener">https://github.com/bumptech/glide</a><br>特点：<br>(1) GIF 动画的解码<br>(2) 本地视频剧照的解码<br>(3) 支持缩略图<br>(4) Activity 生命周期的集成<br>(5) 转码的支持<br>(6) 动画的支持<br>(7) OkHttp 和 Volley 的支持  </p>
</li>
</ol>
<h4 id="三、网络请求"><a href="#三、网络请求" class="headerlink" title="三、网络请求"></a>三、网络请求</h4><ol>
<li><p>Volley<br>Google 提供的网络通信库，使得网络请求更简单、更快速<br>项目地址：<a href="https://android.googlesource.com/platform/frameworks/volley" target="_blank" rel="noopener">https://android.googlesource.com/platform/frameworks/volley</a><br>文档介绍：<a href="http://commondatastorage.googleapis.com/io-2013/presentations/110%20-%20Volley-%20Easy,%20Fast%20Networking%20for%20Android.pdf" target="_blank" rel="noopener">http://commondatastorage.googleapis.com/io-2013/presentations/110%20-%20Volley-%20Easy,%20Fast%20Networking%20for%20Android.pdf</a>  </p>
</li>
<li><p>Asynchronous Http Client for Android<br>Android 异步 Http 请求<br>项目地址：<a href="https://github.com/loopj/android-async-http" target="_blank" rel="noopener">https://github.com/loopj/android-async-http</a><br>文档介绍：<a href="http://loopj.com/android-async-http/" target="_blank" rel="noopener">http://loopj.com/android-async-http/</a><br>特点：(1) 在匿名回调中处理请求结果<br>(2) 在 UI 线程外进行 http 请求<br>(3) 文件断点上传<br>(4) 智能重试<br>(5) 默认 gzip 压缩<br>(6) 支持解析成 Json 格式<br>(7) 可将 Cookies 持久化到 SharedPreferences  </p>
</li>
<li><p>android-query<br>异步加载，更少代码完成 Android 加载<br>项目地址：<a href="https://github.com/androidquery/androidquery" target="_blank" rel="noopener">https://github.com/androidquery/androidquery</a> 或 <a href="https://code.google.com/p/android-query/" target="_blank" rel="noopener">https://code.google.com/p/android-query/</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.androidquery" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.androidquery</a><br>文档介绍：<a href="https://code.google.com/p/android-query/#Why_AQuery" target="_blank" rel="noopener">https://code.google.com/p/android-query/#Why_AQuery</a>?<br>特点：<a href="https://code.google.com/p/android-query/#Why_AQuery" target="_blank" rel="noopener">https://code.google.com/p/android-query/#Why_AQuery</a>?  </p>
</li>
<li><p>Async Http Client<br>Java 异步 Http 请求<br>项目地址：<a href="https://github.com/AsyncHttpClient/async-http-client" target="_blank" rel="noopener">https://github.com/AsyncHttpClient/async-http-client</a><br>文档介绍：<a href="http://sonatype.github.io/async-http-client/" target="_blank" rel="noopener">http://sonatype.github.io/async-http-client/</a>  </p>
</li>
<li><p>Ion<br>支持图片、json、http post 等异步请求<br>项目地址：<a href="https://github.com/koush/ion" target="_blank" rel="noopener">https://github.com/koush/ion</a><br>文档介绍：<a href="https://github.com/koush/ion#more-examples" target="_blank" rel="noopener">https://github.com/koush/ion#more-examples</a>  </p>
</li>
<li><p>Http Request<br>项目地址：<a href="https://github.com/kevinsawicki/http-request" target="_blank" rel="noopener">https://github.com/kevinsawicki/http-request</a><br>文档介绍：<a href="https://github.com/kevinsawicki/http-request#examples" target="_blank" rel="noopener">https://github.com/kevinsawicki/http-request#examples</a>  </p>
</li>
<li><p>okhttp<br>square 开源的 http 工具类<br>项目地址：<a href="https://github.com/square/okhttp" target="_blank" rel="noopener">https://github.com/square/okhttp</a><br>文档介绍：<a href="http://square.github.io/okhttp/" target="_blank" rel="noopener">http://square.github.io/okhttp/</a><br>特点：(1) 支持 SPDY( <a href="http://zh.wikipedia.org/wiki/SPDY" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/SPDY</a> )协议。SPDY 协议是 Google 开发的基于传输控制协议的应用层协议，通过压缩，多路复用(一个 TCP 链接传送网页和图片等资源)和优先级来缩短加载时间。<br>(2) 如果 SPDY 不可用，利用连接池减少请求延迟<br>(3) Gzip 压缩<br>(4) Response 缓存减少不必要的请求  </p>
</li>
<li><p>Retrofit<br>RESTFUL API 设计<br>项目地址：<a href="https://github.com/square/retrofit" target="_blank" rel="noopener">https://github.com/square/retrofit</a><br>文档介绍：<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">http://square.github.io/retrofit/</a>  </p>
</li>
<li><p>RoboSpice<br>Android 异步网络请求工具，支持缓存、REST 等等<br>项目地址：<a href="https://github.com/stephanenicolas/robospice" target="_blank" rel="noopener">https://github.com/stephanenicolas/robospice</a><br>Demo 地址：<a href="https://github.com/stephanenicolas/RoboDemo/downloads" target="_blank" rel="noopener">https://github.com/stephanenicolas/RoboDemo/downloads</a>  </p>
</li>
<li><p>TwistVolley<br>TwistVolley 是对 Volley 的一个封装库。提供类似 Picasso 一样的串联式 API。使得使用 Volley 更加方便。<br>项目地址：<a href="https://github.com/TwistedEquations/TwistVolley" target="_blank" rel="noopener">https://github.com/TwistedEquations/TwistVolley</a>  </p>
</li>
<li><p>OkHttpFinal<br>一个对OkHttp封装的简单易用型HTTP请求和文件下载管理框架<br>项目地址：<a href="https://github.com/pengjianbo/OkHttpFinal" target="_blank" rel="noopener">https://github.com/pengjianbo/OkHttpFinal</a><br>Demo 地址：<a href="https://github.com/pengjianbo/OkHttpFinal" target="_blank" rel="noopener">https://github.com/pengjianbo/OkHttpFinal</a>  </p>
</li>
</ol>
<h4 id="四、数据库-orm-工具包"><a href="#四、数据库-orm-工具包" class="headerlink" title="四、数据库 orm 工具包"></a>四、数据库 orm 工具包</h4><p>orm 的 db 工具类，简化建表、查询、更新、插入、事务、索引的操作 </p>
<ol>
<li><p>greenDAO<br>Android Sqlite orm 的 db 工具类<br>项目地址：<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">https://github.com/greenrobot/greenDAO</a><br>文档介绍：<a href="http://greendao-orm.com/documentation/" target="_blank" rel="noopener">http://greendao-orm.com/documentation/</a><br>官网网址：<a href="http://greendao-orm.com/" target="_blank" rel="noopener">http://greendao-orm.com/</a><br>特点：(1) 性能佳<br>(2) 简单易用的 API<br>(3) 内存小好小<br>(4) 库大小小  </p>
</li>
<li><p>GreenDaoUpgradeHelper<br>greenDAO的数据库升级帮助类，只需一行代码解决数据库升级<br>项目地址：<a href="https://github.com/yuweiguocn/GreenDaoUpgradeHelper" target="_blank" rel="noopener">https://github.com/yuweiguocn/GreenDaoUpgradeHelper</a></p>
</li>
</ol>
<ol>
<li><p>ActiveAndroid<br>Android Sqlite orm 的 db 工具类<br>项目地址：<a href="https://github.com/pardom/ActiveAndroid" target="_blank" rel="noopener">https://github.com/pardom/ActiveAndroid</a><br>文档介绍：<a href="https://github.com/pardom/ActiveAndroid/wiki/_pages" target="_blank" rel="noopener">https://github.com/pardom/ActiveAndroid/wiki/_pages</a>  </p>
</li>
<li><p>Sprinkles<br>Android Sqlite orm 的 db 工具类，比较显著的特点就是配合 <a href="https://github.com/square/retrofit" target="_blank" rel="noopener">https://github.com/square/retrofit</a> 能保存从服务器获取的数据<br>项目地址：<a href="https://github.com/emilsjolander/sprinkles" target="_blank" rel="noopener">https://github.com/emilsjolander/sprinkles</a><br>文档介绍：<a href="http://emilsjolander.github.io/blog/2013/12/18/android-with-sprinkles/" target="_blank" rel="noopener">http://emilsjolander.github.io/blog/2013/12/18/android-with-sprinkles/</a>  </p>
</li>
<li><p>Realm<br>移动端的数据库，适用于 Phone、Tablet、Wearable，支持 ORM，线程安全、支持连表及数据库加密，比 SQLite 性能更好<br>项目地址：<a href="https://github.com/realm/realm-java" target="_blank" rel="noopener">https://github.com/realm/realm-java</a><br>文档介绍：<a href="http://realm.io/docs/java/0.72.0/" target="_blank" rel="noopener">http://realm.io/docs/java/0.72.0/</a>  </p>
</li>
<li><p>ormlite-android<br>项目地址：<a href="https://github.com/j256/ormlite-android" target="_blank" rel="noopener">https://github.com/j256/ormlite-android</a><br>文档介绍：<a href="http://ormlite.com/sqlite_java_android_orm.shtml" target="_blank" rel="noopener">http://ormlite.com/sqlite_java_android_orm.shtml</a>  </p>
</li>
<li><p>Schematic<br>根据 SQLite 生成 ContentProvider<br>项目地址：<a href="https://github.com/SimonVT/schematic" target="_blank" rel="noopener">https://github.com/SimonVT/schematic</a>  </p>
</li>
<li><p>DBFlow<br>Android SQLite ORM 工具库。综合了 Active Android, Schematic, Ollie,Sprinkles 等库的优点；通过注解实现，性能好；能生成 ContentProvider。<br>项目地址：<a href="https://github.com/Raizlabs/DBFlow" target="_blank" rel="noopener">https://github.com/Raizlabs/DBFlow</a><br>文档介绍：<a href="https://github.com/Raizlabs/DBFlow#usage-docs" target="_blank" rel="noopener">https://github.com/Raizlabs/DBFlow#usage-docs</a>  </p>
</li>
<li><p>SnappyDB<br>SnappyDB是一个key-value数据库，非常流行的NoSQL数据库。<br>项目地址：<a href="https://github.com/nhachicha/SnappyDB" target="_blank" rel="noopener">https://github.com/nhachicha/SnappyDB</a><br>演示Demo：<a href="https://play.google.com/store/apps/details?id=com.snappydb.snippets.app" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.snappydb.snippets.app</a><br>性能对比图：<br><img src="https://camo.githubusercontent.com/0f6193a1f84aa8a77d07ac18d3566b87bc89999b/687474703a2f2f736e6170707964622e636f6d2f696d672f62656e63686d61726b5f73716c6974655f776974685f7472616e73616374696f6e2e706e67" alt="Renderings"></p>
</li>
</ol>
<h4 id="五、Android-公共库"><a href="#五、Android-公共库" class="headerlink" title="五、Android 公共库"></a>五、Android 公共库</h4><ol>
<li><p>Guava<br>Google 的基于 java1.6 的类库集合的扩展项目，包括 collections, caching, primitives support, concurrency libraries, common annotations, string processing, I/O 等等. 这些高质量的 API 可以使你的 JAVa 代码更加优雅，更加简洁<br>项目地址：<a href="https://code.google.com/p/guava-libraries/" target="_blank" rel="noopener">https://code.google.com/p/guava-libraries/</a><br>文档介绍：<a href="https://code.google.com/p/guava-libraries/wiki/GuavaExplained" target="_blank" rel="noopener">https://code.google.com/p/guava-libraries/wiki/GuavaExplained</a>  </p>
</li>
<li><p>AndroidCommon<br>Android 公共库<br>项目地址：<a href="https://github.com/Trinea/AndroidCommon" target="_blank" rel="noopener">https://github.com/Trinea/AndroidCommon</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=cn.trinea.android.demo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=cn.trinea.android.demo</a><br>文档介绍：<a href="http://www.trinea.cn/android/android-common-lib/" target="_blank" rel="noopener">http://www.trinea.cn/android/android-common-lib/</a><br>包括：a. ImageCache 图片缓存，包含内存和 Sdcard 缓存<br><a href="http://www.trinea.cn/android/android-imagecache/" target="_blank" rel="noopener">http://www.trinea.cn/android/android-imagecache/</a><br>特点：(1)支持预取新图片，支持等待队列<br>(2)包含二级缓存，可自定义文件名保存规则<br>(3)可选择多种缓存算法(FIFO、LIFO、LRU、MRU、LFU、MFU 等 13 种)或自定义缓存算法<br>(4)可方便的保存及初始化恢复数据<br>(5)支持不同类型网络处理<br>(6)可根据系统配置初始化缓存等  </p>
</li>
<li><p>HttpCache Http 缓存<br>文档介绍：<a href="http://www.trinea.cn/android/android-http-cache" target="_blank" rel="noopener">http://www.trinea.cn/android/android-http-cache</a><br>特点是：(1) 根据 cache-control、expires 缓存 http 请求<br>(2) 支持同步、异步 Http 请求<br>(3) 在匿名回调中处理请求结果<br>(4) 在 UI 线程外进行 http 请求<br>(5) 默认 gzip 压缩<br>(2) 公共 View(下拉及底部加载更多 ListView、底部加载更多 ScrollView、滑动一页 Gallery)<br>(3) Android 常用工具类(网络、下载、Android 资源操作、shell、文件、Json、随机数、Collection 等等)  </p>
</li>
<li><p>DropDownListView 下拉刷新及滑动到底部加载更多 ListView<br>文档介绍：<a href="http://www.trinea.cn/android/dropdown-to-refresh-and-bottom-load-more-listview/" target="_blank" rel="noopener">http://www.trinea.cn/android/dropdown-to-refresh-and-bottom-load-more-listview/</a>  </p>
</li>
<li><p>shipfaster<br>整合了 Dagger Otto Retrofit Robolectric Picasso OkHttp，方便快速开发<br>项目地址：<a href="https://github.com/pyricau/shipfaster" target="_blank" rel="noopener">https://github.com/pyricau/shipfaster</a>  </p>
</li>
<li><p>CleanAndroidCode<br>整合了 Dagger Otto AndroidAnnotations，方便快速开发<br>项目地址：<a href="https://github.com/pyricau/CleanAndroidCode" target="_blank" rel="noopener">https://github.com/pyricau/CleanAndroidCode</a>  </p>
</li>
<li><p>xUtils<br>基于 Afinal，包含 DbUtils、ViewUtils、HttpUtils、BitmapUtils 四大模块，可用于快速开发<br>项目地址：<a href="https://github.com/wyouflf/xUtils" target="_blank" rel="noopener">https://github.com/wyouflf/xUtils</a><br>原理剖析文档：[xUtils](<a href="http://a.codekk.com/detail/Android/Caij/xUtils" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/Caij/xUtils</a> 源码解析)  </p>
</li>
<li><p>Afinal<br>Afinal 是一个 android 的 ioc，orm 框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过 finalActivity，我们可以通过注解的方式进行绑定 ui 和事件。通过 finalBitmap，我们可以方便的加载 bitmap 图片，而无需考虑 oom 等问题。通过 finalDB 模块，我们一行代码就可以对 android 的 sqlite 数据库进行增删改查。通过 FinalHttp 模块，我们可以以 ajax 形式请求 http 数据<br>项目地址：<a href="https://github.com/yangfuhai/afinal" target="_blank" rel="noopener">https://github.com/yangfuhai/afinal</a><br>官网网址：<a href="http://www.afinal.org" target="_blank" rel="noopener">http://www.afinal.org</a>  </p>
</li>
<li><p>UltimateAndroid<br>UltimateAndroid 是一个快速开发 Android 应用的框架，框架目前主要包含的功能有 View Injection,ORM,异步网络请求和图片加载，自动化脚本测试,磁盘 LRU 等功能.同时提供了类似于 TripleDes、Webview 快速设置、Md5 处理、String 处理,Https 处理等常用工具类，还有超过 100 多种 UI 控件效果。<br>项目地址：<a href="https://github.com/cymcsg/UltimateAndroid" target="_blank" rel="noopener">https://github.com/cymcsg/UltimateAndroid</a><br>官网网址：<a href="http://blog.marshalchen.com/UltimateAndroid/" target="_blank" rel="noopener">http://blog.marshalchen.com/UltimateAndroid/</a>  </p>
</li>
<li><p>SAF<br>SAF(Simple Android Framework)是一个简单的 android 框架，它为开发 Android app 提供了基础性组件。<br>项目地址：<a href="https://github.com/fengzhizi715/SAF" target="_blank" rel="noopener">https://github.com/fengzhizi715/SAF</a><br>官网网址：<a href="http://www.salesuite.cn/" target="_blank" rel="noopener">http://www.salesuite.cn/</a><br>包括：(1)Event Bus(事件总线)<br>(2) Rest Client(http 的框架)<br>(3) Image Cache(图片缓存)<br>(4) Dependency Injection(依赖注入)<br>(5) Sqlite ORM(sqlite 的 orm)<br>(6) Router(Activity、Fragment 的 Router)<br>(7) Utils(各种常用的工具类)  </p>
</li>
<li><p>Barber<br>Custom View 神器。通过简单的注解帮助你大大减少 Custom View 中的代码量。由于和 ButterKnife 一样使用了 Annotation Proccessor ，所以对程序性能没有影响。<br>项目地址：<a href="https://github.com/hzsweers/barber" target="_blank" rel="noopener">https://github.com/hzsweers/barber</a>  </p>
</li>
<li><p>device-year-class<br>A library that analyzes an Android device’s specifications and calculates which year the device would be considered “high end”.(facebook 开发的检测手机主流配置工具)<br>项目地址：<a href="https://github.com/facebook/device-year-class" target="_blank" rel="noopener">https://github.com/facebook/device-year-class</a>  </p>
</li>
<li><p>RxAndroid<br>对RxJava在Android上的扩展，使得Android上也很容易实现reactive components，简化线程操作，从而写出很漂亮的代码。<br>项目地址：<a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="noopener">https://github.com/ReactiveX/RxAndroid</a><br>文档介绍：<a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给Android 开发者的 RxJava 详解</a>  </p>
</li>
<li><p>MultiImageSelector<br>一个本地图片选择器，支持图片的单选和多选，直接返回所选图片的路径。<br>项目地址：<a href="https://github.com/lovetuzitong/MultiImageSelector.git" target="_blank" rel="noopener">https://github.com/lovetuzitong/MultiImageSelector.git</a> </p>
</li>
</ol>
<h4 id="六、Android-高版本向低版本兼容"><a href="#六、Android-高版本向低版本兼容" class="headerlink" title="六、Android 高版本向低版本兼容"></a>六、Android 高版本向低版本兼容</h4><ol>
<li><p>Nine Old Androids<br>将 Android 3.0(Honeycomb)所有动画 API(ObjectAnimator ValueAnimator 等)兼容到 Android1.0<br>项目地址：<a href="https://github.com/JakeWharton/NineOldAndroids" target="_blank" rel="noopener">https://github.com/JakeWharton/NineOldAndroids</a><br>原理剖析文档：[Nine Old Androids](<a href="http://a.codekk.com/detail/Android/Mr.Simple/NineOldAnimations" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/Mr.Simple/NineOldAnimations</a> 源码解析)<br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.jakewharton.nineoldandroids.sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.jakewharton.nineoldandroids.sample</a><br>文档介绍：<a href="http://nineoldandroids.com/" target="_blank" rel="noopener">http://nineoldandroids.com/</a>  </p>
</li>
<li><p>HoloEverywhere<br>将 Android 3.0 的 Holo 主题兼容到 Android2.1++<br>项目地址：<a href="https://github.com/Prototik/HoloEverywhere" target="_blank" rel="noopener">https://github.com/Prototik/HoloEverywhere</a><br>Demo 地址：<a href="https://raw.github.com/Prototik/HoloEverywhere/repo/org/holoeverywhere/demo/2.1.0/demo-2.1.0.apk" target="_blank" rel="noopener">https://raw.github.com/Prototik/HoloEverywhere/repo/org/holoeverywhere/demo/2.1.0/demo-2.1.0.apk</a><br>文档介绍：<a href="http://android-developers.blogspot.com/2012/01/holo-everywhere.html" target="_blank" rel="noopener">http://android-developers.blogspot.com/2012/01/holo-everywhere.html</a>  </p>
</li>
<li><p>SherlockNavigationDrawer<br>将 Android NavigationDrawer 和 ActionbarSherlock 结合，解决 4.0 以下 NavigationDrawer 的适配问题<br>项目地址：<a href="https://github.com/tobykurien/SherlockNavigationDrawer" target="_blank" rel="noopener">https://github.com/tobykurien/SherlockNavigationDrawer</a><br>文档介绍：<a href="http://developer.android.com/training/implementing-navigation/nav-drawer.html" target="_blank" rel="noopener">http://developer.android.com/training/implementing-navigation/nav-drawer.html</a>  </p>
</li>
<li><p>Notifications4EveryWhere<br>将 Android 4.1 的 Notification 兼容到 Android2.2++<br>项目地址：<a href="https://github.com/youxiachai/Notifications4EveryWhere" target="_blank" rel="noopener">https://github.com/youxiachai/Notifications4EveryWhere</a>  </p>
</li>
<li><p>Android Switch Widget Backport<br>将 Android Switch 和 SwitchPreference 的兼容到 Android2.1++<br>项目地址：<a href="https://github.com/BoD/android-switch-backport" target="_blank" rel="noopener">https://github.com/BoD/android-switch-backport</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=org.jraf.android.backport.switchwidget.sample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=org.jraf.android.backport.switchwidget.sample</a><br>文档介绍：<a href="https://github.com/BoD/android-switch-backport#using-the-switch" target="_blank" rel="noopener">https://github.com/BoD/android-switch-backport#using-the-switch</a>  </p>
</li>
<li><p>android-datepicker<br>将 Android 4.0 的 datepicker 兼容到 Android2.2++<br>项目地址：<a href="https://github.com/SimonVT/android-datepicker" target="_blank" rel="noopener">https://github.com/SimonVT/android-datepicker</a>  </p>
</li>
<li><p>Transitions Everywhere<br>Android 4.4 的 Transitions API 兼容到 Android 2.2 以上<br>项目地址：<a href="https://github.com/andkulikov/transitions-everywhere" target="_blank" rel="noopener">https://github.com/andkulikov/transitions-everywhere</a>  </p>
</li>
<li><p>KShareViewActivityManager<br>一个兼容Android 5.0 以下Shared Element Transition （页面间共享元素位移动画）库<br>项目地址：<a href="https://github.com/kot32go/KShareViewActivityManager" target="_blank" rel="noopener">https://github.com/kot32go/KShareViewActivityManager</a><br>效果图：<a href="http://i8.tietuku.com/aa5726b8302ae711.gif" target="_blank" rel="noopener">http://i8.tietuku.com/aa5726b8302ae711.gif</a>  </p>
</li>
</ol>
<h4 id="七、多媒体相关"><a href="#七、多媒体相关" class="headerlink" title="七、多媒体相关"></a>七、多媒体相关</h4><ol>
<li><p>cocos2d-x<br>跨平台的 2d 游戏框架，支持 Android、IOS、Linux、Windows 等众多平台<br>项目地址：<a href="https://github.com/cocos2d/cocos2d-x" target="_blank" rel="noopener">https://github.com/cocos2d/cocos2d-x</a><br>文档介绍：<a href="http://www.cocos2d-x.org/wiki" target="_blank" rel="noopener">http://www.cocos2d-x.org/wiki</a><br>官网网址：<a href="http://www.cocos2d-x.org/" target="_blank" rel="noopener">http://www.cocos2d-x.org/</a>  </p>
</li>
<li><p>JustWeEngine<br>Android的轻量级游戏框架，能大大缩减编写原生游戏的代码量和难度，仍在持续更新中。<br>项目地址: <a href="https://github.com/lfkdsk/JustWeEngine" target="_blank" rel="noopener">https://github.com/lfkdsk/JustWeEngine</a><br>Demo地址: <a href="https://github.com/lfkdsk/EngineDemo" target="_blank" rel="noopener">https://github.com/lfkdsk/EngineDemo</a>  </p>
</li>
<li><p>Vitamio<br>是一款 Android 与 iOS 平台上的全能多媒体开发框架<br>项目地址：<a href="https://github.com/yixia/VitamioBundle" target="_blank" rel="noopener">https://github.com/yixia/VitamioBundle</a><br>网站介绍：<a href="http://www.vitamio.org/docs/" target="_blank" rel="noopener">http://www.vitamio.org/docs/</a><br>特点：(1) 全面支持硬件解码与 GPU 渲染<br>(2) 能够流畅播放 720P 甚至 1080P 高清 MKV，FLV，MP4，MOV，TS，RMVB 等常见格式的视频<br>(3) 在 Android 与 iOS 上跨平台支持 MMS, RTSP, RTMP, HLS(m3u8)等常见的多种视频流媒体协议，包括点播与直播。 </p>
</li>
<li><p>VDPlayerSDK<br>最容易集成的开源播放器组件，支持直播，支持软硬解切换，支持清晰度切换<br>项目地址：<a href="https://github.com/SinaVDDeveloper/" target="_blank" rel="noopener">https://github.com/SinaVDDeveloper/</a><br>Demo 地址：<a href="https://github.com/SinaVDDeveloper/demo" target="_blank" rel="noopener">https://github.com/SinaVDDeveloper/demo</a><br>文档介绍：<a href="https://github.com/SinaVDDeveloper/sinavideo_playersdk" target="_blank" rel="noopener">https://github.com/SinaVDDeveloper/sinavideo_playersdk</a><br>特点：<br>(1) 使用自定义控件方式提供播放器UI，不需要视频相关知识，能编写android应用就能使用<br>(2) 软硬解切换、点播直播支持<br>(3) 解码内核小于4M，更方便集成到非专业视频app中<br>(4) 修正一些vitaimio的问题，比如m3u8可以拖动等等</p>
</li>
<li><p>VideoPlayerManager<br>帮助实现VideoPlayer控制，使得它更容易使用ListView和recyclerview。它还可以跟踪滚动列表中可见的项。当列表中的新项可见域最大时，该库给出了接口来跟踪它。<br>项目地址：<a href="https://github.com/danylovolokh/VideoPlayerManager" target="_blank" rel="noopener">https://github.com/danylovolokh/VideoPlayerManager</a><br>文档介绍：<a href="https://medium.com/@v.danylo/implementing-video-playback-in-a-scrolled-list-listview-recyclerview-d04bc2148429#.hs5n0geqn" target="_blank" rel="noopener">https://medium.com/@v.danylo/implementing-video-playback-in-a-scrolled-list-listview-recyclerview-d04bc2148429#.hs5n0geqn</a>  </p>
</li>
<li><p>UniversalVideoView<br>Android上定义播放器控件,支持自定义控制UI, 全屏播放, 重力感应自动切换横竖屏.<br>项目地址：<a href="https://github.com/linsea/UniversalVideoView" target="_blank" rel="noopener">https://github.com/linsea/UniversalVideoView</a><br><img src="https://github.com/linsea/UniversalVideoView/raw/master/screenshot/screen1.png" alt="Sample Screenshot 1"><br><img src="https://github.com/linsea/UniversalVideoView/raw/master/screenshot/screen2.png" alt="Sample Screenshot 2"></p>
</li>
<li><p>PhotoProcessing<br>利用 ndk 处理图片库，支持 Instafix、Ansel、Testino、XPro、Retro、BW、Sepia、Cyano、Georgia、Sahara、HDR、Rotate(旋转)、Flip(翻转)等各种特效<br>项目地址：<a href="https://github.com/lightbox/PhotoProcessing" target="_blank" rel="noopener">https://github.com/lightbox/PhotoProcessing</a><br>Demo 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/photo-processing.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/photo-processing.apk?raw=true</a>  </p>
</li>
<li><p>Android StackBlur<br>图片模糊效果工具类<br>项目地址：<a href="https://github.com/kikoso/android-stackblur" target="_blank" rel="noopener">https://github.com/kikoso/android-stackblur</a><br>Demo 地址：<a href="https://github.com/kikoso/android-stackblur/blob/master/StackBlurDemo/bin/StackBlurDemo.apk?raw=true" target="_blank" rel="noopener">https://github.com/kikoso/android-stackblur/blob/master/StackBlurDemo/bin/StackBlurDemo.apk?raw=true</a><br>文档介绍：<a href="https://github.com/kikoso/android-stackblur#usage" target="_blank" rel="noopener">https://github.com/kikoso/android-stackblur#usage</a>  </p>
</li>
<li><p>Bitmap Smart Clipping using OpenCV<br>图片智能裁剪保留重要部分显示<br>项目地址：<a href="https://github.com/beartung/tclip-android" target="_blank" rel="noopener">https://github.com/beartung/tclip-android</a><br>利用淘宝的 <a href="http://code.taobao.org/p/tclip/" target="_blank" rel="noopener">http://code.taobao.org/p/tclip/</a> 库完成<br>一淘玩客正在使用的图片裁剪，自动识别图片中的重要区域，并且在图片裁剪时保留重要区域<br>特点：(1). 能进行人脸识别。图片中有人脸，将自动视为人脸区域为重要区域，将不会被裁剪掉<br>(2).自动其它重要区域。如果图片中未识别出人脸，则会根据特征分布计算出重区域  </p>
</li>
<li><p>Cropper<br>图片局部剪切工具，可触摸控制选择区域或旋转<br>项目地址：<a href="https://github.com/edmodo/cropper" target="_blank" rel="noopener">https://github.com/edmodo/cropper</a><br>文档介绍：<a href="https://github.com/edmodo/cropper/wiki" target="_blank" rel="noopener">https://github.com/edmodo/cropper/wiki</a><br>效果图：<img src="https://github-camo.global.ssl.fastly.net/e4fde77bf41d4a60b234b4e268e5cfa8c17d9b6f/687474703a2f2f692e696d6775722e636f6d2f334668735467666c2e6a7067" alt="Renderings">  </p>
</li>
<li><p>uCrop<br>Yalantis 出品的强大的图片裁剪库 ，支持缩放，旋转图片，支持各种比例的裁剪框<br>项目地址：<a href="https://github.com/Yalantis/uCrop" target="_blank" rel="noopener">https://github.com/Yalantis/uCrop</a><br>效果图：<img src="https://camo.githubusercontent.com/8577338af603bb6046e0ff06e2530cbbedd94d85/68747470733a2f2f6431337961637572716a676172612e636c6f756466726f6e742e6e65742f75736572732f3232313933352f73637265656e73686f74732f323437343239352f616e696d6174696f6e2e676966" alt="Renderings"></p>
</li>
<li><p>android-crop<br>图片裁剪 Activity<br>项目地址：<a href="https://github.com/jdamcd/android-crop" target="_blank" rel="noopener">https://github.com/jdamcd/android-crop</a><br>效果图：<img src="https://github.com/jdamcd/android-crop/raw/master/screenshot.png" alt="Renderings">  </p>
</li>
<li><p>TileView<br>可分块显示大图，支持 2D 拖动、双击、双指放大、双指捏合<br>项目地址：<a href="https://github.com/moagrius/TileView" target="_blank" rel="noopener">https://github.com/moagrius/TileView</a><br>Demo 地址：<a href="http://moagrius.github.io/TileView/TileViewDemo.apk" target="_blank" rel="noopener">http://moagrius.github.io/TileView/TileViewDemo.apk</a>  </p>
</li>
<li><p>BlurEffectForAndroidDesign<br>图片模糊效果<br>项目地址：<a href="https://github.com/PomepuyN/BlurEffectForAndroidDesign" target="_blank" rel="noopener">https://github.com/PomepuyN/BlurEffectForAndroidDesign</a>  </p>
</li>
<li><p>android-eye<br>PC 端网页查看同一局域网内的手机摄像头内容，可以用来监控哦<br>项目地址：<a href="https://github.com/Teaonly/android-eye" target="_blank" rel="noopener">https://github.com/Teaonly/android-eye</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=teaonly.droideye" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=teaonly.droideye</a>  </p>
</li>
<li><p>libpng for Android<br>PNG 图片的 jni 库，支持几乎 png 的所有特性<br>项目地址：<a href="https://github.com/julienr/libpng-android" target="_blank" rel="noopener">https://github.com/julienr/libpng-android</a><br>文档介绍：<a href="http://www.libpng.org/pub/png/libpng.html" target="_blank" rel="noopener">http://www.libpng.org/pub/png/libpng.html</a>  </p>
</li>
<li><p>android-gpuimage<br>基于 GPU 的图片滤镜<br>项目地址：<a href="https://github.com/CyberAgent/android-gpuimage" target="_blank" rel="noopener">https://github.com/CyberAgent/android-gpuimage</a>  </p>
</li>
<li><p>AndroidFaceCropper<br>图片脸部自动识别，将识别后的局部图片返回<br>项目地址：<a href="https://github.com/lafosca/AndroidFaceCropper" target="_blank" rel="noopener">https://github.com/lafosca/AndroidFaceCropper</a>  </p>
</li>
<li><p>Android Video Crop<br>利用 TextureView 播放和剪切视频，类似 ImageView.setScaleType<br>项目地址：<a href="https://github.com/dmytrodanylyk/android-video-crop" target="_blank" rel="noopener">https://github.com/dmytrodanylyk/android-video-crop</a><br>Demo 地址：<a href="https://github.com/lafosca/AndroidFaceCropper/releases/download/1.0/FaceCropper-sample-debug-unaligned.apk" target="_blank" rel="noopener">https://github.com/lafosca/AndroidFaceCropper/releases/download/1.0/FaceCropper-sample-debug-unaligned.apk</a>  </p>
</li>
<li><p>svg-android<br>Android Svg 矢量图形支持<br>项目地址：<a href="https://github.com/japgolly/svg-android" target="_blank" rel="noopener">https://github.com/japgolly/svg-android</a> <a href="https://github.com/japgolly/svg-android" target="_blank" rel="noopener">https://github.com/japgolly/svg-android</a>  </p>
</li>
<li><p>Android Visualizer<br>从 Android MediaPlayer 获得音频，然后像 iTunes 及 WinAmp 一样展示音轨<br>项目地址：<a href="https://github.com/felixpalmer/android-visualizer" target="_blank" rel="noopener">https://github.com/felixpalmer/android-visualizer</a>  </p>
</li>
<li><p>ExoPlayer<br>包括仪表板和 SmoothStreaming 自适应回放，缓存持久化和自定义渲染器，方便自定义和扩展，并且可以通过应用商店更新<br>项目地址：<a href="https://github.com/google/ExoPlayer" target="_blank" rel="noopener">https://github.com/google/ExoPlayer</a>  </p>
</li>
<li><p>DanmakuFlameMaster<br>android 上开源弹幕解析绘制引擎项目<br>项目地址：<a href="https://github.com/ctiao/DanmakuFlameMaster" target="_blank" rel="noopener">https://github.com/ctiao/DanmakuFlameMaster</a>  </p>
</li>
<li><p>OpenDanmaku<br>android 上一个轻量级的更简单的开源弹幕控件<br>项目地址：<a href="https://github.com/linsea/OpenDanmaku" target="_blank" rel="noopener">https://github.com/linsea/OpenDanmaku</a>  </p>
</li>
<li><p>K-Sonic<br>一个基于Sonic的变音Demo,可调节Speed,Pitch,Rate.<br>项目地址：<a href="https://github.com/jcodeing/K-Sonic" target="_blank" rel="noopener">https://github.com/jcodeing/K-Sonic</a><br>Demo 地址：<a href="https://raw.githubusercontent.com/jcodeing/K-Sonic/master/K-Sonic-demo.apk" target="_blank" rel="noopener">Download here</a>  </p>
</li>
<li><p>KMedia<br>一个为Android打造的应用级媒体框架, 它可以助你快速搭建媒体应用.<br>内部重新定义Android MediaPlayer API并对其封装, 简化和扩展一些原生API不支持的功能.<br>其中涵盖了, <code>AB播放/循环</code> <code>位置单元/间隔/循环</code> <code>变速播放</code> <code>媒体队列管理</code> <code>媒体服务/绑定</code> <code>音频后台/通知栏控制</code><br><code>媒体按键自定义处理</code> <code>音频焦点管理</code> <code>媒体引擎切换/扩展</code>… 等功能的快速实现.<br>以及, 对视频播放实现方面的封装. 其中将视频视图主要分为: 绘制层 控制组 控制层, 三个部分.<br>从而能够快速并灵活的实现Video相关应用的大部分功能, 包括 <code>视频浮窗/拖动/调整位置大小</code> <code>横竖屏自动切换</code> <code>全屏锁定</code><br><code>手势调整亮度/音量/进度</code> <code>字幕/切换/拖动</code> <code>视频段落/间隔复读</code> <code>视频续集/列表/循环播放</code> <code>动态切换视频控制层</code><br><code>控制层分离</code>… 等功能的快速实现.<br>项目地址：<a href="https://github.com/jcodeing/KMedia" target="_blank" rel="noopener">https://github.com/jcodeing/KMedia</a> →项目模块：<a href="https://github.com/jcodeing/KMedia-Core" target="_blank" rel="noopener">KMedia-Core</a> &amp; <a href="https://github.com/jcodeing/KMedia-Uie" target="_blank" rel="noopener">KMedia-Uie</a> &amp; <a href="https://github.com/jcodeing/KMedia-Exo" target="_blank" rel="noopener">KMedia-Exo</a><br><img src="https://raw.githubusercontent.com/jcodeing/raw/raw/gif/km_d_sr_1_270.gif" alt="Demo-Gif-1">)<img src="https://raw.githubusercontent.com/jcodeing/raw/raw/gif/km_d_ui_270.gif" alt="Demo-Gif-2">)<img src="https://raw.githubusercontent.com/jcodeing/raw/raw/gif/km_d_sr_2_270.gif" alt="Demo-Gif-3"></p>
</li>
</ol>
<h4 id="八、事件总线-订阅者模式"><a href="#八、事件总线-订阅者模式" class="headerlink" title="八、事件总线(订阅者模式)"></a>八、事件总线(订阅者模式)</h4><p>通过发布/订阅事件解耦事件发送和接受，从而简化应用程序组件(Activities, Fragments 及后台线程)之间的通信  </p>
<ol>
<li><p>EventBus<br>greenrobot 的开源项目<br>项目地址：<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">https://github.com/greenrobot/EventBus</a><br>原理剖析文档：[EventBus](<a href="http://a.codekk.com/detail/Android/Trinea/EventBus" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/Trinea/EventBus</a> 源码解析)<br>文档介绍：<a href="https://github.com/greenrobot/EventBus#general-usage-and-api" target="_blank" rel="noopener">https://github.com/greenrobot/EventBus#general-usage-and-api</a><br>特点：(1) 支持在不同类型的线程中处理订阅，包括发布所在线程，UI 线程、单一后台线程、异步线程<br>(2) 支持事件优先级定义，支持优先级高的订阅者取消事件继续传递，支持粘性事件，是不是跟系统的有序广播、粘性广播很像啊<br>(3) 不是基于 annotations<br>(4) 性能更优<br>(5) 体积小<br>(6) 支持单例创建或创建多个对象<br>(7) 支持根据事件类型订阅  </p>
</li>
<li><p>Otto<br>Square 的开源项目，基于 Guava 的 Android 优化<br>项目地址：<a href="https://github.com/square/otto" target="_blank" rel="noopener">https://github.com/square/otto</a><br>文档介绍：<a href="http://square.github.io/otto/" target="_blank" rel="noopener">http://square.github.io/otto/</a><br><a href="https://github.com/greenrobot/EventBus#comparison-with-squares-otto" target="_blank" rel="noopener">EventBus 与 Otto 的功能及性能对比文档</a><br><a href="https://play.google.com/store/apps/details?id=de.greenrobot.eventperf" target="_blank" rel="noopener">EventBus 与 Otto 性能对比 Demo Apk</a>  </p>
</li>
</ol>
<h4 id="九、传感器"><a href="#九、传感器" class="headerlink" title="九、传感器"></a>九、传感器</h4><ol>
<li><p>Great Android Sensing Toolkit<br>Android 感应器工具包，包含示例及使用过程中可能需要的算法<br>项目地址：<a href="https://github.com/gast-lib/gast-lib" target="_blank" rel="noopener">https://github.com/gast-lib/gast-lib</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=root.gast.playground" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=root.gast.playground</a><br>文档介绍：<a href="https://github.com/gast-lib/gast-lib#documentation" target="_blank" rel="noopener">https://github.com/gast-lib/gast-lib#documentation</a>  </p>
</li>
<li><p>SensorManager<br>Android 传感器管理<br>项目地址：<a href="https://github.com/nlathia/SensorManager" target="_blank" rel="noopener">https://github.com/nlathia/SensorManager</a><br>文档介绍：<a href="https://docs.google.com/document/d/1TqThJULb-4e6TGb1gdkAaPCfyuXStjJpbnt7a0OZ9OE/edit" target="_blank" rel="noopener">https://docs.google.com/document/d/1TqThJULb-4e6TGb1gdkAaPCfyuXStjJpbnt7a0OZ9OE/edit</a>  </p>
</li>
<li><p>GPSLogger<br>记录 GPS 信息<br>项目地址：<a href="https://github.com/mendhak/gpslogger" target="_blank" rel="noopener">https://github.com/mendhak/gpslogger</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.mendhak.gpslogger" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.mendhak.gpslogger</a><br>文档介绍：<a href="http://code.mendhak.com/gpslogger/" target="_blank" rel="noopener">http://code.mendhak.com/gpslogger/</a>  </p>
</li>
<li><p>Pedometer<br>计步器，使用硬件计步感应器<br>项目地址：<a href="https://github.com/j4velin/Pedometer" target="_blank" rel="noopener">https://github.com/j4velin/Pedometer</a>  </p>
</li>
<li><p>leapcast<br>ChromeCast 模拟器的 App<br>项目地址：<a href="https://github.com/dz0ny/leapcast" target="_blank" rel="noopener">https://github.com/dz0ny/leapcast</a>  </p>
</li>
<li><p>Arduino-Communicator<br>与 Arduino 通信的 App<br>项目地址：<a href="https://github.com/jeppsson/Arduino-Communicator" target="_blank" rel="noopener">https://github.com/jeppsson/Arduino-Communicator</a>  </p>
</li>
<li><p>android-pedometer<br>Android 计步器<br>项目地址：<a href="https://github.com/bagilevi/android-pedometer" target="_blank" rel="noopener">https://github.com/bagilevi/android-pedometer</a><br>Demo 地址：<a href="http://pedometer.googlecode.com/files/Pedometer-1.4.apk" target="_blank" rel="noopener">http://pedometer.googlecode.com/files/Pedometer-1.4.apk</a>  </p>
</li>
<li><p>OwnTracks for Android<br>自己的轨迹记录<br>项目地址：<a href="https://github.com/owntracks/android" target="_blank" rel="noopener">https://github.com/owntracks/android</a>  </p>
</li>
<li><p>Shake Detector library for Android<br>Android 手机震动摇晃检测库，提供供 UI 线程调用的回调接口<br>项目地址：<a href="https://github.com/tbouron/ShakeDetector" target="_blank" rel="noopener">https://github.com/tbouron/ShakeDetector</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.github.tbouron.shakedetector.example" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.github.tbouron.shakedetector.example</a>  </p>
</li>
<li><p>Android heart rate monitor<br>Android 心跳检测<br>项目地址：<a href="https://github.com/phishman3579/android-heart-rate-monitor" target="_blank" rel="noopener">https://github.com/phishman3579/android-heart-rate-monitor</a>  </p>
</li>
<li><p>Bluetooth LE Library for Android<br>蓝牙源信息，包括宝库 Mac、更新时间、RSSI、UUID、信号源距离、影响范围等信息<br>项目地址：<a href="https://github.com/alt236/Bluetooth-LE-Library---Android" target="_blank" rel="noopener">https://github.com/alt236/Bluetooth-LE-Library---Android</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=uk.co.alt236.btlescan" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=uk.co.alt236.btlescan</a>  </p>
</li>
<li><p>farebot<br>通过 NFC 从公交卡中读取数据的一个应用<br>项目地址：<a href="https://github.com/codebutler/farebot" target="_blank" rel="noopener">https://github.com/codebutler/farebot</a>  </p>
</li>
</ol>
<h4 id="十、安全"><a href="#十、安全" class="headerlink" title="十、安全"></a>十、安全</h4><ol>
<li><p>SQLCipher<br>Sqlite 加密工具<br>项目地址：<a href="https://github.com/sqlcipher/sqlcipher" target="_blank" rel="noopener">https://github.com/sqlcipher/sqlcipher</a><br>文档介绍：<a href="http://sqlcipher.net/sqlcipher-for-android/" target="_blank" rel="noopener">http://sqlcipher.net/sqlcipher-for-android/</a>  </p>
</li>
<li><p>Conceal<br>快速高效的进行文件加密解密<br>项目地址：<a href="https://github.com/facebook/conceal" target="_blank" rel="noopener">https://github.com/facebook/conceal</a><br>文档介绍：<a href="https://github.com/facebook/conceal#usage" target="_blank" rel="noopener">https://github.com/facebook/conceal#usage</a>  </p>
</li>
<li><p>Android-PasscodeLock<br>应用锁，每次启动或从任何 Activity 启动应用都需要输入四位数字的密码方可进入<br>项目地址：<a href="https://github.com/wordpress-mobile/Android-PasscodeLock" target="_blank" rel="noopener">https://github.com/wordpress-mobile/Android-PasscodeLock</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=org.wordpress.android" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=org.wordpress.android</a><br>APP 示例：Wordpress Android，支付宝，挖财  </p>
</li>
<li><p>GlowPadBackport<br>将 Android4.2 的锁屏界面解锁扩展到 Android1.6 及 1.6+<br>项目地址：<a href="https://github.com/rock3r/GlowPadBackport" target="_blank" rel="noopener">https://github.com/rock3r/GlowPadBackport</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=net.sebastianopoggi.samples.ui.GlowPadSample" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=net.sebastianopoggi.samples.ui.GlowPadSample</a><br>效果图：<img src="https://lh6.ggpht.com/U070b6Lh6cVsVwx4jN-5nq0xqiB1PBzrYABPeJIEe2hZQ5UWOxc-FDUG77wADelToHA=h310-rw" alt="Renderings">  </p>
</li>
<li><p>GlowPadView<br>Android 4 锁屏界面解锁<br>项目地址：<a href="https://github.com/nadavfima/GlowPadView" target="_blank" rel="noopener">https://github.com/nadavfima/GlowPadView</a><br>效果图：<img src="https://raw.github.com/nadavfima/GlowPadView/master/example.png" alt="Renderings">  </p>
</li>
<li><p>Android-InsecureBank<br>关于 Android 不安全性的示例<br>项目地址：<a href="https://github.com/dineshshetty/Android-InsecureBankv2" target="_blank" rel="noopener">https://github.com/dineshshetty/Android-InsecureBankv2</a>  </p>
</li>
</ol>
<h4 id="十一、插件化"><a href="#十一、插件化" class="headerlink" title="十一、插件化"></a>十一、插件化</h4><p>更多见：<a href="http://www.trinea.cn/android/android-plugin/" target="_blank" rel="noopener">Android 插件化作用、概念以及不错的资料(包括开源项目)和解决方案</a>  </p>
<ol>
<li><p>dynamic-load-apk<br>Android 动态加载 Apk，热部署，利用 ClassLoader 以及 Activity 代理的方式解决<br>项目地址：<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="noopener">https://github.com/singwhatiwanna/dynamic-load-apk</a><br>原理剖析文档：[dynamic-load-apk](<a href="http://a.codekk.com/detail/Android/FFish/DynamicLoadApk" target="_blank" rel="noopener">http://a.codekk.com/detail/Android/FFish/DynamicLoadApk</a> 源码解析)<br>文档介绍：<a href="http://blog.csdn.net/singwhatiwanna/article/details/22597587" target="_blank" rel="noopener">http://blog.csdn.net/singwhatiwanna/article/details/22597587</a>  </p>
</li>
<li><p>Android Dynamic Loader<br>点评的实现方式，和上面不同的是：他不是用代理 Activity 的方式实现而是用 Fragment 以及 Schema 的方式实现<br>项目地址：<a href="https://github.com/mmin18/AndroidDynamicLoader" target="_blank" rel="noopener">https://github.com/mmin18/AndroidDynamicLoader</a><br>Demo 地址：<a href="https://github.com/mmin18/AndroidDynamicLoader/raw/master/host.apk" target="_blank" rel="noopener">https://github.com/mmin18/AndroidDynamicLoader/raw/master/host.apk</a>  </p>
</li>
<li><p>xCombine<br>Android App 插件式插件开发，插件必须先安装，更推荐看上面两个开源项目<br>项目地址：<a href="https://github.com/wyouflf/xCombine" target="_blank" rel="noopener">https://github.com/wyouflf/xCombine</a><br>文档介绍：<a href="http://my.oschina.net/u/1171837/blog/155377" target="_blank" rel="noopener">http://my.oschina.net/u/1171837/blog/155377</a>  </p>
</li>
<li><p>Android Plugin Framework<br>Android 插件式开发，开放的源码目前不完整<br>项目地址：<a href="https://github.com/umeng/apf" target="_blank" rel="noopener">https://github.com/umeng/apf</a>  </p>
</li>
<li><p>Android OpenAtlas<br>Android插件框架，基于OSGI，非代理方式，组件需要在宿主中声明<br>项目地址：<a href="https://github.com/bunnyblue/OpenAtlas" target="_blank" rel="noopener">https://github.com/bunnyblue/OpenAtlas</a><br>Demo 地址：<a href="https://github.com/bunnyblue/OpenAtlasExtension/blob/master/Dist/OpenAtlasLauncher.apk" target="_blank" rel="noopener">https://github.com/bunnyblue/OpenAtlasExtension/blob/master/Dist/OpenAtlasLauncher.apk</a> </p>
</li>
<li><p>multidex<br>安装多 dex 的 classloader<br>项目地址：<a href="https://github.com/casidiablo/multidex" target="_blank" rel="noopener">https://github.com/casidiablo/multidex</a>  </p>
</li>
<li><p>ANR-WatchDog<br>Android ANR 监听，通过监听自己的 UI Thread 是否被执行确定是否发生了 ANR，并可以设置相关事件<br>项目地址：<a href="https://github.com/SalomonBrys/ANR-WatchDog" target="_blank" rel="noopener">https://github.com/SalomonBrys/ANR-WatchDog</a>  </p>
</li>
</ol>
<h4 id="十二、文件"><a href="#十二、文件" class="headerlink" title="十二、文件"></a>十二、文件</h4><p>对不同文档类型的处理，包括 PDF、Word、EPub、Html、Zip 等  </p>
<ol>
<li><p>purePDF<br>允许从任何运行的 SWF 文件读取和创建 PDF 文档<br>项目地址：<a href="https://github.com/sephiroth74/purePDF" target="_blank" rel="noopener">https://github.com/sephiroth74/purePDF</a>  </p>
</li>
<li><p>android-pdfview<br>快速解析 pdf 的 view，默认支持手势缩放和相关动画<br>项目地址：<a href="https://github.com/JoanZapata/android-pdfview" target="_blank" rel="noopener">https://github.com/JoanZapata/android-pdfview</a>  </p>
</li>
<li><p>Office 365 SDK for Android Preview<br>可支持 Microsoft SharePoint Lists, Microsoft SharePoint Files, Microsoft Exchange Calendar, Microsoft Exchange Contacts, Microsoft Exchange Mail<br>项目地址：<a href="https://github.com/OfficeDev/Office-365-SDK-for-Android" target="_blank" rel="noopener">https://github.com/OfficeDev/Office-365-SDK-for-Android</a>  </p>
</li>
<li><p>OpenSpritz-Android<br>EPub 阅读器<br>项目地址：<a href="https://github.com/OnlyInAmerica/OpenSpritz-Android" target="_blank" rel="noopener">https://github.com/OnlyInAmerica/OpenSpritz-Android</a>  </p>
</li>
<li><p>jsoup<br>一个解析 html 的 java 库，可方便的提取和操作数据<br>项目地址：<a href="https://github.com/jhy/jsoup" target="_blank" rel="noopener">https://github.com/jhy/jsoup</a><br>官网网址：<a href="http://jsoup.org/" target="_blank" rel="noopener">http://jsoup.org/</a><br>作用：(1) 从一个 url、文件或 string 获得 html 并解析<br>(2) 利用 dom 遍历或 css 选择器查找、提取数据<br>(3) 操作 html 元素<br>(4) 根据白名单去除用于提交的非法数据防止 xss 攻击<br>(5) 输出整齐的 html  </p>
</li>
<li><p>ZIP<br>java 压缩和解压库<br>项目地址：<a href="https://github.com/zeroturnaround/zt-zip" target="_blank" rel="noopener">https://github.com/zeroturnaround/zt-zip</a><br>文档介绍：<a href="https://github.com/zeroturnaround/zt-zip#examples" target="_blank" rel="noopener">https://github.com/zeroturnaround/zt-zip#examples</a><br>作用：(1) 解压和压缩，并支持文件夹内递归操作<br>(2) 支持包含和排除某些元素<br>(3) 支持重命名元素<br>(4) 支持遍历 zip 包内容<br>(5) 比较两个 zip 包等功能  </p>
</li>
<li><p>Image File Selector<br>轻量级的图片文件选择器，用系统api选取，压缩和裁切图片，可以方便的得要指定尺寸的图片<br>项目地址：<a href="https://github.com/sw926/ImageFileSelector" target="_blank" rel="noopener">https://github.com/sw926/ImageFileSelector</a>  </p>
</li>
</ol>
<h4 id="十三、其他"><a href="#十三、其他" class="headerlink" title="十三、其他"></a>十三、其他</h4><ol>
<li><p>FragmentStack<br>一个封装了启动模式的Fragment便捷使用库,方便构建单Activity+多Fragment轻量级框架<br>项目地址：<a href="https://github.com/Mr-wangyong/FragmentStack" target="_blank" rel="noopener">https://github.com/Mr-wangyong/FragmentStack</a><br>效果图：<a href="https://github.com/Mr-wangyong/FragmentStack/blob/master/play.gif" target="_blank" rel="noopener">https://github.com/Mr-wangyong/FragmentStack/blob/master/play.gif</a><br>App示例：<a href="http://www.wandoujia.com/apps/cn.vcinema.cinema" target="_blank" rel="noopener">南瓜电影</a>  </p>
</li>
<li><p>CustomTabsHelper<br>快速集成 CustomTabs 的工具类<br>项目地址：<a href="https://github.com/DreaminginCodeZH/CustomTabsHelper" target="_blank" rel="noopener">https://github.com/DreaminginCodeZH/CustomTabsHelper</a>  </p>
</li>
<li><p>EffortlessPermissions<br>基于 Google EasyPermissions 进行扩展的动态权限库<br>项目地址：<a href="https://github.com/DreaminginCodeZH/EffortlessPermissions" target="_blank" rel="noopener">https://github.com/DreaminginCodeZH/EffortlessPermissions</a>  </p>
</li>
<li><p>Salvage view<br>带 View 缓存的 Viewpager PagerAdapter，很方便使用<br>项目地址：<a href="https://github.com/JakeWharton/salvage" target="_blank" rel="noopener">https://github.com/JakeWharton/salvage</a>  </p>
</li>
<li><p>Android Priority Job Queue<br>Android 后台任务队列<br>项目地址：<a href="https://github.com/path/android-priority-jobqueue" target="_blank" rel="noopener">https://github.com/path/android-priority-jobqueue</a><br>文档介绍：<a href="https://github.com/path/android-priority-jobqueue#getting-started" target="_blank" rel="noopener">https://github.com/path/android-priority-jobqueue#getting-started</a>  </p>
</li>
<li><p>Cobub Razor<br>开源的 mobile 行为分析系统，包括 web 端、android 端，支持 ios 和 window phone<br>项目地址：<a href="https://github.com/cobub/razor" target="_blank" rel="noopener">https://github.com/cobub/razor</a><br>Demo 地址：<a href="http://demo.cobub.com/razor" target="_blank" rel="noopener">http://demo.cobub.com/razor</a><br>官网网址：<a href="http://dev.cobub.com/" target="_blank" rel="noopener">http://dev.cobub.com/</a>  </p>
</li>
<li><p>Countly<br>Android 移动端数据采集分析系统<br>项目地址：<a href="https://github.com/Countly/countly-sdk-android" target="_blank" rel="noopener">https://github.com/Countly/countly-sdk-android</a><br>官网网址：<a href="https://count.ly/" target="_blank" rel="noopener">https://count.ly/</a>  </p>
</li>
<li><p>aFileChooser<br>文件选择器，可内嵌到程序中，而无需使用系统或三方文件选择器。<br>项目地址：<a href="https://github.com/iPaulPro/aFileChooser" target="_blank" rel="noopener">https://github.com/iPaulPro/aFileChooser</a>  </p>
</li>
<li><p>androidpn<br>基于 xmpp 协议的消息推送解决方案，包括服务器端和 android 端。<br>项目地址：<a href="https://github.com/dannytiehui/androidpn" target="_blank" rel="noopener">https://github.com/dannytiehui/androidpn</a>  </p>
</li>
<li><p>Bolts<br>Android 的异步编程模式<br>项目地址：<a href="https://github.com/BoltsFramework/Bolts-Android/" target="_blank" rel="noopener">https://github.com/BoltsFramework/Bolts-Android/</a><br>与 AsyncTask 比较：(1) 使用的是无大小限制的线程池<br>(2) 任务可组合可级联，防止了代码耦合  </p>
</li>
<li><p>CastCompanionLibrary-android<br>使 Android 程序中更快的接入 Google Cast<br>项目地址：<a href="https://github.com/googlecast/CastCompanionLibrary-android" target="_blank" rel="noopener">https://github.com/googlecast/CastCompanionLibrary-android</a><br>文档介绍：<a href="https://developers.google.com/cast/" target="_blank" rel="noopener">https://developers.google.com/cast/</a>  </p>
</li>
<li><p>CastVideos-android<br>从 Android 设备分享 Video 通过 Google Cast<br>项目地址：<a href="https://github.com/googlecast/CastVideos-android" target="_blank" rel="noopener">https://github.com/googlecast/CastVideos-android</a><br>文档介绍：<a href="https://developers.google.com/cast/" target="_blank" rel="noopener">https://developers.google.com/cast/</a>  </p>
</li>
<li><p>Uninstall_Statics<br>Android 应用自身被卸载监听及打开浏览器等反馈功能实现<br>项目地址：<a href="https://github.com/sevenler/Uninstall_Statics" target="_blank" rel="noopener">https://github.com/sevenler/Uninstall_Statics</a><br>文档介绍：<a href="http://www.cnblogs.com/zealotrouge/p/3157126.html" target="_blank" rel="noopener">http://www.cnblogs.com/zealotrouge/p/3157126.html</a>  <a href="http://www.cnblogs.com/zealotrouge/p/3159772.html" target="_blank" rel="noopener">http://www.cnblogs.com/zealotrouge/p/3159772.html</a>  </p>
</li>
<li><p>Memento<br>保证在系统配置改变时，Activity 中的某些数据可以简单安全的保持不变<br>项目地址：<a href="https://github.com/mttkay/memento" target="_blank" rel="noopener">https://github.com/mttkay/memento</a><br>文档介绍：<a href="https://github.com/mttkay/memento#usage" target="_blank" rel="noopener">https://github.com/mttkay/memento#usage</a>  </p>
</li>
<li><p>FreeFlow<br>布局引擎，更简单的创建自定义布局，并且当数据和布局改变时更美观的过渡动画<br>项目地址：<a href="https://github.com/Comcast/FreeFlow" target="_blank" rel="noopener">https://github.com/Comcast/FreeFlow</a><br>Demo 地址：<a href="https://github.com/Comcast/FreeFlow/releases" target="_blank" rel="noopener">https://github.com/Comcast/FreeFlow/releases</a>  </p>
</li>
<li><p>Android Gesture Detectors Framework<br>Android 手势框架，支持双指旋转、移动、平移、缩放等<br>项目地址：<a href="https://github.com/Almeros/android-gesture-detectors" target="_blank" rel="noopener">https://github.com/Almeros/android-gesture-detectors</a>  </p>
</li>
<li><p>Mapbox Android SDK<br>Android Map 的替代版<br>项目地址：<a href="https://github.com/mapbox/mapbox-android-sdk" target="_blank" rel="noopener">https://github.com/mapbox/mapbox-android-sdk</a>  </p>
</li>
<li><p>Activity animation<br>Activity 跳转动画，支持各个方向波浪的效果<br>项目地址：<a href="https://github.com/flavienlaurent/activityanimation" target="_blank" rel="noopener">https://github.com/flavienlaurent/activityanimation</a><br>在线演示：<a href="https://www.youtube.com/watch?v=-E0sc6w_Jck" target="_blank" rel="noopener">https://www.youtube.com/watch?v=-E0sc6w_Jck</a>  </p>
</li>
<li><p>KryoNet<br>通过 NIO 提供客户端和服务器端 TCP/UDP 网络传输的 Java 库<br>项目地址：<a href="https://github.com/EsotericSoftware/kryonet" target="_blank" rel="noopener">https://github.com/EsotericSoftware/kryonet</a>  </p>
</li>
<li><p>Rebound<br>一个模仿弹簧反弹的 Java 库，可用于创建动画<br>项目地址：<a href="https://github.com/facebook/rebound" target="_blank" rel="noopener">https://github.com/facebook/rebound</a>  </p>
</li>
<li><p>Android Social Networks<br>社交网络接入统一管理器，可方便的从 Twitter, LinkedIn, Facebook, Google Plus 登陆、获得个人信息、发送消息、发送专篇、添加或删除好友<br>项目地址：<a href="https://github.com/antonkrasov/AndroidSocialNetworks" target="_blank" rel="noopener">https://github.com/antonkrasov/AndroidSocialNetworks</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.github.androidsocialnetworks.apidemos" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.github.androidsocialnetworks.apidemos</a>  </p>
</li>
<li><p>SmartAppUpdates<br>Android App 增量升级，包含前后端方案、Demo、以及 so 库，可用于商店或大体积 App 差分升级<br>项目地址：<a href="https://github.com/cundong/SmartAppUpdates" target="_blank" rel="noopener">https://github.com/cundong/SmartAppUpdates</a>  </p>
</li>
<li><p>Magnet<br>创建类似 Facebook 聊天桌面悬浮窗的效果<br>项目地址：<a href="https://github.com/premnirmal/Magnet" target="_blank" rel="noopener">https://github.com/premnirmal/Magnet</a>  </p>
</li>
<li><p>AcDisplay<br>将 Android 的通知都集中到锁屏显示<br>项目地址：<a href="https://github.com/AChep/AcDisplay" target="_blank" rel="noopener">https://github.com/AChep/AcDisplay</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.achep.acdisplay" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.achep.acdisplay</a>  </p>
</li>
<li><p>QrCodeScan<br>ZXing 和 ZBar 结合的二维码扫描项目，提高了扫描效率<br>项目地址：<a href="https://github.com/SkillCollege/QrCodeScan" target="_blank" rel="noopener">https://github.com/SkillCollege/QrCodeScan</a><br>效果图：<img src="http://www.eoeandroid.com/data/attachment/forum/201405/09/124538vteuz4leptgg1te6.png" alt="Renderings">  </p>
</li>
<li><p>Android-ScreenShot<br>实现 android 系统截屏功能<br>项目地址：<a href="https://github.com/Android-ScreenShot/AndroidScreenShotService" target="_blank" rel="noopener">https://github.com/Android-ScreenShot/AndroidScreenShotService</a><br>文档介绍：<a href="http://blog.csdn.net/buptgshengod/article/details/39155979" target="_blank" rel="noopener">http://blog.csdn.net/buptgshengod/article/details/39155979</a>  </p>
</li>
<li><p>card.io SDK for Android<br>信用卡扫描 Android SDK<br>项目地址：<a href="https://github.com/card-io/card.io-Android-SDK" target="_blank" rel="noopener">https://github.com/card-io/card.io-Android-SDK</a><br>Demo 项目：<a href="https://github.com/card-io/card.io-Android-SDK/tree/master/SampleApp" target="_blank" rel="noopener">https://github.com/card-io/card.io-Android-SDK/tree/master/SampleApp</a>  </p>
</li>
<li><p>ASNE<br>Twitter, Facebook, Google Plus, LinkedIn, Instagram, Vkontakte, Odnoklassniki 的集成库，包括他们的大多数功能<br>项目地址：<a href="https://github.com/gorbin/ASNE" target="_blank" rel="noopener">https://github.com/gorbin/ASNE</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=com.gorbin.androidsocialnetworksextended.asne" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.gorbin.androidsocialnetworksextended.asne</a>  </p>
</li>
<li><p>Android Signature Pad<br>Android 自定义的签名 View，可自定义笔颜色和大小<br>项目地址：<a href="https://github.com/gcacace/android-signaturepad" target="_blank" rel="noopener">https://github.com/gcacace/android-signaturepad</a><br>Demo 项目：<a href="https://github.com/gcacace/android-signaturepad/tree/master/SignaturePad-Example" target="_blank" rel="noopener">https://github.com/gcacace/android-signaturepad/tree/master/SignaturePad-Example</a>  </p>
</li>
<li><p>Teleport<br>Android Wear 数据同步和消息传送库<br>项目地址：<a href="https://github.com/Mariuxtheone/Teleport" target="_blank" rel="noopener">https://github.com/Mariuxtheone/Teleport</a>  </p>
</li>
<li><p>DebugLog<br>可以帮你创建更简单和更容易理解的调试日志，能够友好的显示调试信息所在类和函数。<br>项目地址：<a href="https://github.com/MustafaFerhan/DebugLog" target="_blank" rel="noopener">https://github.com/MustafaFerhan/DebugLog</a><br>效果图：<img src="https://camo.githubusercontent.com/37deffede9f9b185886da48e96a4829ebd407260/68747470733a2f2f7261772e6769746875622e636f6d2f4d75737461666146657268616e2f44656275674c6f672f6d61737465722f44656275674c6f672d44656d6f2f6173736574732f7373322e6a7067" alt="Renderings">  </p>
</li>
<li><p>Logger<br>简单、美观而且十分强大的 Android 日志工具<br>项目地址：<a href="https://github.com/orhanobut/logger" target="_blank" rel="noopener">https://github.com/orhanobut/logger</a><br>Demo 地址：<a href="https://github.com/orhanobut/logger/tree/master/app" target="_blank" rel="noopener">https://github.com/orhanobut/logger/tree/master/app</a><br>效果图：<img src="https://github.com/orhanobut/logger/blob/master/images/description.png" alt="Renderings">  </p>
</li>
<li><p>jlog<br>可以灵活配置的日志工具，支持JSON打印，日志保存到指定文件，日志显示调用位置（混淆模式下依然有效）<br>项目地址：<a href="https://github.com/JiongBull/jlog" target="_blank" rel="noopener">https://github.com/JiongBull/jlog</a><br>Demo 地址：<a href="https://raw.githubusercontent.com/JiongBull/jlog/master/apk/JLog_sample.apk" target="_blank" rel="noopener">apk地址</a><br>效果图：<img src="http://7xize8.com1.z0.glb.clouddn.com/jlog_sample.gif" alt="Renderings">  </p>
</li>
<li><p>Phrase<br>square 组开源大牛写的字符串替换类<br>项目地址：<a href="https://github.com/square/phrase" target="_blank" rel="noopener">https://github.com/square/phrase</a>  </p>
</li>
<li><p>ColorPhrase<br>模仿 phrase 写的对字符串个别字符颜色改变的类，高效强大！<br>项目地址：<a href="https://github.com/THEONE10211024/ColorPhrase" target="_blank" rel="noopener">https://github.com/THEONE10211024/ColorPhrase</a><br>效果图：<img src="https://github.com/THEONE10211024/ColorPhrase/blob/master/screenshot/Screenshot_2015-05-16-18-12-23.jpeg" alt="Renderings">  </p>
</li>
<li><p>PinyinSearch<br>一个为 T9 搜索和 Qwerty 搜索,提供数据解析与匹配等方法的拼音搜索 java 库。<br>项目地址： <a href="https://github.com/handsomezhou/PinyinSearchLibrary" target="_blank" rel="noopener">https://github.com/handsomezhou/PinyinSearchLibrary</a><br>Demo 地址： <a href="https://github.com/handsomezhou/PinyinSearchLibrary/blob/master/external_res/bin/ContactsSearch.apk?raw=true" target="_blank" rel="noopener">ContactsSearch</a>    <a href="https://github.com/handsomezhou/PinyinSearchLibrary/blob/master/external_res/bin/AppSearch.apk?raw=true" target="_blank" rel="noopener">AppSearch</a><br>效果图：<img src="https://github.com/handsomezhou/PinyinSearchLibrary/blob/master/external_res/image/ContactsSearch.gif" alt="Renderings"><br>APP 示例： 通讯录应用，微信电话本  </p>
</li>
<li><p>PrainView<br>PaintView 是一个画图工具:<br>可直接使用设定按钮来实现已拥有的方法，且拓展性强<br>基础功能：更换颜色、更换橡皮、以及更换橡皮和笔的粗细、清屏、倒入图片<br>特殊功能：保存画笔轨迹帧动画、帧动画导入导出、ReDo和UnDo<br>项目地址：<a href="https://github.com/lfkdsk/JustWeTools" target="_blank" rel="noopener">Paintview</a><br>效果图：<img src="https://github.com/lfkdsk/JustWeTools/blob/master/picture/gif.gif" alt="p1">  </p>
<pre><code>![p2](https://github.com/lfkdsk/JustWeTools/blob/master/picture/io.gif)  </code></pre><p>demo地址：<a href="https://github.com/lfkdsk/JustWeTools/blob/master/demo/DrawAPicture.apk" target="_blank" rel="noopener">apk地址</a><br>原理解析：<a href="http://www.cnblogs.com/lfk-dsk/p/4768850.html" target="_blank" rel="noopener">PaintView 绘图控件解析</a>  </p>
</li>
<li><p>CodeView<br>CodeView代码查看／修改工具: 基于WebView制作的代码编辑器,实现代码高亮，暗色主题<br>项目地址：<a href="https://github.com/lfkdsk/JustWeTools" target="_blank" rel="noopener">CodeView</a><br>效果图：<img src="https://github.com/lfkdsk/JustWeTools/blob/master/picture/accomplish.png" alt="p3">  </p>
<pre><code>![p4](https://github.com/lfkdsk/JustWeTools/blob/master/picture/edit.png)  </code></pre><p>demo地址：<a href="https://github.com/lfkdsk/JustWeTools/blob/master/demo/JustWeTools.apk" target="_blank" rel="noopener">apk地址</a>  </p>
</li>
<li><p>ExplorerView<br>文件浏览器：继承自ListView，可拓展性强，可进行文件类型分析<br>项目地址：<a href="https://github.com/lfkdsk/JustWeTools" target="_blank" rel="noopener">CodeView</a><br>效果图：<img src="https://github.com/lfkdsk/JustWeTools/blob/master/picture/explorer1.png" alt="p5"><br><img src="https://github.com/lfkdsk/JustWeTools/blob/master/picture/explorer2.png" alt="p6"><br>demo地址：<a href="https://github.com/lfkdsk/JustWeTools/blob/master/demo/JustWeTools.apk" target="_blank" rel="noopener">apk地址</a>  </p>
</li>
<li><p>ReadView<br>小说阅读器，支持文字字体、颜色、背景、进度等多种调整，支持一键设置。<br>项目地址：<a href="https://github.com/lfkdsk/JustWeTools" target="_blank" rel="noopener">ReadView</a><br>效果图：<img src="https://github.com/lfkdsk/JustWeTools/blob/master/picture/readbook.png" alt="p7"><br>demo地址：<a href="https://github.com/lfkdsk/JustWeTools/blob/master/demo/JustWeTools.apk" target="_blank" rel="noopener">apk地址</a>  </p>
</li>
<li><p>MarkDownView<br>支持MarkDown语法的渲染器,基于WebView的MarkDown渲染器,支持标准化的MarkDown语法,<br>调用接口和CodeView保持一致使用简便<br>项目地址：<a href="https://github.com/lfkdsk/JustWeTools" target="_blank" rel="noopener">ReadView</a><br>效果图：<img src="https://github.com/lfkdsk/JustWeTools/blob/master/picture/markdown.png" alt="markdown"><br>demo地址：<a href="https://github.com/lfkdsk/JustWeTools/blob/master/demo/JustWeTools.apk" target="_blank" rel="noopener">apk地址</a>  </p>
</li>
<li><p>VerTextView竖行排版的TextView:<br>支持竖行排版，添加了下划线功能，开启简便，下划线粗细、颜色、间距均可自定义，<br>接口调用方式与TextView相似，使用简便。<br>项目地址：<a href="https://github.com/lfkdsk/JustWeTools" target="_blank" rel="noopener">ReadView</a><br>效果图：<img src="https://github.com/lfkdsk/JustWeTools/blob/master/picture/VerTextView.png" alt="vertextview"><br>demo地址：<a href="https://github.com/lfkdsk/JustWeTools/blob/master/demo/JustWeTools.apk" target="_blank" rel="noopener">apk地址</a>  </p>
</li>
<li><p>GHDownload下载框架<br>支持单线程和多线程断点下载，简单易用。<br>项目地址：<a href="https://github.com/guanchao/GHDownload" target="_blank" rel="noopener">GHDownload</a>  </p>
</li>
</ol>
<h2 id="第三部分-优秀项目"><a href="#第三部分-优秀项目" class="headerlink" title="第三部分 优秀项目"></a>第三部分 优秀项目</h2><p>主要介绍那些 Android 还不错的完整项目，目前包含的项目主要依据是项目有意思或项目分层规范比较好。  </p>
<h4 id="一、系统及平台"><a href="#一、系统及平台" class="headerlink" title="一、系统及平台"></a>一、系统及平台</h4><ol>
<li>Linux<br>项目地址：<a href="https://github.com/torvalds/linux" target="_blank" rel="noopener">https://github.com/torvalds/linux</a>  </li>
<li>Android<br>项目地址：<a href="https://android.googlesource.com/" target="_blank" rel="noopener">https://android.googlesource.com/</a>  </li>
</ol>
<h4 id="二、项目"><a href="#二、项目" class="headerlink" title="二、项目"></a>二、项目</h4><ol>
<li><p>ZXing<br>二维码扫描工具<br>项目地址：<a href="https://github.com/zxing/zxing" target="_blank" rel="noopener">https://github.com/zxing/zxing</a> 或 <a href="https://code.google.com/p/zxing/" target="_blank" rel="noopener">https://code.google.com/p/zxing/</a><br>APK 地址：<a href="https://play.google.com/store/apps/details?id=com.google.zxing.client.android" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.google.zxing.client.android</a><br>其他：现在市面上很多应用的二维码扫描功能都是从这个修改而来  </p>
</li>
<li><p>photup<br>编辑机批量上传照片到 facebook 上<br>项目地址：<a href="https://github.com/chrisbanes/photup" target="_blank" rel="noopener">https://github.com/chrisbanes/photup</a><br>APK 地址：<a href="https://play.google.com/store/apps/details?id=uk.co.senab.photup" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=uk.co.senab.photup</a><br>其他：代码分包合理，很棒。不过这个项目依赖的开源项目比较多，比较难编译  </p>
</li>
<li><p>github-android<br>Github 的 Android 客户端项目<br>项目地址：<a href="https://github.com/github/android" target="_blank" rel="noopener">https://github.com/github/android</a><br>APK 地址：<a href="https://play.google.com/store/apps/details?id=com.github.mobile" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.github.mobile</a>  </p>
</li>
<li><p>Notes<br>MIUI 便签<br>项目地址：<a href="https://github.com/MiCode/Notes" target="_blank" rel="noopener">https://github.com/MiCode/Notes</a><br>APK 地址：<a href="https://github.com/Trinea/TrineaDownload/blob/master/miui-note-demo.apk?raw=true" target="_blank" rel="noopener">https://github.com/Trinea/TrineaDownload/blob/master/miui-note-demo.apk?raw=true</a><br>其他：项目分包比较合理，相比较 miui 的文件管理器 <a href="https://github.com/MiCode/FileExplorer" target="_blank" rel="noopener">https://github.com/MiCode/FileExplorer</a> 代码规范较好得多  </p>
</li>
<li><p>weicuiyuan<br>四次元-新浪微博客户端<br>项目地址：<a href="https://github.com/qii/weiciyuan" target="_blank" rel="noopener">https://github.com/qii/weiciyuan</a><br>APK 地址：<a href="https://play.google.com/store/apps/details?id=org.qii.weiciyuan" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=org.qii.weiciyuan</a>  </p>
</li>
<li><p>Douya<br>豆芽——Material Design 的豆瓣客户端<br>项目地址：<a href="https://github.com/DreaminginCodeZH/Douya" target="_blank" rel="noopener">https://github.com/DreaminginCodeZH/Douya</a><br>效果图：<img src="https://raw.githubusercontent.com/DreaminginCodeZH/Douya/master/screenshot/00-main.png" alt="">  </p>
</li>
<li><p>gnucash-android<br>一个记账理财软件<br>项目地址：<a href="https://github.com/codinguser/gnucash-android" target="_blank" rel="noopener">https://github.com/codinguser/gnucash-android</a><br>APK 地址：<a href="http://play.google.com/store/apps/details?id=org.gnucash.android" target="_blank" rel="noopener">http://play.google.com/store/apps/details?id=org.gnucash.android</a>  </p>
</li>
<li><p>AntennaPod<br>支持 rss 订阅、音乐订阅<br>项目地址：<a href="https://github.com/danieloeh/AntennaPod" target="_blank" rel="noopener">https://github.com/danieloeh/AntennaPod</a><br>APK 地址：<a href="https://play.google.com/store/apps/details?id=de.danoeh.antennapod" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=de.danoeh.antennapod</a>  </p>
</li>
<li><p>ChaseWhisplyProject<br>打鬼游戏<br>项目地址：<a href="https://github.com/tvbarthel/ChaseWhisplyProject" target="_blank" rel="noopener">https://github.com/tvbarthel/ChaseWhisplyProject</a><br>APK 地址：<a href="https://play.google.com/store/apps/details?id=fr.tvbarthel.games.chasewhisply" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=fr.tvbarthel.games.chasewhisply</a>  </p>
</li>
<li><p>Tweet Lanes<br>功能完整的 Twitter 客户端<br>项目地址：<a href="https://github.com/chrislacy/TweetLanes" target="_blank" rel="noopener">https://github.com/chrislacy/TweetLanes</a><br>APK 地址：<a href="https://play.google.com/store/apps/details?id=com.tweetlanes.android" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.tweetlanes.android</a>  </p>
</li>
<li><p>Financius<br>简单易用的记账程序<br>项目地址：<a href="https://github.com/mvarnagiris/Financius" target="_blank" rel="noopener">https://github.com/mvarnagiris/Financius</a><br>APK 地址：<a href="https://play.google.com/store/apps/details?id=com.code44.finance" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.code44.finance</a>  </p>
</li>
<li><p>todo.txt-android<br>todo.txt 的官方 Android 应用<br>项目地址：<a href="https://github.com/ginatrapani/todo.txt-android" target="_blank" rel="noopener">https://github.com/ginatrapani/todo.txt-android</a><br>APK 地址：<a href="https://play.google.com/store/apps/details?id=com.todotxt.todotxttouch" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.todotxt.todotxttouch</a>  </p>
</li>
<li><p>simpletask<br>基于 todo.txt 官方应用的另一个客户端<br>项目地址：<a href="https://github.com/mpcjanssen/simpletask-android" target="_blank" rel="noopener">https://github.com/mpcjanssen/simpletask-android</a><br>APK 地址：<a href="https://play.google.com/store/apps/details?id=nl.mpcjanssen.todotxtholo" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=nl.mpcjanssen.todotxtholo</a>  </p>
</li>
<li><p>Muzei Live Wallpaper<br>定时更换桌面精美壁纸<br>项目地址：<a href="https://github.com/romannurik/muzei" target="_blank" rel="noopener">https://github.com/romannurik/muzei</a><br>APK 地址：<a href="https://play.google.com/store/apps/details?id=net.nurik.roman.muzei" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=net.nurik.roman.muzei</a>  </p>
</li>
<li><p>Scanbook<br>扫描搜索查询图书信息<br>项目地址：<a href="https://github.com/JayFang1993/ScanBook" target="_blank" rel="noopener">https://github.com/JayFang1993/ScanBook</a><br>APK 地址：<a href="http://www.wandoujia.com/apps/com.scanbook" target="_blank" rel="noopener">http://www.wandoujia.com/apps/com.scanbook</a>  </p>
</li>
<li><p>iosched<br>The Google I/O 2014 Android App<br>项目地址：<a href="https://github.com/google/iosched" target="_blank" rel="noopener">https://github.com/google/iosched</a><br>APK 地址：<a href="https://play.google.com/store/apps/details?id=com.google.samples.apps.iosched" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.google.samples.apps.iosched</a>  </p>
</li>
<li><p>CoolClock<br>An Android clock<br>项目地址：<a href="https://github.com/socoolby/CoolClock" target="_blank" rel="noopener">https://github.com/socoolby/CoolClock</a><br>APK 地址：<a href="https://github.com/socoolby/CoolClock/blob/master/CoolClock.apk" target="_blank" rel="noopener">https://github.com/socoolby/CoolClock/blob/master/CoolClock.apk</a><br>效果图：<br><img src="https://raw.githubusercontent.com/socoolby/CoolClock/master/CoolClock.png" width="768" height="382"/><img src="https://raw.githubusercontent.com/socoolby/CoolClock/master/demonstrate.gif" width="320" height="568"/>  </p>
</li>
</ol>
<h2 id="第四部分-开发工具及测试工具"><a href="#第四部分-开发工具及测试工具" class="headerlink" title="第四部分 开发工具及测试工具"></a>第四部分 开发工具及测试工具</h2><p>主要介绍和 Android 开发工具和测试工具相关的开源项目。  </p>
<h4 id="一、开发效率工具"><a href="#一、开发效率工具" class="headerlink" title="一、开发效率工具"></a>一、开发效率工具</h4><ol>
<li><p>Parceler<br>通过注解及工具类自动完成实体类 Parcelable 及值传递<br>项目地址：<a href="https://github.com/johncarl81/parceler" target="_blank" rel="noopener">https://github.com/johncarl81/parceler</a>  </p>
</li>
<li><p>Json2Java<br>根据 JSon 数据自动生成对应的 Java 实体类，还支持 Parcel、Gson Annotations 对应代码自动生成。期待后续的提取父类以及多 url 构建整个工程的功能<br>项目地址：<a href="https://github.com/jonfhancock/JsonToJava" target="_blank" rel="noopener">https://github.com/jonfhancock/JsonToJava</a><br>在线演示：<a href="http://jsontojava.appspot.com/" target="_blank" rel="noopener">http://jsontojava.appspot.com/</a>  </p>
</li>
<li><p>IntelliJ Plugin for Android Parcelable boilerplate code generation<br>Android studio 插件，生成 Parcelable 代码<br>项目地址：<a href="https://github.com/mcharmas/android-parcelable-intellij-plugin" target="_blank" rel="noopener">https://github.com/mcharmas/android-parcelable-intellij-plugin</a><br>效果图：<img src="https://github.com/mcharmas/android-parcelable-intellij-plugin/raw/master/screenshot.png" alt="Renderings">  </p>
</li>
<li><p>Android Holo Colors IntelliJ Plugin<br>Android studio 插件，生成 holo 样式 9 patch 图片<br>项目地址：<a href="https://github.com/jeromevdl/android-holo-colors-idea-plugin" target="_blank" rel="noopener">https://github.com/jeromevdl/android-holo-colors-idea-plugin</a><br>效果图：<img src="https://raw.github.com/jeromevdl/android-holo-colors-idea-plugin/master/other/holocolorsidea.png" alt="Renderings">  </p>
</li>
<li><p>Android Drawable Factory<br>用于生成各个分辨率的图片<br>项目地址：<a href="https://github.com/tizionario/AndroidDrawableFactory" target="_blank" rel="noopener">https://github.com/tizionario/AndroidDrawableFactory</a><br>效果图：<img src="https://github-camo.global.ssl.fastly.net/5c3844b345a9779296f996490070dab0bfc9dbf5/68747470733a2f2f646c2e64726f70626f7875736572636f6e74656e742e636f6d2f752f32363636343637352f416e64726f69644472617761626c65466163746f72792f312e706e67" alt="Renderings">  </p>
</li>
<li><p>SelectorChapek for Android<br>Android Studio 插件，可根据固定文件名格式资源自动生成 drawable selectors xml 文件。<br>项目地址：<a href="https://github.com/inmite/android-selector-chapek" target="_blank" rel="noopener">https://github.com/inmite/android-selector-chapek</a>  </p>
</li>
<li><p>Android Action Bar Style Generator<br>Android ActionBar 样式生成器，可在线选择 ActionBar 样式自动生成所需要的图片资源及 xml 文件<br>项目地址：<a href="https://github.com/jgilfelt/android-actionbarstylegenerator" target="_blank" rel="noopener">https://github.com/jgilfelt/android-actionbarstylegenerator</a><br>在线演示：<a href="http://jgilfelt.github.io/android-actionbarstylegenerator/" target="_blank" rel="noopener">http://jgilfelt.github.io/android-actionbarstylegenerator/</a>  </p>
</li>
<li><p>ButterKnifeZelezny<br>用于快速生成<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">ButterKnife</a>View 注入代码的 Android Studio/IDEA 插件<br>项目地址：<a href="https://github.com/inmite/android-butterknife-zelezny" target="_blank" rel="noopener">https://github.com/inmite/android-butterknife-zelezny</a>  </p>
</li>
<li><p>RoboCoP<br>利用 Gradle task 根据固定格式的 json 文件生成 ContentProvider<br>项目地址：<a href="https://github.com/mediarain/RoboCoP" target="_blank" rel="noopener">https://github.com/mediarain/RoboCoP</a>  </p>
</li>
<li><p>appiconsizes<br>用于生成各个分辨率的图片<br>项目地址：<a href="http://www.appiconsizes.com/" target="_blank" rel="noopener">http://www.appiconsizes.com/</a>  </p>
</li>
<li><p>AndroidUtiles<br>集合了所有常用的安卓工具类<br>项目地址：<a href="https://github.com/l123456789jy/Lazy" target="_blank" rel="noopener">https://github.com/l123456789jy/Lazy</a></p>
</li>
</ol>
<ol>
<li><p>Gradle Retrolambda Plugin<br><a href="https://github.com/orfjackal/retrolambda" target="_blank" rel="noopener">Retrolambda</a>是将 Java8 的 Lambdas 应用于 Java7 的工具，本项目是 Gradle 插件，通过 Retrolambda 从而使 Java 或 Android 项目用 Java8 的 Lambdas 编写，将编译后的字节码转换为 Java6 和 7 的字节码从而正常运行<br>项目地址：<a href="https://github.com/evant/gradle-retrolambda" target="_blank" rel="noopener">https://github.com/evant/gradle-retrolambda</a>  </p>
</li>
<li><p>Dagger IntelliJ Plugin<br>dagger 的 intellij 插件<br>项目地址：<a href="https://github.com/square/dagger-intellij-plugin" target="_blank" rel="noopener">https://github.com/square/dagger-intellij-plugin</a>  </p>
</li>
<li><p>Android Gen Drawable Maven plugin<br>在编译时根据 SVG 描述文件生成不同分辨率的 jpg、png 或点 9 图片<br>项目地址：<a href="https://github.com/avianey/androidgendrawable-maven-plugin" target="_blank" rel="noopener">https://github.com/avianey/androidgendrawable-maven-plugin</a>  </p>
</li>
<li><p>Android Asset Studio<br>各种 Android 资源自动生成器，包括启动图标、ActionBar 图标、通知栏图标、点 9 等<br>项目地址：<a href="https://github.com/romannurik/AndroidAssetStudio" target="_blank" rel="noopener">https://github.com/romannurik/AndroidAssetStudio</a><br>在线演示：<a href="http://romannurik.github.io/AndroidAssetStudio/" target="_blank" rel="noopener">http://romannurik.github.io/AndroidAssetStudio/</a>  </p>
</li>
<li><p>jsonschema2pojo<br>根据 Json 内容生成 java 对象，支持 jackjson 和 gson<br>项目地址：<a href="https://github.com/joelittlejohn/jsonschema2pojo" target="_blank" rel="noopener">https://github.com/joelittlejohn/jsonschema2pojo</a><br>在线演示：<a href="http://www.jsonschema2pojo.org/" target="_blank" rel="noopener">http://www.jsonschema2pojo.org/</a>  </p>
</li>
<li><p>GsonFormat<br>根据 JSONObject 格式的字符串,自动生成实体类参数的 Android Studio/IntelliJ IDEA 插件<br>项目地址：<a href="https://github.com/zzz40500/GsonFormat" target="_blank" rel="noopener">https://github.com/zzz40500/GsonFormat</a><br>效果图：<img src="https://camo.githubusercontent.com/fbf4b89e2ec64e80d351f725d11762ebd2b7a515/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f3136363836362d303766333038346262363735386566612e676966" alt="Renderings">  </p>
</li>
<li><p>Json2Class<br>根据Json生成Java文件的Android Studio/IntelliJ IDEA 插件，并且可以选择Parcelable或者Serializable<br>项目地址：<a href="https://github.com/anzewei/Json2Class" target="_blank" rel="noopener">https://github.com/anzewei/Json2Class</a><br>效果图：<img src="https://raw.githubusercontent.com/anzewei/Json2Class/master/screenshot/screenshot_15002.png" alt="Renderings">  </p>
</li>
<li><p>9-Patch-Resizer<br>自动生成 png 及点 9 图片的不同分辨率版本<br>项目地址：<a href="https://github.com/redwarp/9-Patch-Resizer" target="_blank" rel="noopener">https://github.com/redwarp/9-Patch-Resizer</a>  </p>
</li>
<li><p>AndroidLocalizationer<br>可用于将项目中的 string 资源自动翻译为其他语言的 Android Studio/IntelliJ IDEA 插件<br>项目地址：<a href="https://github.com/westlinkin/AndroidLocalizationer" target="_blank" rel="noopener">https://github.com/westlinkin/AndroidLocalizationer</a>  </p>
</li>
<li><p>Material Palette<br>一个将现有的色彩方案组合成材料设计的调色板方案，提供下载。选取两个主要色彩后便可以提供下载，提供下载的格式可以是 android 的资源 xml 文件，以色彩的方式提供，也可以是 CSS、SVG、PNG 等常见格式文件。<br>项目地址：<a href="http://www.materialpalette.com/" target="_blank" rel="noopener">http://www.materialpalette.com/</a>  </p>
</li>
</ol>
<h4 id="二、开发自测相关"><a href="#二、开发自测相关" class="headerlink" title="二、开发自测相关"></a>二、开发自测相关</h4><ol>
<li><p>Quality Tools for Android<br>Android 测试及自测工具集合和示例<br>项目地址：<a href="https://github.com/stephanenicolas/Quality-Tools-for-Android" target="_blank" rel="noopener">https://github.com/stephanenicolas/Quality-Tools-for-Android</a>  </p>
</li>
<li><p>android-test-kit<br>Google 的 Android 测试工具<br>包括 GoogleInstrumentationTestRunner(增强版的 InstrumentationTestRunner)和 Espresso(用于快速写出可靠测试用例的 API)<br>项目地址：<a href="https://code.google.com/p/android-test-kit/" target="_blank" rel="noopener">https://code.google.com/p/android-test-kit/</a><br>文档介绍：<a href="https://code.google.com/p/android-test-kit/w/list" target="_blank" rel="noopener">https://code.google.com/p/android-test-kit/w/list</a>  </p>
</li>
<li><p>robolectric<br>测试用例编写框架<br>项目地址：<a href="https://github.com/robolectric/robolectric" target="_blank" rel="noopener">https://github.com/robolectric/robolectric</a><br>Demo 地址：<a href="https://github.com/robolectric/robolectricsample" target="_blank" rel="noopener">https://github.com/robolectric/robolectricsample</a><br>文档介绍：<a href="http://robolectric.org/" target="_blank" rel="noopener">http://robolectric.org/</a><br>特点：(1). 不需要模拟器在一般 JVM 就可以运行测试用例<br>(2). 能完成在真机上的大部分测试包括感应器<br>其他的测试用例及相关模块 Mock 可见：<a href="https://code.google.com/p/android-mock/" target="_blank" rel="noopener">android-mock</a>, <a href="https://code.google.com/p/mockito/" target="_blank" rel="noopener">mockito</a>, <a href="https://github.com/easymock/easymock" target="_blank" rel="noopener">easy-mock</a>  </p>
</li>
<li><p>Android FEST<br>提供一些列方便的断言，可用于提高编写 Android 自测代码效率<br>项目地址：<a href="https://github.com/square/fest-android" target="_blank" rel="noopener">https://github.com/square/fest-android</a>  </p>
</li>
<li><p>BoundBox<br>可用于测试类各种访问权限的属性、方法。实际是通过 BoundBox 这个 annotation 生成一个属性和方法都是 public 权限的中间类并对此类进行测试完成的<br>项目地址：<a href="https://github.com/stephanenicolas/boundbox" target="_blank" rel="noopener">https://github.com/stephanenicolas/boundbox</a>  </p>
</li>
<li><p>Hugo<br>用于打印函数信息及执行时间的工具，仅在 debug 模式生效<br>项目地址：<a href="https://github.com/JakeWharton/hugo" target="_blank" rel="noopener">https://github.com/JakeWharton/hugo</a>  </p>
</li>
<li><p>scalpel<br>在应用下面添加一层用于界面调试<br>项目地址：<a href="https://github.com/JakeWharton/scalpel" target="_blank" rel="noopener">https://github.com/JakeWharton/scalpel</a>  </p>
</li>
<li><p>Android Screenshot library<br>Android 截图工具类，用于在持续集成时截图<br>项目地址：<a href="https://github.com/rtyley/android-screenshot-lib" target="_blank" rel="noopener">https://github.com/rtyley/android-screenshot-lib</a>  </p>
</li>
<li><p>sonar-android-lint-plugin<br>将 android lint 的错误在 sonar 中展现<br>项目地址：<a href="https://github.com/SonarCommunity/sonar-android" target="_blank" rel="noopener">https://github.com/SonarCommunity/sonar-android</a>  </p>
</li>
</ol>
<h4 id="三、测试工具"><a href="#三、测试工具" class="headerlink" title="三、测试工具"></a>三、测试工具</h4><ol>
<li><p>Spoon<br>可用于 android 不同机型设备自动化测试，能将应用 apk 和测试 apk 运行在不同机器上并生成相应测试报告。<br>项目地址：<a href="https://github.com/square/spoon" target="_blank" rel="noopener">https://github.com/square/spoon</a>  </p>
</li>
<li><p>Tencent APT<br>APT 是腾讯开源的一个 Android 平台高效性能测试组件，提供丰富实用的功能，适用于开发自测、定位性能瓶颈；测试人员完成性能基准测试、竞品对比测试<br>项目地址：<a href="https://github.com/stormzhang/APT" target="_blank" rel="noopener">https://github.com/stormzhang/APT</a>  </p>
</li>
<li><p>Emmagee<br>网易开源的性能测试工具，包括 CPU、内存、网络流量、启动时间、电池状态等<br>项目地址：<a href="https://github.com/NetEase/Emmagee" target="_blank" rel="noopener">https://github.com/NetEase/Emmagee</a>  </p>
</li>
<li><p>Android py-uiautomator<br>py-uiautomator 是一个对 Android uiautomator 用 python 进行封装的测试框架.<br>项目地址：<a href="https://github.com/xiaocong/uiautomator" target="_blank" rel="noopener">https://github.com/xiaocong/uiautomator</a>  </p>
</li>
<li><p>Augmented Traffic Control<br>模拟网络状况，包括带宽、时延抖动、丢包率、错包率、包重排率<br>项目地址：<a href="https://github.com/facebook/augmented-traffic-control" target="_blank" rel="noopener">https://github.com/facebook/augmented-traffic-control</a>  </p>
</li>
<li><p>stetho<br>强大的 Android Debug 工具。支持网络请求监控以及数据库查看，可以和 Chrome DevTools 结合或者命令行模式。<br>项目地址：<a href="https://github.com/facebook/stetho" target="_blank" rel="noopener">https://github.com/facebook/stetho</a>  </p>
</li>
</ol>
<h4 id="四、开发及编译环境"><a href="#四、开发及编译环境" class="headerlink" title="四、开发及编译环境"></a>四、开发及编译环境</h4><ol>
<li><p>Buck<br>facebook 开源的 Android 编译工具，效率是 ant 的两倍。主要优点在于：<br>(1) 加快编译速度，通过并行利用多核 cpu 和跟踪不变资源减少增量编译时间实现<br>(2) 可以在编译系统中生成编译规则而无须另外的系统生成编译规则文件<br>(3) 编译同时可生成单元测试结果<br>(4) 既可用于 IDE 编译也可用于持续集成编译<br>(5) facebook 持续优化中<br>项目地址：<a href="https://github.com/facebook/buck" target="_blank" rel="noopener">https://github.com/facebook/buck</a>  </p>
</li>
<li><p>Android Maven Plugin<br>Android Maven 插件，可用于对 android 三方依赖进行管理。在 J2EE 开发中，maven 是非常成熟的依赖库管理工具，可统一管理依赖库。<br>项目地址：<a href="https://github.com/jayway/maven-android-plugin" target="_blank" rel="noopener">https://github.com/jayway/maven-android-plugin</a>  </p>
</li>
<li><p>umeng-muti-channel-build-tool<br>渠道打包工具<br>项目地址：<a href="https://github.com/umeng/umeng-muti-channel-build-tool" target="_blank" rel="noopener">https://github.com/umeng/umeng-muti-channel-build-tool</a><br>另可参见 Google 的构建系统 Gradle：<a href="http://tools.android.com/tech-docs/new-build-system/user-guide" target="_blank" rel="noopener">http://tools.android.com/tech-docs/new-build-system/user-guide</a>  </p>
</li>
<li><p>Genymotion<br>目前最好用最快的 android 模拟器<br>项目地址：<a href="http://www.genymotion.com/" target="_blank" rel="noopener">http://www.genymotion.com/</a><br>Android studio 集成控件： <a href="http://plugins.jetbrains.com/plugin/7269?pr=idea" target="_blank" rel="noopener">http://plugins.jetbrains.com/plugin/7269?pr=idea</a><br>Cyril Mottier 推荐：<a href="http://cyrilmottier.com/2013/06/27/a-productive-android-development-environment/" target="_blank" rel="noopener">http://cyrilmottier.com/2013/06/27/a-productive-android-development-environment/</a>  </p>
</li>
<li><p>gradle-mvn-push<br>方便的将 Gradle 的 Artifacts 上传到 Maven 仓库<br>项目地址：<a href="https://github.com/chrisbanes/gradle-mvn-push" target="_blank" rel="noopener">https://github.com/chrisbanes/gradle-mvn-push</a><br>文档介绍：<a href="https://github.com/chrisbanes/gradle-mvn-push#usage" target="_blank" rel="noopener">https://github.com/chrisbanes/gradle-mvn-push#usage</a>  </p>
</li>
<li><p>Android Emulator Plugin for Jenkins<br>Android 模拟器 jenkins 插件，用于 Jenkins 做持续集成时跑模拟器测试<br>项目地址：<a href="https://github.com/jenkinsci/android-emulator-plugin" target="_blank" rel="noopener">https://github.com/jenkinsci/android-emulator-plugin</a>  </p>
</li>
<li><p>Android Maven Plugin<br>管理应用所需要的依赖库。包括的构建工具有 Maven、Gradle、ant、sbt<br>项目地址：<a href="https://github.com/mosabua/maven-android-sdk-deployer" target="_blank" rel="noopener">https://github.com/mosabua/maven-android-sdk-deployer</a>  </p>
</li>
<li><p>SDK Manager Plugin<br>下载和管理 Android SDK 的 Gradle 插件<br>项目地址：<a href="https://github.com/JakeWharton/sdk-manager-plugin" target="_blank" rel="noopener">https://github.com/JakeWharton/sdk-manager-plugin</a>  </p>
</li>
<li><p>Gradle Protobuf Plugin<br>将.proto 文件转换成 Java 文件的 gradle 插件<br>项目地址：<a href="https://github.com/andrewkroh/gradle-protobuf-plugin" target="_blank" rel="noopener">https://github.com/andrewkroh/gradle-protobuf-plugin</a>  </p>
</li>
<li><p>ChromeADB<br>Chrome 的 Adb 插件，当登录后，能看到所有连接的设备并操作，可以看应用、进程、内存及磁盘使用情况等<br>项目地址：<a href="https://github.com/importre/chromeadb" target="_blank" rel="noopener">https://github.com/importre/chromeadb</a>  </p>
</li>
</ol>
<h4 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h4><ol>
<li><p>GT<br>APP的随身调试平台，它是直接运行在手机上的“集成调试环境”(IDTE, Integrated Debug Environment)。<br>项目地址：<a href="https://github.com/TencentOpen/GT" target="_blank" rel="noopener">https://github.com/TencentOpen/GT</a><br>文档介绍：<a href="http://gt.qq.com/docs.html" target="_blank" rel="noopener">http://gt.qq.com/docs.html</a>  </p>
</li>
<li><p>ViewServer<br>允许 app 运行在任何手机上都可以用 HierarchyViewer 查看<br>项目地址：<a href="https://github.com/romainguy/ViewServer" target="_blank" rel="noopener">https://github.com/romainguy/ViewServer</a>  </p>
</li>
<li><p>GridWichterle for Android<br>在整个系统上显示一个 grid，用来帮助查看应用布局及使得布局更美观，可设置 grid 网格大小和颜色，android 推荐 48dp 和 8dp，可见 Android Design Guidelines – Metrics and Grids，比起 hierarchyviewer 相差甚远，不过偶尔可用来作为布局查看工具。<br>项目地址：<a href="https://github.com/inmite/android-grid-wichterle" target="_blank" rel="noopener">https://github.com/inmite/android-grid-wichterle</a><br>Demo 地址：<a href="https://play.google.com/store/apps/details?id=eu.inmite.android.gridwichterle" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=eu.inmite.android.gridwichterle</a>  </p>
</li>
<li><p>Catlog<br>手机端 log 查看工具，支持不同颜色显示、关键字过滤、级别过滤、进程 id 过滤、录制功能等<br>项目地址：<a href="https://github.com/nolanlawson/Catlog" target="_blank" rel="noopener">https://github.com/nolanlawson/Catlog</a><br>在线演示：<a href="https://play.google.com/store/apps/details?id=com.nolanlawson.logcat" target="_blank" rel="noopener">https://play.google.com/store/apps/details?id=com.nolanlawson.logcat</a>  </p>
</li>
<li><p>PID Cat<br>根据 package 查看 logcat 日志<br>项目地址：<a href="https://github.com/JakeWharton/pidcat" target="_blank" rel="noopener">https://github.com/JakeWharton/pidcat</a>  </p>
</li>
<li><p>ACRA<br>应用崩溃信息日志上报到 GoogleDoc 工具，网页版展现结果三方开源地址 <a href="https://github.com/BenoitDuffez/crashreportsviewer" target="_blank" rel="noopener">https://github.com/BenoitDuffez/crashreportsviewer</a><br>项目地址：<a href="https://github.com/ACRA/acra" target="_blank" rel="noopener">https://github.com/ACRA/acra</a><br>文档介绍：<a href="https://github.com/ACRA/acra/wiki/BasicSetup" target="_blank" rel="noopener">https://github.com/ACRA/acra/wiki/BasicSetup</a>  </p>
</li>
<li><p>Crashlytics<br>提供丰富的应用崩溃信息日志收集<br>轻量级，丰富，可自定义应用崩溃信息收集器，附有邮件通知<br>项目地址：<a href="http://www.crashlytics.com/" target="_blank" rel="noopener">http://www.crashlytics.com/</a><br>集成插件：<a href="http://try.crashlytics.com/sdk-android/?utm_source=blog&utm_medium=blog&utm_campaign=Announcing_android_studio_wp&utm_content=CTA_button" target="_blank" rel="noopener">Android Studio, Eclipse and IntelliJ</a>  </p>
</li>
<li><p>Android Resource Navigator<br>chrome 插件，可以方便的查看 github 上 android 源码工程的 styles.xml 和 themes.xml。主要功能：<br>(1) 快速打开 android styles.xml themes.xml<br>(2) 方便在资源间跳转。styles.xml themes.xml 文件中资源链接跳转，可以方便跳转到某个资源<br>(3) 方便查找某个 style 和 theme。chrome 地址栏输入 arn+tab+搜索内容回车即可<br>(4) 自动下载不同分辨率下的 drawable<br>(5) 通过映射查找那些不是按照固定命名规则命名的 style 和 theme<br>项目地址：<a href="https://github.com/jgilfelt/android-resource-navigator" target="_blank" rel="noopener">https://github.com/jgilfelt/android-resource-navigator</a><br>在线演示：<a href="https://chrome.google.com/webstore/detail/android-resource-navigato/agoomkionjjbejegcejiefodgbckeebo?hl=en&amp;gl=GB" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/android-resource-navigato/agoomkionjjbejegcejiefodgbckeebo?hl=en&amp;gl=GB</a>  </p>
</li>
<li><p>android-resource-remover<br>根据 lint 的提示删除项目中无用的资源，减少包的大小<br>项目地址：<a href="https://github.com/KeepSafe/android-resource-remover" target="_blank" rel="noopener">https://github.com/KeepSafe/android-resource-remover</a>  </p>
</li>
<li><p>Telescope<br>通过手势截图以特定主题发送到特定邮箱地址报告 Bug<br>项目地址：<a href="https://github.com/mattprecious/telescope" target="_blank" rel="noopener">https://github.com/mattprecious/telescope</a>  </p>
</li>
<li><p>Complete Android Fragment &amp; Activity Lifecycle<br>完整的 Android Fragment/Activity 生命周期图<br>项目地址：<a href="https://github.com/xxv/android-lifecycle" target="_blank" rel="noopener">https://github.com/xxv/android-lifecycle</a>  </p>
</li>
<li><p>Bugsnag Notifier for Android<br>通过<code>Thread.UncaughtExceptionHandler</code>捕获应用未处理的异常崩溃 Bug 并用 Notification 展示同时上传到后台服务器<br>项目地址：<a href="https://github.com/bugsnag/bugsnag-android" target="_blank" rel="noopener">https://github.com/bugsnag/bugsnag-android</a><br>文档介绍：<a href="https://github.com/bugsnag/bugsnag-android#installation--setup" target="_blank" rel="noopener">https://github.com/bugsnag/bugsnag-android#installation--setup</a>  </p>
</li>
<li><p>Material Design Icons<br>Google Material Design 规范中的 Icon<br>项目地址：<a href="https://github.com/google/material-design-icons" target="_blank" rel="noopener">https://github.com/google/material-design-icons</a>  </p>
</li>
<li><p>scrollscreenshot<br>Android 滚动屏幕自动截图 jar 包，支持纵向、横向滚动截屏拼接<br>项目地址：<a href="https://github.com/PGSSoft/scrollscreenshot" target="_blank" rel="noopener">https://github.com/PGSSoft/scrollscreenshot</a><br>效果图：<img src="https://github.com/PGSSoft/scrollscreenshot/raw/master/samplehorizontal.png" alt="Renderings">  </p>
</li>
<li><p>droidicon<br>1600+的海量 Icon，包括 750+的 Material Design icons<br>项目地址：<a href="https://github.com/theDazzler/droidicon" target="_blank" rel="noopener">https://github.com/theDazzler/droidicon</a>  </p>
</li>
<li><p>leakcanary<br>Android 内存泄露检测工具，集成方便，出现泄露后报告直观<br>项目地址：<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">https://github.com/square/leakcanary</a><br>效果图：<img src="https://github.com/square/leakcanary/blob/master/assets/screenshot.png" alt="Renderings">  </p>
</li>
<li><p>CacheUtilsLibrary<br>将任何Java Object类型的数据序列化后写入缓存文件，将来使用时读取缓存文件并反序列化成对应Java Object的库<br>项目地址：<a href="https://github.com/westlinkin/CacheUtilsLibrary" target="_blank" rel="noopener">https://github.com/westlinkin/CacheUtilsLibrary</a></p>
</li>
<li><p>BlockCanary<br>BlockCanary是一个Android平台的一个非侵入式的性能监控组件，应用只需要实现一个抽象类，提供一些该组件需要的上下文环境，就可以在平时使用应用的时候检测主线程上的各种卡慢问题，并通过组件提供的各种信息分析出原因并进行修复。<br>项目地址: <a href="https://github.com/moduth/blockcanary" target="_blank" rel="noopener">https://github.com/moduth/blockcanary</a>  </p>
</li>
</ol>
<h2 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h2><p>主要介绍那些乐于分享并且有一些很不错的开源项目的个人和组织。Follow 大神，深挖大神的项目和 following，你会发现很多。  </p>
<h4 id="一、个人"><a href="#一、个人" class="headerlink" title="一、个人"></a>一、个人</h4><ol>
<li><p>JakeWharton<br>现就职于 Google，（曾就职于 Square），绝对牛逼的大神，项目主要集中在 Android 版本兼容，ViewPager 及开发工具上<br>Github 地址：<a href="https://github.com/JakeWharton" target="_blank" rel="noopener">https://github.com/JakeWharton</a><br>代表作：ActionBarSherlock，Android-ViewPagerIndicator，Nine Old Androids，SwipeToDismissNOA，hugo，butterknife，Android-DirectionalViewPager, scalpel<br>pidcat 另外对 square 及其他开源项目有很多贡献<br>主页：<a href="http://jakewharton.com/" target="_blank" rel="noopener">http://jakewharton.com/</a>  </p>
</li>
<li><p>Chris Banes<br>Github 地址：<a href="https://github.com/chrisbanes" target="_blank" rel="noopener">https://github.com/chrisbanes</a><br>代表作：ActionBar-PullToRefresh，PhotoView，Android-BitmapCache，Android-PullToRefresh<br>主页：<a href="http://chris.banes.me/" target="_blank" rel="noopener">http://chris.banes.me/</a>  </p>
</li>
<li><p>Koushik Dutta<br>就职于 ClockworkMod<br>Github 地址：<a href="https://github.com/koush" target="_blank" rel="noopener">https://github.com/koush</a><br>代表作：Superuser，AndroidAsync，UrlImageViewHelper，ion, 另外对 <a href="https://github.com/CyanogenMod" target="_blank" rel="noopener">https://github.com/CyanogenMod</a> 的开源项目有很多贡献<br>主页：<a href="http://koush.com/" target="_blank" rel="noopener">http://koush.com/</a>  </p>
</li>
<li><p>Simon Vig<br>Github 地址：<a href="https://github.com/SimonVT" target="_blank" rel="noopener">https://github.com/SimonVT</a><br>代表作：android-menudrawer，MessageBar<br>主页：<a href="http://simonvt.net/" target="_blank" rel="noopener">http://simonvt.net/</a>  </p>
</li>
<li><p>Manuel Peinado<br>Github 地址：<a href="https://github.com/ManuelPeinado" target="_blank" rel="noopener">https://github.com/ManuelPeinado</a><br>代表作：FadingActionBar，GlassActionBar，RefreshActionItem，QuickReturnHeader  </p>
</li>
<li><p>Emil Sj?lander<br>Github 地址：<a href="https://github.com/emilsjolander" target="_blank" rel="noopener">https://github.com/emilsjolander</a><br>代表作：StickyListHeaders，sprinkles，android-FlipView<br>主页：<a href="http://emilsjolander.se/" target="_blank" rel="noopener">http://emilsjolander.se/</a>  </p>
</li>
<li><p>greenrobot<br>Github 地址：<a href="https://github.com/greenrobot" target="_blank" rel="noopener">https://github.com/greenrobot</a><br>代表作：greenDAO，EventBus<br>主页：<a href="http://greenrobot.de/" target="_blank" rel="noopener">http://greenrobot.de/</a>  </p>
</li>
<li><p>Jeff Gilfelt<br>Github 地址：<a href="https://github.com/jgilfelt" target="_blank" rel="noopener">https://github.com/jgilfelt</a><br>代表作：android-mapviewballoons，android-viewbadger，android-actionbarstylegenerator，android-sqlite-asset-helper<br>主页：<a href="http://jeffgilfelt.com" target="_blank" rel="noopener">http://jeffgilfelt.com</a>  </p>
</li>
<li><p>Romain Guy<br>Android team 成员(2013.10 已离开 Android team，仍在 Google)<br>Github 地址：<a href="https://github.com/romainguy" target="_blank" rel="noopener">https://github.com/romainguy</a><br>代表作：ViewServer<br>主页：<a href="http://www.curious-creature.org/category/android/" target="_blank" rel="noopener">http://www.curious-creature.org/category/android/</a><br>個人攝影作品：<a href="http://www.flickr.com/photos/romainguy" target="_blank" rel="noopener">http://www.flickr.com/photos/romainguy</a>  </p>
</li>
<li><p>sephiroth74<br>就职于 Aviary.com<br>Github 地址：<a href="https://github.com/sephiroth74" target="_blank" rel="noopener">https://github.com/sephiroth74</a><br>代表作：ImageViewZoom，HorizontalVariableListView，AndroidWheel，purePDF<br>主页：<a href="http://www.sephiroth.it/" target="_blank" rel="noopener">http://www.sephiroth.it/</a>  </p>
</li>
<li><p>Cyril Mottier<br>Google 开发者专家认证，发布一些 Android 技巧及文章<br>Github 地址：<a href="https://github.com/cyrilmottier" target="_blank" rel="noopener">https://github.com/cyrilmottier</a><br>代表作：GreenDroid，Polaris<br>主页：<a href="http://cyrilmottier.com/" target="_blank" rel="noopener">http://cyrilmottier.com/</a>  </p>
</li>
</ol>
<h4 id="二、组织"><a href="#二、组织" class="headerlink" title="二、组织"></a>二、组织</h4><ol>
<li><p>Square<br>有态度有良心的企业，很多不错的分享<br>Github 地址：<a href="https://github.com/square" target="_blank" rel="noopener">https://github.com/square</a><br>代表作：okhttp、fest-android，android-times-square、picasso、dagger、spoon 等等<br>主页：<a href="http://square.github.io/" target="_blank" rel="noopener">http://square.github.io/</a>  </p>
</li>
<li><p>Inmite s.r.o.<br>Github 地址：<a href="https://github.com/inmite" target="_blank" rel="noopener">https://github.com/inmite</a><br>代表作：android-styled-dialogs，android-grid-wichterle，android-selector-chapek<br>主页：<a href="http://www.inmite.eu/" target="_blank" rel="noopener">http://www.inmite.eu/</a>  </p>
</li>
</ol>
<h4 id="三、博客"><a href="#三、博客" class="headerlink" title="三、博客"></a>三、博客</h4><p><a href="https://github.com/android-cn/android-dev-com" target="_blank" rel="noopener">部分国外著名 Android 开发者信息</a>  </p>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><pre><code>Copyright 2014 [trinea.cn](http://www.trinea.cn/)

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</code></pre>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android项目汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>六度空间理论：通过六个人你就能够认识任何一个陌生人</title>
    <url>/2017/12/24/liudukongjian/</url>
    <content><![CDATA[<h2 id="SNS是什么意思"><a href="#SNS是什么意思" class="headerlink" title="SNS是什么意思"></a>SNS是什么意思</h2><p>SNS有两种解释：<br>1、SNS(Social Networking Services)即社会性网络服务，专指旨在帮助人们建立社会性网络的互联网应用服务。也应加上目前社会现有已成熟普及的信息载体，如短信SMS服务。<br>2、SNS（Social Network Site）即“社交网站”或“社交网”。<br>SNS是根据六度分割理论，创立的面向社会性网络的互联网服务，通过“熟人的熟人”来进行网络社交拓展。但现在一般所谓的SNS，其含义已经大大扩展。</p>
<a id="more"></a>

<h2 id="什么是六度空间理论"><a href="#什么是六度空间理论" class="headerlink" title="什么是六度空间理论"></a>什么是六度空间理论</h2><p>什么是六度空间理论（Six Degrees of Separation），它是数学领域的一个猜想，名为Six Degrees of Separation，中文翻译包括以下几种： 六度空间理论、六度分隔理论、六度分割理论或叫作小世界理论等。</p>
<p>六度空间理论指出：你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过六个人你就能够认识任何一个陌生人。这就是六度空间理论，也叫小世界理论。</p>
<p>六度分隔的现象，并不是说任何人与人之间的联系都必须要通过六个层次才会产生联系，而是表达了这样一个重要的概念：任何两位素不相识的人之间，通过一定的联系方式，总能够产生必然联系或关系。显然，随着联系方式和联系能力的不同，实现个人期望的机遇将产生明显的区别。</p>
<p>小世界现象(又称小世界效应)假设世界上所有互不相识的人只需要很少中间人就能建立起联系。后来1967年哈佛大学的心理学教授斯坦利·米尔格拉姆（Stanley Milgram，1933年—1984年）根据这概念做过一次连锁信实验，尝试证明平均只需六个人就可以联系任何两个互不相识的美国人。</p>
<hr>
<h2 id="米尔格伦连锁信实验"><a href="#米尔格伦连锁信实验" class="headerlink" title="米尔格伦连锁信实验"></a>米尔格伦连锁信实验</h2><p>【实验经过】米尔格伦的研究本来在无特定的市民大众进行，而不是在专业的、需要高度合作的数学界及演艺界进行（参见下）。然而仍遭受不少抨击。于首次连锁信实验（纪录于未注明日期论文”Results of Communication Project”），米尔格伦寄出六十封信给堪萨斯州威奇塔市自愿参加者，请他们转交到麻萨诸塞州剑桥市某指定地点的股票经纪人。 参加者只能把信交给他认为有可能把信送到目的地的熟人，可以亲自送或者通过他的朋友。虽然有50个人参与了实验，但组中只有三封信送到了目的地。 当信传到第五个人手上时，只有三封信抵达了目的地。米尔格伦在他1967年的那篇著名论文中提到在最初的试验中，其中的一封信在不到四天的时间内，就被传达到了目的地，但是他却忽略了一个重要事实，那就是实际上只有不到5%的信件最终被送达了。在随后两次连锁信实验，因完成连锁的比例太低，实验结果未被发表。但是幸运的是，研究者发现很多微妙的因素会对连锁信实验的结果产生极大的影响。研究者尝试在不同种族和不同收入人群中来重复实验，他们发现巨大的差异。事实上，在米尔格伦合著的一篇论文中揭示如果信件的最终接受者为黑人，实验的送达率为13%，而如果是白人，则送达率上升为33%，尽管实验者开始的时候并不知道接受者的种族。</p>
<p>【发现】虽然饱受议论，米尔格伦带来不少新奇的发现。经过多次改良实验，米尔格伦发现信件或包裹在人们心目中的价值是影向人们决定继续传递它的重要因素。他成功将送达率提升至35%， 以至于后来更上升为97%。抛开对“地球是很小的”这样论断的怀疑不说，人们对“某个特定世界是很小”的论断是没有丝毫怀疑的（例如：从某个学院到密西根大学到蒙特利尔犹太人社区。 平均来看，为实现一次送达，需要六个中间人从而得出了六度分隔理论的说法（Six Degrees of Separation)，他可能源于六个自由度的说法 (Six Degrees of Freedom)。不仅如此，米尔格伦还发现了漏斗效应， 他发现大部分的传递都是由那些极少数的明星人物完成的。在一个5%的飞行员实验中，他发现2/3成功的传递是由同一些“明星”来完成的。</p>
<p>尽管如此，这个实验仍然存在着一个具有挑战性的假设：它假设传递链条中所有的实验者都完全有能力发掘链条终端的两个人传递的有效性。</p>
<p>【数学解释1】若每个人平均认识260人，其六度就是260的6次方 ＝308,915,776,000,000（约300万亿）。消除一些节点重复，那也几乎覆盖了整个地球人口若干多多倍。</p>
<p>公式可以进一步抽象成：n=log(N)/log(W)，其中n表示复杂度，N表示人的总数，W表示每个人的联系宽度。</p>
<p>【数学解释2】两个人之间由六个人介绍，那么他们一定是通过了七次介绍，现在世界人口是65亿，我对65亿开七次方根，结果是25.2257，我们就算26个，那么如果满足六度空间的结论，每个人至少和社会中的26个人有联系—-至少是可以介绍的那种。 26个联系，我觉得是个非常保守的数字：学校里每个班的学生就有50多个，一个人的亲属也有20多个，再加上同事，100个应该是有的。所以六度空间的结论是值得相信的。 而如果按照26个联系去计算，五度空间可以覆盖的人群大约是3亿，四度空间是1千万。日本人口约为1.3亿，所以两个日本人之间只需要5个人去介绍，成都人口是1千万，两个成都人之间只需要4个人去介绍。</p>
<p>【涵义】这种现象，并不是说任何人与人之间的联系都必须要通过六个层次才会产生联系，而是表达了这样一个重要的概念：任何两位素不相识的人之间，通过一定的联系方式，总能够产生必然联系或关系。显然，随着联系方式和联系能力的不同，实现个人期望的机遇将产生明显的区别。</p>
<p>社会网络其实并不高深，它的理论基础正是“六度分割”。而社会性软件则是建立在真实的社会网络上的增值性软件和服务。有这么一个故事，几年前一家德国报纸接受了一项挑战，要帮法兰克福的一位土耳其烤肉店老板，找到他和他最喜欢的影星马龙·白兰度的关联。结果经过几个月，报社的员工发现，这两个人只经过不超过六个人的私交，就建立了人脉关系。原来烤肉店老板是伊拉克移民，有个朋友住在加州，刚好这个朋友的同事，是电影《这个男人有点色》的制作人的女儿在女生联谊会的结拜姐妹的男朋友，而马龙·白兰度主演了这部片子。</p>
<p>【价值】不管理论如何深奥，“六度分割”和互联网的亲密结合，已经开始显露出商业价值。人们在近几年越来越关注社会网络的研究，很多网络软件也开始支持人们建立更加互信和紧密的社会关联，这些软件被统称为“社会性软件” （Social Software）。例如Blog就是一种社会性软件，因为Blog写作所需要的个性和延续性，已使Blogger圈这种典型的物以类聚的生态形式，越来越象真实生活中的人际圈。据致力于研究社会软件的毛向辉介绍，国外现在更流行的是一种快速交友，或者商业联系的工具，例如LinkedIN。人们可以更容易在全球找到和自己有共同志趣的人、更容易发现商业机会、更容易达到不同族群之间的理解和交流，等等。</p>
<p>社会性软件的定义很多，而且还都在不断的发展演变过程之中。它的核心思想其实是一种聚合产生的效应。人、社会、商业都有无数种排列组合的方式，如果没有信息手段聚合在一起，就很容易损耗掉。WWW成功地将文本、图形聚合在一起，使互联网真正走向应用；即时通讯又将人聚合在一起，产生了ICQ这样的工具。然而这还是虚拟的，虚拟虽然是网络世界的一种优势，但是和商业社会所要求的实名、信用隔着一条鸿沟。通过熟人之间，通过“六度分割”产生的聚合，将产生一个可信任的网络，这其中的商业潜能的确是无可估量的。</p>
<p>聚合作为社会研究的对象也具有实际价值。康奈尔大学的科学家开发了一个算法，能够识别一篇文章中某些文字的“突发”增长，而这些“突发”增长的文字可以用来快速识别最新的趋势和热点问题，因此能够更有效地筛选重要信息。过去很多搜索技术都采用了简单计算文字 /词组出现频率的方法，却忽略了文字使用增加的速率。如果这种方法应用到广告商，就可以快速找到潜在的需求风尚。</p>
<p>社会、网络、地域、商业、Blog、sns，这些词汇你也许都听麻木了。然而一旦那些预见先机的人找到聚合它们的商业价值，被改变的绝不仅仅是网络世界。</p>
<hr>
<h2 id="六度空间的残缺"><a href="#六度空间的残缺" class="headerlink" title="六度空间的残缺"></a>六度空间的残缺</h2><p>【权值问题】。首先六度分割肯定了人与人之间的普遍联系，但是没有对这种联系作定量分析。我们一生可能会认识千百人，他们有的对我极其重要，有的对我无足轻重，我们联系建立的原因和方法也是千差万别的。有父母亲属这类生而固有的联系，也有因为地理位置接近发展出来的。如邻里关系，还有因为共同学习生活而发展出来的同学、同事关系。六度分割理论中只把他们统统归结于联系，却没有强弱之分。在网状结构里面，人与人的关系，需要加权处理，在这里，六度分割理论还是残缺的。</p>
<p>【阻尼问题】在Stanley Milgram的实验和火炬的实验里面，都没有任何的花费，或者说看起来成本为0。但是是不是真的成本为0呢？每个人传递一下信件花费极低，改下msn名字更是没有成本，然而那些人肯这么做，其实是看着朋友的面子上，所以这里花费的成本实际是什么呢？是中国人说的人情债，所谓的关系成本。没有人喜欢一个整天都要人帮忙这帮忙那的人，人情债和金钱债一样，背了就一定要还，这就是传递中的成本问题。</p>
<p>Gmail的邀请方式直至今日仍被很多人称颂，刚刚出现的时候，一个邀请甚至可以卖到60美金。很多人惊呼这是最伟大的营销。然而，到了今天，很多人的邀请已经变得无法送出去。为什么呢？因为一开始的时候Gmail是稀缺物品，所以价值高昂，加上Gmail带有Google的强势品牌和高度用户认同感，所以就更加被追捧，拥有Gmail成了荣誉的象征。这是这种荣誉成为了Gmail邀请在六度分割网络中疯狂传播的激励。然而随着Gmail的高度普及，这种荣誉感逐步下降，最终降低了激励，从而使传播陷入了停滞状态。</p>
<p>阻尼是好还是坏？没有阻尼我们可以给任何人发送信息，每个SNS网站都在宣扬你只需要六个人就可以认识克林顿可以认识比尔盖茨，但是有几个人真的去认识他们了？是因为他们不值得认识么？不是，是因为联系虽然看起来只有六度，然而每度的阻尼都有可能都是无法跨越的。但是你不要悲观，如果没有阻尼也许你会更加不爽！</p>
<p>举例来说吧。假设每个人有30个朋友，信息经过六度是30的6次方 =729000000，数量足够到达一个能够覆盖所有可能的人的级别。”，如果六度的连接没有任何的阻尼，估计我们每天收到的来自好友的各种各样的信息就会让我们的脑袋爆炸。</p>
<p>在我们的生活里面，一个身份越高的人，越有名的人他就会有越多的好友，于是他也就越不想随便拓展自己的关系圈子，因为他们往往不胜其扰。如果一瞬间，阻尼消失了，你可以随便打电话给李彦宏、马云、马化腾了，你不是想跟冯小刚聊电影么？你现在可以打电话了。但是，我们只能说这成了一场灾难，很多名人诉苦，说很多人打电话到他们的家里，说了句“你是XXX么？我很喜欢你！”然后就挂了电话。很多人不堪其扰停了机，甚至换了号。</p>
<p>这场灾难对我们这些局外人来说是一个很有意思的故事，一旦这些名人和大众的关系扁平化后（六度变成一度），他们对大众的价值也开始流失，大众们只能打电话过去，问一声，然后炫耀自己给明星打过电话，仅此而已。这个巨大的扁平化工程并没有扩展追星族们的朋友圈子，他们仍旧离那些明星很远……</p>
<p>【目的和结果问题】20世纪60年代，耶鲁大学的社会心理学家米尔格兰姆(Stanley Milgram)就设计了一个连锁信件实验。他将一套连锁信件随机发送给居住在内布拉斯加州奥马哈的160个人，信中放了一个波士顿股票经纪人的名字，信中要求每个收信人将这套信寄给自己认为是比较接近那个股票经纪人的朋友。朋友收信后照此办理。最终，大部分信在经过五、六个步骤后都抵达了该股票经纪人。</p>
<p>六度分割的概念由此而来。这个故事很多六度分割的爱好者都知道，并奉为圣经。但是我请大家注意这个故事和我们现在流行的SNS网站理念的重要差别。在这个故事里面，信到达了波士顿股票经纪人手里面没错，但是请注意整个过程中，每个人的朋友关系都没有发生改变。对，这点很重要，这个故事里面传递的信息，而我们现在看到的SNS网站希望在用户之间传递的是什么呢？是联系方式还是朋友关系?</p>
<p>这个连锁实验，体现了一个似乎很普遍的客观规律：社会化的现代人类社会成员之间，都可能通过“六度分割” 而联系起来，绝对没有联系的A与B是不存在的。这是一个更典型、深刻而且普遍的自然现象。那么，怎样用数学理论揭示 “六度分割”现象？这是现代数学领域又一个重大的数学猜想。</p>
<p>这有点儿像地图的邻接色问题，只不过邻接色问题是通过数学方法可以精确证明的（即最多只需要使用4种颜色即可），而六度分割理论我个人估计只能通过不完全归纳来形成假设了吧，社会的模型还是比二维地图模型要复杂莫测得多。</p>
<hr>
<h2 id="六度空间的应用"><a href="#六度空间的应用" class="headerlink" title="六度空间的应用"></a>六度空间的应用</h2><p>【同名电影】六度分隔理论提出后，引起世人极大关注，同时激发了人们的无限想象力。1990年，戏剧《六度分隔》上演。1993年，基于这部戏剧的同名电影《六度分隔》（Six Degrees of Separation）上映。影片主角的台词包括“我们之间，只需要6个人相连”，“不管是美国总统还是威尼斯的船夫，只要找到正确的6个人，我们就能联系起来”，“我们之间联系如此紧密，这让我感到十分安慰”等等。</p>
<p>【网络中的应用】各种社交型网站，其实质的应用表现为好友的好友，关注的人，被谁关注，共同爱好，好友动态等。网站内游戏中的应用有抢车位，偷菜，好友买卖等游戏。</p>
<p>随着SNS（社会性网络服务）网站的兴起，更多的社交互动创意涌现出来，社会性网络服务的优势逐渐在门户竞争中得以体现。近年来国内网站兴起了一波以SNS为主打的网络风潮，其中具有代表性的有：人人网，开心网，若邻网，白社会，豆瓣，QQzone，六度分割，旅行器，新浪微博等等。这些网站都可以算是国内SNS的典范，值得大家学习。我们以开心网为例。在其推出开心农场之后，这一年多最大的变化莫过于加入了一些看似简单却又耐人寻味的小游戏。这些游戏将我们的现实生活融入网络，特别适合于上班族玩。有人说：是游戏拉近了人与人的距离，这话一点不假。近年来，国内SNS的应用都体现在了效仿facebook而建立起来的互动游戏环节。</p>
<p>站长们可以反驳说：如果真那么神奇，六度分割理论岂不是能让我将所有网络用户吸引过来？那别的网站也效仿这种做法，也吸引了全部网络用户，但不是所有网络用户都同时使用两个网站的系统，这岂不是在理论上就出现矛盾了？当然我们所说的六度分割理论只是一种宏观上对人与人之间连接关系的理解，并不是说通过建立这么一个互动的系统，通过人吸引人，人邀请人，就能够吸引网络上所有的用户。理论结合实际，好的创意加之强大的技术支撑，你的网站距离成功也就不远了。</p>
<hr>
<h2 id="网上各种评论及联想"><a href="#网上各种评论及联想" class="headerlink" title="网上各种评论及联想"></a>网上各种评论及联想</h2><p>【评论】人与人之间的联系并不如人们想象中紧密。而且，拥有一段真挚的友谊比通过一连串人认识某个距离很远的名人要有意义得多。</p>
<p>【评论】由于受教育程度、种族背景等差异，世界并不像人们想象中那么小。</p>
<p>【评论】六度分割虽然是个社会学的理论，但是实际上它更像一个数学理论，很多人说它和四色问题有异曲同工之妙。在我看来，六度分割很好的阐述了一个网状的结构（我们的人类社会），增强了不同节点之间的联系和连接关系，然而它并不完整，也并不足以指导我们的实践。</p>
<p>【联想】其实我们已经在不自觉地使用它，就是现在我们常用的“人肉搜索”，原理有些类似。</p>
<p>【联想】指数运算的确是一种可怕的运算，人们习以为常的几十个经常联系的人，通过指数运算的7次推演居然能联系到世界上的每一个人，形成了这个这个既让人吃惊而又不得不信服的“六度空间”理论。PS：最经典的指数运算，汉诺塔的故事。</p>
<p>【联想】哲学课中有个物质之间存在普遍联系的规律，那时老师讲了很多例子，大家还是感觉很懵懂，如果有六度空间理论去佐证，那就容易理解多了</p>
]]></content>
      <categories>
        <category>六度空间</category>
      </categories>
      <tags>
        <tag>六度空间</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解「墨菲定律」？</title>
    <url>/2017/11/04/mofei/</url>
    <content><![CDATA[<p>墨菲定律（Murphy’s Law），亦称莫非定律、莫非定理、或摩菲定理，是西方世界常用的俚语。墨菲定律主要内容是：事情如果有变坏的可能，不管这种可能性有多小，它总会发生（Anything that can go wrong will go wrong）。</p>
<a id="more"></a>


<p>“墨菲定律”是一种心理学效应，是由爱德华·墨菲（Edward A. Murphy）提出的。<br>主要内容：<br>一、任何事都没有表面看起来那么简单；<br>二、所有的事都会比你预计的时间长；<br>三、会出错的事总会出错；<br>四、如果你担心某种情况发生，那么它就更有可能发生。<br>墨菲定律的原句是这样的：如果有两种或两种以上的方式去做某件事情，而其中一种选择方式将导致灾难，则必定有人会做出这种选择。<br>墨菲定律是其作出的著名论断，亦称墨菲定律、墨菲定理，是西方世界常用的俚语。<br>墨菲定律根本内容是：如果事情有变坏的可能，不管这种可能性有多小，它总会发生。</p>
<h3 id="幸存者偏差"><a href="#幸存者偏差" class="headerlink" title="幸存者偏差"></a>幸存者偏差</h3><p>幸存者偏差（Survivorship bias），另译为“生存者偏差”或“存活者偏差”，驳斥的是一种常见的逻辑谬误（“谬误”而不是“偏差”），这个被驳斥的逻辑谬误指的是只能看到经过某种筛选而产生的结果，而没有意识到筛选的过程，因此忽略了被筛选掉的关键信息。这东西的别名有很多，比如“沉默的数据”、“死人不会说话”等等。</p>
<p>意思是指，当取得资讯的渠道，仅来自于幸存者时（因为死人不会说话），此资讯可能会存在与实际情况不同的偏差。<br>此规律也适用于金融和商业领域。存活下来的企业往往被视为“传奇”，它们的做法被争相效仿。而其实有些也许只是因为偶然原因幸存下来了而已。<br>在日常生活中，最明显的例子就是“我亲戚吃这个药好了”或者“我一个朋友去找了这个老中医”等等。不管你的亲戚和朋友和你关系如何好，如何值得信任和尊重，在客观规律面前他们都是等同的。疾病和医药不会因为你的喜好而照顾或者偏袒你的亲朋。<br>如何应对呢？最明显的办法当然是让“死人”说话。双盲实验设计和详细全面客观的数据纪录都是应对“幸存者偏差”的良方。所谓“兼听则明”也是这个道理，抛掉对个案的迷信，全面系统的了解才能克服这个偏差。</p>
]]></content>
      <categories>
        <category>墨菲定律</category>
      </categories>
      <tags>
        <tag>墨菲定律</tag>
      </tags>
  </entry>
  <entry>
    <title>广告页面开发员原理</title>
    <url>/2017/10/15/iosadvertising/</url>
    <content><![CDATA[<blockquote>
<p>iOS的通知是一个神器，它会发出应用的启动，退到后台等事件通知，有了通知我们就可以做到对AppDelegate的无入侵。只有通知还是没有用的，我们还需要显示。</p>
</blockquote>
<a id="more"></a>


<h3 id="自启动-amp-监听"><a href="#自启动-amp-监听" class="headerlink" title="自启动 &amp; 监听"></a>自启动 &amp; 监听</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">///在load 方法中，启动监听，可以做到无注入</span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">[self shareInstance];</span><br><span class="line">&#125;</span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line"></span><br><span class="line">///如果是没啥经验的开发，请不要在初始化的代码里面做别的事，防止对主线程的卡顿，和 其他情况</span><br><span class="line"></span><br><span class="line">///应用启动, 首次开屏广告</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidFinishLaunchingNotification object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) &#123;</span><br><span class="line">///要等DidFinished方法结束后才能初始化UIWindow，不然会检测是否有rootViewController</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">[self checkAD];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;];</span><br><span class="line">///进入后台</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) &#123;</span><br><span class="line">[self request];</span><br><span class="line">&#125;];</span><br><span class="line">///后台启动,二次开屏广告</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationWillEnterForegroundNotification object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) &#123;</span><br><span class="line">[self checkAD];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>iOS的通知是一个神器，它会发出应用的启动，退到后台等事件通知，有了通知我们就可以做到对AppDelegate的无入侵。只有通知还是没有用的，我们还需要显示。</p>
</blockquote>
<h3 id="核心突破点：显示"><a href="#核心突破点：显示" class="headerlink" title="核心突破点：显示"></a>核心突破点：显示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)show</span><br><span class="line">&#123;</span><br><span class="line">///初始化一个Window， 做到对业务视图无干扰。</span><br><span class="line">UIWindow *window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line"></span><br><span class="line">///广告布局</span><br><span class="line">[self setupSubviews:window];</span><br><span class="line"></span><br><span class="line">///设置为最顶层，防止 AlertView 等弹窗的覆盖</span><br><span class="line">window.windowLevel = UIWindowLevelStatusBar + 1;</span><br><span class="line"></span><br><span class="line">///默认为YES，当你设置为NO时，这个Window就会显示了</span><br><span class="line">window.hidden = NO;</span><br><span class="line"></span><br><span class="line">///来个渐显动画</span><br><span class="line">window.alpha = 0;</span><br><span class="line">[UIView animateWithDuration:0.3 animations:^&#123;</span><br><span class="line">window.alpha = 1;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">///防止释放，显示完后  要手动设置为 nil</span><br><span class="line">self.window = window;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实大家一般盖视图，习惯在 KeyWindow 上直接AddSubview， 其实这是不好的。首先KeyWindow 会被AlertView覆盖， 还有可能别的业务代码也进行了AddSubview 这样就会把你的广告给覆盖了。</p>
<p>而使用我这种 UIWindow 的初始化，可以让你的视图出现在最顶层，不用怕乱七八糟的业务逻辑覆盖。</p>
<p>调用KeyWindow 还有个坏处。下面会说到。</p>
<h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><p>其实倒计时跟跳转是个很普通的功能点，没啥说的。有个关键点还是要说的 就是KeyWindow的调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">///不直接取KeyWindow 是因为当有AlertView 或者有键盘弹出时， 取到的KeyWindow是错误的。</span><br><span class="line">UIViewController* rootVC = [[UIApplication sharedApplication].delegate window].rootViewController;</span><br><span class="line">[[rootVC imy_navigationController] pushViewController:[IMYWebViewController new] animated:YES];</span><br></pre></td></tr></table></figure>

<p>其实 [UIApplication sharedApplication].keyWindow 取到的Window 不一定是你想要的。 因为KeyWindow 是会变的，所以劲量使用 [Delegate Window] 来获取显示的Window。 做 OS X 的应该体会多点。</p>
<p>在送上一个扩展，获取任意ViewController的navigationController</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation UIViewController (IMYPublic)</span><br><span class="line">- (UINavigationController*)imy_navigationController</span><br><span class="line">&#123;</span><br><span class="line">UINavigationController* nav = nil;</span><br><span class="line">if ([self isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class="line">nav = (id)self;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if ([self isKindOfClass:[UITabBarController class]]) &#123;</span><br><span class="line">nav = [((UITabBarController*)self).selectedViewController imy_navigationController];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">nav = self.navigationController;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return nav;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/li6185377/IMYADLaunchDemo" target="_blank" rel="noopener">广告启动 - IMYADLaunchDemo</a></p>
<p><a href="https://github.com/CoderZhuXH/XHLaunchAd" target="_blank" rel="noopener">广告启动(姿势多) - XHLaunchAd</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS架构实践干货</title>
    <url>/2017/09/25/iosarchitecture/</url>
    <content><![CDATA[<p><a href="https://github.com/madaoCN/NonBaseClass-MVVM-ReactiveObjc" target="_blank" rel="noopener">NonBaseClass-MVVM-ReactiveObjc</a></p>
<h2 id="NonBaseClass-MVVM-ReactiveObjc"><a href="#NonBaseClass-MVVM-ReactiveObjc" class="headerlink" title="NonBaseClass-MVVM-ReactiveObjc"></a>NonBaseClass-MVVM-ReactiveObjc</h2><a id="more"></a>

<p>遵循组合优于继承，采用 AOP方法和基类说Fxxk Off，采用 MVVM架构，ReactCocoa做动态绑定，JLRoutes 进行组件化</p>
<!--more-->
<h2 id="概览：主要内容如下："><a href="#概览：主要内容如下：" class="headerlink" title="概览：主要内容如下："></a>概览：主要内容如下：</h2><p>采用AOP思想，使用 Aspects 来完成替换 Controller ，View，ViewModel基类，和基类说拜拜<br>View层采用 MVVM 设计模式，使用 ReactiveObjC 进行数据绑定<br>网络层使用 YTKNetwork 配合 ReactiveCocoa 封装网络请求，解决如何交付数据，交付什么样的数据（去Model化)等问题<br>采用 JLRoutes 路由 对应用进行组件化解耦</p>
<p><a href="https://www.jianshu.com/p/921dd65e79cb" target="_blank" rel="noopener">iOS架构实践干货：AOP替代基类 + MVVM + ReactiveObjC + JLRoutes组件化</a></p>
<p><a href="https://www.jianshu.com/p/57661d206922" target="_blank" rel="noopener">（长文预警）面向切面 Aspects 源码阅读</a></p>
<p><a href="https://github.com/meili/MGJRouter" target="_blank" rel="noopener">meili/MGJRouter</a></p>
<p><a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">yuantiku/YTKNetwork</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 中常用的宏</title>
    <url>/2017/08/05/iosmacro/</url>
    <content><![CDATA[<p>// 带方法名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define NSLog(FORMAT, ...) &#123;\</span><br><span class="line">NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];\</span><br><span class="line">[dateFormatter setDateStyle:NSDateFormatterMediumStyle];\</span><br><span class="line">[dateFormatter setTimeStyle:NSDateFormatterShortStyle];\</span><br><span class="line">[dateFormatter setDateFormat:@&quot;HH:mm:ss:SSSSSS&quot;]; \</span><br><span class="line">NSString *str = [dateFormatter stringFromDate:[NSDate date]];\</span><br><span class="line">fprintf(stderr,&quot;Debug----&gt;&gt;&gt;&gt; %s %s %d %s~ 打印 = %s\n&quot;,[str UTF8String],[[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String], __LINE__,__func__, [[NSString stringWithFormat:FORMAT, ##__VA_ARGS__] UTF8String]);\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>//屏幕的宽和高</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kScreenWidth       [UIScreen mainScreen].bounds.size.width</span><br><span class="line">#define kScreenHeight      [UIScreen mainScreen].bounds.size.height</span><br><span class="line">#define kScreenBounds      ([UIScreen mainScreen].bounds)</span><br></pre></td></tr></table></figure>
<p>//MARK:获取手机类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define PHONE4 [UIScreen mainScreen].bounds.size.height == 480</span><br><span class="line">#define PHONE5  [UIScreen mainScreen].bounds.size.height == 568</span><br><span class="line">#define PHONE6  [UIScreen mainScreen].bounds.size.height == 667</span><br><span class="line">#define PHONEPLUS  [UIScreen mainScreen].bounds.size.height == 736</span><br></pre></td></tr></table></figure>


<p>//Library/Caches 文件路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kFilePath ([[NSFileManager defaultManager] URLForDirectory:NSCachesDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:YES error:nil])</span><br></pre></td></tr></table></figure>

<p>//文件目录的宏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kPathTemp                   NSTemporaryDirectory()</span><br><span class="line">#define kPathDocument               [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]</span><br><span class="line">#define kPathCache                  [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) objectAtIndex:0]</span><br></pre></td></tr></table></figure>


<p>// AppDelegate</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kAppDelegate ((AppDelegate *)[[UIApplication  sharedApplication] delegate])</span><br></pre></td></tr></table></figure>
<p>//获取图片资源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kGetImage(imageName) [UIImage imageNamed:[NSString stringWithFormat:@&quot;%@&quot;,imageName]]</span><br></pre></td></tr></table></figure>
<p>//在Main线程上运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kDISPATCH_ON_MAIN_THREAD(mainQueueBlock) dispatch_async(dispatch_get_main_queue(), mainQueueBlock);</span><br></pre></td></tr></table></figure>

<p>//在Global Queue上运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kDISPATCH_ON_GLOBAL_QUEUE_HIGH(globalQueueBlocl) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), globalQueueBlocl);</span><br><span class="line">#define kDISPATCH_ON_GLOBAL_QUEUE_DEFAULT(globalQueueBlocl) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), globalQueueBlocl);</span><br><span class="line">#define kDISPATCH_ON_GLOBAL_QUEUE_LOW(globalQueueBlocl) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), globalQueueBlocl);</span><br><span class="line">#define kDISPATCH_ON_GLOBAL_QUEUE_BACKGROUND(globalQueueBlocl) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), globalQueueBlocl);</span><br></pre></td></tr></table></figure>



<p>//获取系统版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kIOS_VERSION [[[UIDevice currentDevice] systemVersion] floatValue]</span><br><span class="line">#define kCurrentSystemVersion [[UIDevice currentDevice] systemVersion]</span><br></pre></td></tr></table></figure>

<p>//判断字符串,字典, 数据为空<br>// 字符串是否为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kIsEmptyString(str) ([str isKindOfClass:[NSNull class]] || str == nil || [str length] &lt; 1 ? YES : NO )</span><br></pre></td></tr></table></figure>
<p>// 对象为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kIsEmptyObject(obj) (obj == nil || [obj isKindOfClass:[NSNull class]])</span><br></pre></td></tr></table></figure>
<p>// 字典为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kDictIsEmpty(dic) (dic == nil || [dic isKindOfClass:[NSNull class]] || dic.allKeys == 0)</span><br></pre></td></tr></table></figure>
<p>// 数组为空为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kArrayIsEmpty(array) (array == nil || [array isKindOfClass:[NSNull class]] || array.count == 0)</span><br></pre></td></tr></table></figure>

<p>//MARK:获取当前本地时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kGETLOCALTIME [[DateHelper sharedInstance] getLocalTimeStr:[NSDate date]]</span><br></pre></td></tr></table></figure>


<p>//十rgb颜色转换（16进制-&gt;10进制）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kRGBAlpha(rgbValue,a) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:(a)]</span><br></pre></td></tr></table></figure>
<p>//获取RGB颜色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kRGBAColor(Red,Green,Blue,a) [UIColor colorWithRed:Red/255.0 green:Green/255.0 blue:Blue/255.0 alpha:a]</span><br></pre></td></tr></table></figure>
<p>//清除背景色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define kCLEARCOLOR [UIColor clearColor]</span><br><span class="line"></span><br><span class="line">#define kBlackColor       [UIColor blackColor]</span><br><span class="line">#define kDarkGrayColor    [UIColor darkGrayColor]</span><br><span class="line">#define kLightGrayColor   [UIColor lightGrayColor]</span><br><span class="line">#define kWhiteColor       [UIColor whiteColor]</span><br><span class="line">#define kRedColor         [UIColor redColor]</span><br><span class="line">#define kBlueColor        [UIColor blueColor]</span><br><span class="line">#define kGreenColor       [UIColor greenColor]</span><br><span class="line">#define kCyanColor        [UIColor cyanColor]</span><br><span class="line">#define kYellowColor      [UIColor yellowColor]</span><br><span class="line">#define kMagentaColor     [UIColor magentaColor]</span><br><span class="line">#define kOrangeColor      [UIColor orangeColor]</span><br><span class="line">#define kPurpleColor      [UIColor purpleColor]</span><br><span class="line">#define kBrownColor       [UIColor brownColor]</span><br><span class="line">#define kClearColor       [UIColor clearColor]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>宏</tag>
      </tags>
  </entry>
  <entry>
    <title>iPhone手机十周年回顾</title>
    <url>/2017/07/03/iphonehuigu/</url>
    <content><![CDATA[<blockquote>
<p>十年前的今天, 史蒂夫.乔布斯在2007年的 MacWorld大会上宣布了倍受期待的产品,他是iPod + phone + internet device 的结合体.这一代产品重新定义了手机. 在这十年中这部产品有哪些变化呢?</p>
</blockquote>
<p><img src="http://static.zybuluo.com/Rookie/4qyl4do5sazoaa403sgi82s0/iphones_light.gif" alt="iphones_light.gif-180.5kB"><br>十年 iPhone 产品图</p>
<a id="more"></a>


<hr>
<h3 id="iPhone-出发了"><a href="#iPhone-出发了" class="headerlink" title="iPhone: 出发了"></a>iPhone: 出发了</h3><p><img src="http://static.zybuluo.com/Rookie/wq66ndfj1ahwzr9gv1ph26ip/image_1bjot9ajcogtr0vk5t1gr2760m.png" alt="image_1bjot9ajcogtr0vk5t1gr2760m.png-264.7kB"><br>我们的和他的</p>
<p>当我们还在讨论直板手机和翻盖手机哪个好的时候, 但我们还在讨论买哪款 mp3的时候.<br>一款全触摸屏,有 iPod 的功能, 支持 HTML 和 CSS 浏览器 Safari的手机悄然诞生了.但是当产品出来的时候也是倍受争议, 认为他只是一个 iPod 的替代品. 没有支持彩信, 没有应用商店, 没有3G 连接.但是当时谁又能想到就是他改变了一个行业 ,或者说改变了世界.</p>
<hr>
<h3 id="iPhone-3G-支持3G"><a href="#iPhone-3G-支持3G" class="headerlink" title="iPhone 3G:  支持3G"></a>iPhone 3G:  支持3G</h3><p><img src="http://static.zybuluo.com/Rookie/icrb4uvs5nxeptopz3717afo/image_1bjott92f14t21o7115dpaas5lo9.png" alt="image_1bjott92f14t21o7115dpaas5lo9.png-332kB"><br>左边是 iPhone 右边是 iPhone 3G</p>
<p>iPhone 3G 搭载了”iPhone OS 2.0”系统, 添加了 App Store 和3G 功能,提供了8GB 版本和16GB 版本.但是还没有得到消费者的认可, 觉得如果你想尝鲜可以买来把玩,但是如果真是使用可能他们还是会认可黑莓</p>
<hr>
<h3 id="iPhone-3GS-更快的运行速度"><a href="#iPhone-3GS-更快的运行速度" class="headerlink" title="iPhone 3GS: 更快的运行速度"></a>iPhone 3GS: 更快的运行速度</h3><p><img src="http://static.zybuluo.com/Rookie/lggbpfz1tiic7dwln8msxp9q/image_1bjoudk9bt12q001jvi1q851ve8m.png" alt="image_1bjoudk9bt12q001jvi1q851ve8m.png-392.9kB"><br>搭载 iOS6的 iPhone3GS</p>
<p>“S”系列一直沿用到现在, 是指一年会有一个全新的设计, 下一年会带来更快的速度和其他内部调整设计优化</p>
<p>iPhone 3GS 搭载了”iPhone OS 3.0”系统,支持彩信,邮件和短信的推送通知,以及最基础的复制粘贴功能等等.在这个基础上, 当时的人们才觉得有塞班系统媲美的资格了.</p>
<hr>
<h3 id="iPhone-4-支持Retina"><a href="#iPhone-4-支持Retina" class="headerlink" title="iPhone 4: 支持Retina"></a>iPhone 4: 支持Retina</h3><p><img src="http://static.zybuluo.com/Rookie/0o46uqs8wpol3msjp0ur4kgh/image_1bjp056ag13k11e2q1uev1k7m167013.png" alt="image_1bjp056ag13k11e2q1uev1k7m167013.png-435.4kB"><br>iPhone 4是第一款支持视网膜屏幕的手机</p>
<p>iPhone 4 重新进行了设计, 内存上升到512MB, A4处理器提升了一大截的运行速度,玻璃正面和背面边框金属天线等等 . 无论在现在还是当时iPhone4都被认为是最伟大的作品之一.真正的定义了什么是智能手机.虽然出现天线门的争议.但是谁也无法否定这是一部划时代的产品</p>
<hr>
<h3 id="iPhone-4S-嘿-Siri"><a href="#iPhone-4S-嘿-Siri" class="headerlink" title="iPhone 4S: 嘿, Siri"></a>iPhone 4S: 嘿, Siri</h3><p><img src="http://static.zybuluo.com/Rookie/8ann5p0fqqnxye0mnlwf9d91/image_1bjp1av631apf1dq81pjlv901gp61g.png" alt="image_1bjp1av631apf1dq81pjlv901gp61g.png-542.3kB"><br>iPhone 4S 手机</p>
<p>iPhone 4S 是乔布斯一生中发布的最后一个 iPhone,添加了Siri, 让手机变的更智能, 同时也是代表了一个时代的总结,比如老化的30-pin iPod 端口, 3.5英寸大小的屏幕,同时也是最后一个没有 LTE 的 iPhone. </p>
<h3 id="iPhone-5-Lightning-接口问世"><a href="#iPhone-5-Lightning-接口问世" class="headerlink" title="iPhone 5: Lightning 接口问世"></a>iPhone 5: Lightning 接口问世</h3><p><img src="http://static.zybuluo.com/Rookie/tcvsqq9nscow3d2o4952n04z/image_1bjp1qscf1dvpb1k1br2ulj1mp99.png" alt="image_1bjp1qscf1dvpb1k1br2ulj1mp99.png-452.5kB"><br>iPhone 5运行 iOS 10</p>
<p>因为 Android 手机不断增加屏幕尺寸, iPhone 5 也将屏幕增加到了4英寸,重新设计了闪电接口.同时对机身整体重新设计和优化. 变得更高了一点,同时更薄了一点.也是消费者相对比较喜爱的经典机型</p>
<hr>
<h3 id="iPhone-5S-指纹解锁"><a href="#iPhone-5S-指纹解锁" class="headerlink" title="iPhone 5S: 指纹解锁"></a>iPhone 5S: 指纹解锁</h3><p><img src="http://static.zybuluo.com/Rookie/que0ag9l8ce8rbdti6dbzwq6/image_1bjp49p2bcl71q05p42ggv1vnom.png" alt="image_1bjp49p2bcl71q05p42ggv1vnom.png-219.6kB"><br>解锁中的 iPhone 5S</p>
<p>iPhone 5S 搭载 iOS 7 系统, 设计部门高级副总裁乔纳森更新为扁平化设计, 硬件上添加 Touch ID 指纹识别传感器,首次使用64位 处理器等. 同时针对扁平和拟物设计引起争论, 现在看起来扁平化设计也很顺眼了. 也许我们当时支持拟物化设计的人员只是比较怀念有乔布斯的苹果吧.</p>
<hr>
<h3 id="iPhone-5C-低价格多彩手机"><a href="#iPhone-5C-低价格多彩手机" class="headerlink" title="iPhone 5C: 低价格多彩手机"></a>iPhone 5C: 低价格多彩手机</h3><p><img src="http://static.zybuluo.com/Rookie/r9uvvmvwdzaxdrs6kl1jjrmc/image_1bjp4rikh19no1r4e1rb11hm11d5a13.png" alt="image_1bjp4rikh19no1r4e1rb11hm11d5a13.png-385.8kB"><br>彩色 iPhone 5C</p>
<p>这是苹果第一次专门为低端或者低端价格研发的手机,在 iPhone 5 上添加一个彩色塑料外壳,苹果子对它进行销售了几年的时间,后面逐步淘汰了他, 目前为止没有重新彩色物料外壳的产品,同时也好像在验证了什么!</p>
<h3 id="iPhone-6-and-6-Plus-更大的手机"><a href="#iPhone-6-and-6-Plus-更大的手机" class="headerlink" title="iPhone 6 and 6 Plus: 更大的手机"></a>iPhone 6 and 6 Plus: 更大的手机</h3><p><img src="http://static.zybuluo.com/Rookie/xjwmuu0uopp763ssqw20uobo/image_1bjp5456u1svahkb1mq2171h1ee1g.png" alt="image_1bjp5456u1svahkb1mq2171h1ee1g.png-392.1kB"><br>上图是 iPhone 6 和 6 Plus</p>
<p>这两款手机是大变革手机,无论是4.7和5.5英寸的屏幕,还是圆润的工业设计, 好像在乔布斯的路上渐行渐远, 薄铝机身圆润的边框,让人难以接收的天线线条. 好像放弃了曾经的高傲,变得更加温和包容.好像失去了乔老爷的魂魄..</p>
<hr>
<h3 id="iPhone-6S-and-6S-Plus-玫瑰金"><a href="#iPhone-6S-and-6S-Plus-玫瑰金" class="headerlink" title="iPhone 6S and 6S Plus: 玫瑰金"></a>iPhone 6S and 6S Plus: 玫瑰金</h3><p><img src="http://static.zybuluo.com/Rookie/yb7047aurgd54nv46rxyb04b/image_1bjp5n5u61k2159un6sdsnhje1t.png" alt="image_1bjp5n5u61k2159un6sdsnhje1t.png-394.2kB"><br>玫瑰金iPhone 6S</p>
<p>硬件上只更新了更快的芯片,加铝制机身进行强化, 软件上增加了3D Touch.以及系统的优化等, 好像苹果给予的惊喜越来越少了…</p>
<hr>
<h3 id="iPhone-SE-好的东西可以用小包装"><a href="#iPhone-SE-好的东西可以用小包装" class="headerlink" title="iPhone SE: 好的东西可以用小包装"></a>iPhone SE: 好的东西可以用小包装</h3><p><img src="http://static.zybuluo.com/Rookie/84va8d2xwp4k5893d1h4lrnw/image_1bjp614h7gcuqegqbcdviknt2a.png" alt="image_1bjp614h7gcuqegqbcdviknt2a.png-418.8kB"><br>玫瑰金 iPhone SE</p>
<p>这是苹果又一款低端机型, 他的存在确实降低了 iPhone 的平均售价, 并且搭载了最新的系统以及更高的配置, 对于使用5和5S 的用户是一个不错的选择.而我觉得这款手机更多的是为了怀念一下乔老爷吧.. </p>
<hr>
<h3 id="iPhone-7-and-7-Plus-再见了-耳机插孔"><a href="#iPhone-7-and-7-Plus-再见了-耳机插孔" class="headerlink" title="iPhone 7 and 7 Plus: 再见了,耳机插孔"></a>iPhone 7 and 7 Plus: 再见了,耳机插孔</h3><p><img src="http://static.zybuluo.com/Rookie/i0yy1svw8tyujsox5ttu0gy4/image_1bjp6cl9k1a5l11qi1gkeei132m2n.png" alt="image_1bjp6cl9k1a5l11qi1gkeei132m2n.png-545.3kB"><br> iPhone 7 和 7 Plus</p>
<p> iPhone 7 和 7 Plus 增加了防水的性能,最新的处理器以及存储能力,第一次添加了双摄像头, Home 按键变成实体按键不能在点击, 没有耳机插孔,推出了新的 Airpod无线耳机等, 但是我觉得 iPhone 7 更像是 iPhone 6 的第二个 “S”版本.</p>
<hr>
<h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p> <img src="http://static.zybuluo.com/Rookie/t2sn1gd0x96qf8fxpppf0izs/image_1bjp78j2q1pjlu9jhah416pr634.png" alt="image_1bjp78j2q1pjlu9jhah416pr634.png-66.2kB"><br> 图片来自网络</p>
<p> 作为下一代 iPhone 还没有问世, 现在就已经流言四起, OLED 屏幕, Home按键小事,竖向双摄像头等等 .期待着那一份惊喜!<br> 十年之前的苹果我不认识你,你不属于我,<br> 十年后的苹果. 感谢你曾经惊艳过我, 虽然你不是唯一, 但依然支持你!</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>公众账号</tag>
      </tags>
  </entry>
  <entry>
    <title>拿什么保护我们的成果</title>
    <url>/2017/06/26/proourapp/</url>
    <content><![CDATA[<blockquote>
<p>程序猿，色剂丝，地球上最苦逼的职业之一，当自己辛辛苦苦、没日没夜的赶工，如生孩子般辛苦的完成了App的制作，却在不久之后发现了很多在外观和设计理念上都足以以假乱真的App出现了，可能你的心里已经在画个圈圈诅咒那些抄袭者了，但却不知道该如何用实际行动去对付他们，真的没有办法去防止这种现象的出现，维护自己的权益吗</p>
</blockquote>
<a id="more"></a>

<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><blockquote>
<p>软件专利和外观设计</p>
</blockquote>
<p><img src="http://static.zybuluo.com/Rookie/cztx3rr2ta7qae2f5cusc2x1/image_1bjh8egng13kdickf6g5cu13kv9.png" alt="image_1bjh8egng13kdickf6g5cu13kv9.png-363.1kB"></p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><blockquote>
<p>软件著作权</p>
</blockquote>
<p><img src="http://static.zybuluo.com/Rookie/9teuhn3hlswwqneujjp6kham/image_1bjh8fajn1k2r1peb1fnq1al3no1m.png" alt="image_1bjh8fajn1k2r1peb1fnq1al3no1m.png-204.3kB"></p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><blockquote>
<p>APP 图标申请商标申请</p>
</blockquote>
<ol>
<li>APP的名称，是可以通过商标权来保护的。比如陌陌因没及时注册商标被诉1000万赔偿，而滴滴打车则因为没有及时注册商标而被迫从“嘀嘀”改成“滴滴”。</li>
<li>APP的图标，属于图形用户界面，但如果显著性强的话，也可以通过注册商标获得保护，例如微信的图标显著性强，就可以注册商标，但普通的打电话图标显著性弱，很可能获得不了注册商标。在国际上，又通常可以通过外观设计专利获得保护。</li>
</ol>
<p>作者：吴溯<br>链接：<a href="https://www.zhihu.com/question/25740160/answer/33894173" target="_blank" rel="noopener">https://www.zhihu.com/question/25740160/answer/33894173</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><img src="http://static.zybuluo.com/Rookie/opkmkf67t4rgiae8ww8hvbw5/image_1bjh8g7ov1gv2102k163a176pasq13.png" alt="image_1bjh8g7ov1gv2102k163a176pasq13.png-217.1kB"></p>
<blockquote>
<p>APP 的知识产权保护, 是需要通过权利组合来实现的 . </p>
</blockquote>
<ol>
<li>APP 的名称, 是可以通过商标权来保护的</li>
<li>APP 的图标, 属于图形用户界面, 当时如果显著性强的话, 也可以通过注册商标获得保护, 例如微信的图标显著性强，就可以注册商标，但普通的打电话图标显著性弱，很可能获得不了注册商标。在国际上，又通常可以通过外观设计专利获得保护。</li>
<li>人际交互设计, 通常可以通过专利,著作权和商标来获得保护, 可以分解三个层面<br>3.1 第一层也最低层是人机交互技术层面（如语音识别、触控）等，这个层面是技术层面的基础，通常通过发明专利获得保护，苹果、三星等巨头都有不少这方面的专利；<br>3.2 第二层是人机交互方法，是在交互技术的基础上由工业设计师构思出来的方法，例如苹果公司的滑动解锁就是这一种，通常通过方法发明专利获得保护；<br>3.3 第三层是图形用户界面（GUI），任何产品都需要通过图形用户界面来面对用户，这一层视觉美观和动态效果都是非常重要的，通常可以通过外观设计专利（中国和美国使用外观设计专利，其他国家通常是注册外观设计，名称不同，性质类似）、著作权（只有少部分独创性高的）和商标权（显著性高的图标）来获得保护，尤其在美国，图形用户界面的外观设计专利保护是极为重要的，苹果公司本身申请了200多件图形用户界面的外观设计专利，此外苹果诉三星的专利诉讼中，就有不少图形用户界面外观设计专利。</li>
</ol>
<blockquote>
<p>首先在我过法律规定下, 著作权是天然获得的 , 不管发表与否. 专利需要进行申请, 获取批准后,才能获得专利权,<br>  所以知乎也不是抄袭Quora，人人网也不是抄袭facebook，饭否也不是抄袭twitter，这些行为只能认定为借鉴或者模仿，不能算是抄袭，所以并不能说侵犯了著作权。我下面具体说一下，为什么不算抄袭。<br>  所以著作权并不能很好解决一些问题 , 也就是说可以认定为一种成果的形式. 这种情况下需要进行专利申请进行保护.我国现行关于专利的法律《中华人民共和国专利法》第二条规定了专利的三种形式，发明专利、实用新型专利和外观设计专利。如果需要对界面的样式进行保护，就需要将自己设计的界面申请外观专利。这样，一旦有人仿制你的界面，那即是侵犯你的专利权，你就可以对他提起专利侵权诉讼。<br>  像facebook这样的网站，可以通过发明专利或者使用新型专利的形式，来保护自己的创意<br>  又如，搜索引擎这样的东西，完全可以作为“依赖关键字的互联网页面索引”来申请专利。像Google的PageRank算法显然是一个创新点，那么在专利中是应当具体说明并保护起来的。<br>  但是，如果他们没有申请专利，或者没有申请能够在中国境内有效的专利，那么所有的仿制行为都不能算是侵权，最多只能从道德层面去谴责，没有办法上升到法律的层面。<br>  不属于知识产权，你的点子是一种抽象思维，没有外在表现载体，无法保护。</p>
</blockquote>
<p>PageRank，网页排名，又称网页级别、Google左侧排名或佩奇排名，是一种由<a href="http://static.zybuluo.com/Rookie/cztx3rr2ta7qae2f5cusc2x1/image_1bjh8egng13kdickf6g5cu13kv9.png" target="_blank" rel="noopener">1</a> 根据网页之间相互的超链接计算的技术，而作为网页排名的要素之一，以Google公司创办人拉里·佩奇（Larry Page）之姓来命名。Google用它来体现网页的相关性和重要性，在搜索引擎优化操作中是经常被用来评估网页优化的成效因素之一。Google的创始人拉里·佩奇和谢尔盖·布林于1998年在斯坦福大学发明了这项技术。<br>PageRank通过网络浩瀚的超链接关系来确定一个页面的等级。Google把从A页面到B页面的链接解释为A页面给B页面投票，Google根据投票来源（甚至来源的来源，即链接到A页面的页面）和投票目标的等级来决定新的等级。简单的说，一个高等级的页面可以使其他低等级页面的等级提升!&gt;</p>
<h3 id="关于腾讯抄袭-你怎么看"><a href="#关于腾讯抄袭-你怎么看" class="headerlink" title="关于腾讯抄袭, 你怎么看?"></a>关于腾讯抄袭, 你怎么看?</h3><blockquote>
<ol>
<li>在中国特色社会主义国家中, 抄袭创意是不算抄袭 , “，孔乙己“窃书不能算偷……窃书！……读书人的事，能算偷么？” “<br>偷: 苟且也 –&lt;说文&gt; 如偷情 , 偷人, 偷欢<br>窃: 窃货曰盗。――《荀子·脩身》 多值财务.  但盗亦有道 … 中国文化博大精深</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>腾讯在原有创意上会添加上自己的修改和基调,区别于其他专利和保护. CF, QQ 飞车, 腾讯微博, 搜索, 安全管家, 拍拍 , 财务通……</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>也不用担心 , 腾讯抄袭的也并不是都成功的的, 腾讯微博, 朋友网, 拍拍(14年被京东收购) , 腾讯搜索 soso(13年, 搜狗吞并), QQTtalk(09年业务全面取消), 腾讯 TT浏览器. (11年停止更新), QQ家园,QQ宠物等等 … 神也会有失败 , 我们的失败又能算得了什么呢 ?</li>
</ol>
</blockquote>
<p>  <img src="http://static.zybuluo.com/Rookie/35uz0txhzxj7rnpjky8nmzu9/image_1bjm62s3b1718n2a3m2v607kf9.png" alt="image_1bjm62s3b1718n2a3m2v607kf9.png-158.5kB"></p>
<h1 id="第二页"><a href="#第二页" class="headerlink" title="第二页"></a>第二页</h1><blockquote>
<p>程序猿，色剂丝，地球上最苦逼的职业之一，当自己辛辛苦苦、没日没夜的赶工，如生孩子般辛苦的完成了App的制作，却在不久之后发现了很多在外观和设计理念上都足以以假乱真的App出现了，可能你的心里已经在画个圈圈诅咒那些抄袭者了，但却不知道该如何用实际行动去对付他们，真的没有办法去防止这种现象的出现，维护自己的权益吗</p>
</blockquote>
<p>谈到科技圈抄袭 。 流传着这样两个故事，一个是苹果，一直被模仿从未被超越。另一个是腾讯，一直在模仿从未被超越，虽然两者只有一字之差，但有着完全不同的含义，前者是创新者，是所有创新者崇拜的偶像，后者是模仿者，是所有创新者心中的恶魔。</p>
<p>所以知乎也不是抄袭Quora，人人网也不是抄袭facebook，饭否也不是抄袭twitter，这些行为只能认定为借鉴或者模仿，不能算是抄袭，所以并不能说侵犯了著作权。我下面具体说一下，为什么不算抄袭。而我们最常见的“下拉刷新手势”功能则是来自Twitter客户端Tweetie的设计，现在已成为标配。</p>
<h1 id="第三页："><a href="#第三页：" class="headerlink" title="第三页："></a>第三页：</h1><p> 如果idea是一个技术方案或者一个设计方案，而且符合专利法对客体的要求，那么是可以申请专利的。</p>
<p> 具体地说，如果是产品或方法的技术方案，可以申请发明专利，如果是产品的形状和构造的技术方案，可以申请实用新型专利，如果是造型的外观设计方案，可以申请外观设计专利。</p>
<p> 以方法发明专利为例，如果你对互联网产品的人机交互设计构思出了一个好的idea，比如微信的摇一摇吧，那么这个人机交互方法是可以通过发明专利获得保护的。至于实现了没有是无所谓的，关键是能够实现（实用性），是新的（新颖性），而且不是显而易见容易想到的（创造性）。</p>
<p> 以外观设计专利为例，假设你为你的互联网产品设计出了图形用户界面（GUI），比如一整套APP的界面，只要是新的，不是显而易见的，那么这个APP是不是已经通过软件工程师实现了，那是无所谓的，这个界面的设计，和物理载体比如手机结合在一起，是可以申请“带GUI的手机”的外观设计专利的<br> 。总而言之，可以未实现，但必须能实现，并且符合专利的其他要求，同时未公开，那么就可以申请专利了。</p>
<h1 id="第四页"><a href="#第四页" class="headerlink" title="第四页"></a>第四页</h1><p> 首先在我过法律规定下, 著作权是天然获得的 , 不管发表与否. 专利需要进行申请, 获取批准后,才能获得专利权,<br> 于正妈妈<br>  所以知乎也不是抄袭Quora，人人网也不是抄袭facebook，饭否也不是抄袭twitter，这些行为只能认定为借鉴或者模仿，不能算是抄袭，所以并不能说侵犯了著作权。我下面具体说一下，为什么不算抄袭。<br>  所以著作权并不能很好解决一些问题 , 也就是说可以认定为一种成果的形式. 这种情况下需要进行专利申请进行保护.我国现行关于专利的法律《中华人民共和国专利法》第二条规定了专利的三种形式，发明专利、实用新型专利和外观设计专利。如果需要对界面的样式进行保护，就需要将自己设计的界面申请外观专利。这样，一旦有人仿制你的界面，那即是侵犯你的专利权，你就可以对他提起专利侵权诉讼。<br>  像facebook这样的网站，可以通过发明专利或者使用新型专利的形式，来保护自己的创意<br>  又如，搜索引擎这样的东西，完全可以作为“依赖关键字的互联网页面索引”来申请专利。像Google的PageRank算法显然是一个创新点，那么在专利中是应当具体说明并保护起来的。<br>  但是，如果他们没有申请专利，或者没有申请能够在中国境内有效的专利，那么所有的仿制行为都不能算是侵权，最多只能从道德层面去谴责，没有办法上升到法律的层面。</p>
<h1 id="第五页"><a href="#第五页" class="headerlink" title="第五页"></a>第五页</h1><ol>
<li>APP的名称，是可以通过商标权来保护的。比如陌陌因没及时注册商标被诉1000万赔偿，而滴滴打车则因为没有及时注册商标而被迫从“嘀嘀”改成“滴滴”。<ol start="2">
<li>APP的图标，属于图形用户界面，但如果显著性强的话，也可以通过注册商标获得保护，例如微信的图标显著性强，就可以注册商标，但普通的打电话图标显著性弱，很可能获得不了注册商标。在国际上，又通常可以通过外观设计专利获得保护。</li>
</ol>
</li>
</ol>
<h1 id="第六页"><a href="#第六页" class="headerlink" title="第六页"></a>第六页</h1><h3 id="关于腾讯抄袭-你怎么看-1"><a href="#关于腾讯抄袭-你怎么看-1" class="headerlink" title="关于腾讯抄袭, 你怎么看?"></a>关于腾讯抄袭, 你怎么看?</h3><blockquote>
<ol>
<li>在中国特色社会主义国家中, 抄袭创意是不算抄袭 , “，孔乙己“窃书不能算偷……窃书！……读书人的事，能算偷么？” “<br>偷: 苟且也 –&lt;说文&gt; 如偷情 , 偷人, 偷欢<br>窃: 窃货曰盗。――《荀子·脩身》 多值财务.  但盗亦有道 … 中国文化博大精深</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>腾讯在原有创意上会添加上自己的修改和基调,区别于其他专利和保护. CF, QQ 飞车, 腾讯微博, 搜索, 安全管家, 拍拍 , 财务通……</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>也不用担心 , 腾讯抄袭的也并不是都成功的的, 腾讯微博, 朋友网, 拍拍(14年被京东收购) , 腾讯搜索 soso(13年, 搜狗吞并), QQTtalk(09年业务全面取消), 腾讯 TT浏览器. (11年停止更新), QQ家园,QQ宠物等等 … 神也会有失败 , 我们的失败又能算得了什么呢 ?</li>
</ol>
</blockquote>
<p> 毕加索曾经说过：“好的艺术家复制作品，伟大的艺术家窃取灵感。”<br>抄袭只能获得一时的成功，创新则是一世的成功。<br>抄袭和复制并不可怕 ， 而是在这个过程中要加入思想和灵魂。。。。。 才能走向成功。。。。。。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>公众账号</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell常用命令</title>
    <url>/2017/06/13/sellmingling/</url>
    <content><![CDATA[<h3 id="查找删除"><a href="#查找删除" class="headerlink" title="查找删除"></a>查找删除</h3><blockquote>
<p>//删除文件夹下的所有 .svn 文件<br>find . -name “.svn” | xargs rm -Rf<br>//删除文件夹下的所有 .git 文件<br>find . -name “.git” | xargs rm -Rf<br>输入 touch .gitignore 在文件夹就生成了一个“.gitignore”文件。</p>
</blockquote>
<a id="more"></a>

<hr>
<p>###目录操作<br>命令名 功能描述 使用举例<br><code>mkdir 创建一个目录</code> mkdir dirname<br><code>rmdir 删除一个目录</code> rmdir dirname<br><code>mvdir 移动或重命名一个目录</code> mvdir dir1 dir2<br><code>cd 改变当前目录</code> cd dirname<br><code>pwd 显示当前目录的路径名</code> pwd<br><code>ls 显示当前目录的内容</code> ls -la<br><code>dircmp 比较两个目录的内容</code> dircmp dir1 dir2</p>
<hr>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>命令名 功能描述 使用举例<br><code>cat 显示或连接文件</code> cat filename<br><code>pg 分页格式化显示文件内容</code> pg filename<br><code>more 分屏显示文件内容</code> more filename<br><code>od 显示非文本文件的内容</code> od -c filename<br><code>cp 复制文件或目录</code> cp file1 file2<br><code>rm 删除文件或目录</code> rm filename<br><code>mv 改变文件名或所在目录</code> mv file1 file2<br><code>ln 联接文件</code> ln -s file1 file2<br><code>find 使用匹配表达式查找文件</code> find . -name “*.c” -print<br><code>file 显示文件类型</code> file filename<br><code>open 使用默认的程序打开文件</code> open filename</p>
<p>###选择操作<br>命令名 功能描述 使用举例<br><code>head 显示文件的最初几行</code> head -20 filename<br><code>tail 显示文件的最后几行</code> tail -15 filename<br><code>cut 显示文件每行中的某些域</code> cut -f1,7 -d: /etc/passwd<br><code>colrm 从标准输入中删除若干列</code> colrm 8 20 file2<br><code>paste 横向连接文件</code> paste file1 file2<br><code>diff 比较并显示两个文件的差异</code> diff file1 file2<br><code>sed 非交互方式流编辑器</code> sed “s/red/green/g” filename<br><code>grep 在文件中按模式查找</code> grep “^[a-zA-Z]” filename<br><code>awk 在文件中查找并处理模式</code> awk ‘{print $1 $1}’ filename<br><code>sort 排序或归并文件</code> sort -d -f -u file1<br><code>uniq 去掉文件中的重复行</code> uniq file1 file2<br><code>comm 显示两有序文件的公共和非公共行</code> comm file1 file2<br><code>wc 统计文件的字符数、词数和行数</code> wc filename<br><code>nl 给文件加上行号</code> nl file1 &gt;file2</p>
<hr>
<h3 id="安全操作"><a href="#安全操作" class="headerlink" title="安全操作"></a>安全操作</h3><p>命令名 功能描述 使用举例<br><code>passwd 修改用户密码</code> passwd<br><code>chmod 改变文件或目录的权限</code> chmod ug+x filename<br><code>umask 定义创建文件的权限掩码</code> umask 027<br><code>chown 改变文件或目录的属主</code> chown newowner filename<br><code>chgrp 改变文件或目录的所属组</code> chgrp staff filename<br><code>xlock 给终端上锁</code> xlock -remote</p>
<hr>
<h3 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h3><p>命令名 功能描述 使用举例<br><code>ps 显示进程当前状态</code> ps u<br><code>kill 终止进程</code> kill -9 30142<br><code>nice 改变待执行命令的优先级</code> nice cc -c *.c<br><code>renice 改变已运行进程的优先级</code> renice +20 32768</p>
<hr>
<h3 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h3><p>命令名 功能描述 使用举例<br><code>uname 显示操作系统的有关信息</code> uname -a<br><code>clear 清除屏幕或窗口内容</code> clear<br><code>env 显示当前所有设置过的环境变量</code> env<br><code>who 列出当前登录的所有用户</code> who<br><code>whoami 显示当前正进行操作的用户名</code> whoami<br><code>tty 显示终端或伪终端的名称</code> tty<br><code>stty 显示或重置控制键定义</code> stty -a<br><code>du 查询磁盘使用情况</code> du -k subdir<br><code>df 显示文件系统的总空间和可用空间</code> df /tmp<br><code>w 显示当前系统活动的总信息</code> w</p>
<h3 id="Finder显示隐藏文件"><a href="#Finder显示隐藏文件" class="headerlink" title="Finder显示隐藏文件"></a>Finder显示隐藏文件</h3><p>显示隐藏文件<br>在“终端”中输入下面的命令：<br><code>defaults write com.apple.finder AppleShowAllFiles -bool true
killall Finder</code><br>恢复隐藏文件<br>在“终端”中输入下面的命令：<br><code>defaults write com.apple.finder AppleShowAllFiles -bool false
killall Finder</code></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器维护指南</title>
    <url>/2017/05/12/servicepro/</url>
    <content><![CDATA[<h3 id="随机密码生成">随机密码生成</h3>



<pre class="prettyprint hljs-dark"><code class="hljs cpp">openssl rand -base64 <span class="hljs-number">32</span><br>date | md5sum<br>date +%s | sha256sum | base64 | head -c <span class="hljs-number">32</span> ; echo<br>cat /dev/urandom | tr -dc _A-Z-a-z-<span class="hljs-number">0</span>-<span class="hljs-number">9</span>+$.?*<span class="hljs-preprocessor">#\/@! | head -c${<span class="hljs-number">1</span>:-<span class="hljs-number">64</span>};echo;</span><br></code></pre>


<a id="more"></a>


<h3 id="ssh免密码登陆">SSH免密码登陆</h3>

<ol><li rel="1">在本地输入<code>ssh-keygen -t rsa</code> ，PS：如果已有，可跳过1、2步</li>
<li rel="2">本地<code>~/.ssh</code>目录会生成两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code></li>
<li rel="3"><code>scp ~/.ssh/id_rsa.pub www@112.124.121.91:/home/www</code>，将本地<code>id_rsa.pub</code>拷贝到服务器</li>
<li rel="4">登录www用户，输入<code>cat ~/id_rsa.pub &gt;&gt; authorized_keys</code></li>
<li rel="5">这是就可以免密码登陆了</li>
</ol>



<h3 id="添加用户和用户组">添加用户和用户组</h3>



<pre class="prettyprint hljs-dark"><code class="hljs stata">groupadd www  <span class="hljs-comment">//新建www工作组</span><br>useradd -<span class="hljs-keyword">g</span> www www  <span class="hljs-comment">//新建www用户并增加到test工作组</span><br>passwd www <span class="hljs-comment">// 修改www用户密码</span><br></code></pre>



<pre class="prettyprint hljs-dark"><code class="hljs 1c">visudo <span class="hljs-comment">//需要修改此文件，使新创建的用户可以使用sudo命令, 仿照文件内容修改即可</span><br></code></pre>



<h3 id="环境搭建以下操作均在www用户下进行">环境搭建（以下操作均在www用户下进行）</h3>

<ol start="1"><li rel="1">NVM</li>
</ol>



<pre class="prettyprint hljs-dark"><code class="hljs vim">curl -<span class="hljs-keyword">o</span>- http<span class="hljs-variable">s:</span>//raw.githubusercontent.<span class="hljs-keyword">com</span>/creationix/nvm/v0.<span class="hljs-number">33.1</span>/install.<span class="hljs-keyword">sh</span> | bash<br></code></pre>

<ol start="2"><li rel="2">Node</li>
</ol>



<pre class="prettyprint hljs-dark"><code class="hljs cpp">nvm install v6<span class="hljs-number">.10</span><span class="hljs-number">.0</span><br></code></pre>

<ol start="3"><li rel="3">MySQL</li>
</ol>



<pre class="prettyprint hljs-dark"><code class="hljs vala"><span class="hljs-preprocessor"># 查看系统版本</span><br>lsb_release -a<br><span class="hljs-preprocessor"># 下载 for CenteOS 7</span><br>wget http:<span class="hljs-comment">//dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpm</span><br><span class="hljs-preprocessor"># 添加资源库</span><br>yum localinstall mysql57-community-release-el7-<span class="hljs-number">7.</span>noarch.rpm <br><span class="hljs-preprocessor"># 验证MySQL是否已被添加到本地资源库</span><br>yum repolist enabled | grep <span class="hljs-string">"mysql.*-community.*"</span><br><span class="hljs-preprocessor"># 安装</span><br>sudo yum install mysql-community-server<br><span class="hljs-preprocessor"># 启动</span><br>sudo service mysqld start<br><span class="hljs-preprocessor"># 查看启动状态</span><br>sudo service mysqld status<br><span class="hljs-preprocessor"># 生成root临时密码</span><br>grep <span class="hljs-string">'temporary password'</span> /<span class="hljs-keyword">var</span>/log/mysqld.log<br><span class="hljs-preprocessor"># 安全设置</span><br>mysql_secure_installation<br><span class="hljs-preprocessor"># 更新MySQL</span><br>yum update mysql-server<br><span class="hljs-preprocessor"># 创建数据库</span><br>create database wisdom_estate;<br><span class="hljs-preprocessor"># 授予www用户的数据库的所有权限</span><br>grant all privileges on wisdom_estate.* to www@<span class="hljs-string">'%'</span> identified by <span class="hljs-string">'此处是密码'</span>;<br><span class="hljs-preprocessor"># 修改www用户密码</span><br>mysqladmin -u www -p password<br></code></pre>

<ol start="4"><li rel="4"><a href="http://www.redis.cn" target="_blank">Redis</a></li>
</ol>

<pre class="prettyprint hljs-dark"><code class="hljs cpp">下载，解压，编译:<br>$ wget http:<span class="hljs-comment">//download.redis.io/releases/redis-3.2.8.tar.gz</span><br>$ tar xzf redis-<span class="hljs-number">3.2</span><span class="hljs-number">.8</span>.tar.gz<br>$ cd redis-<span class="hljs-number">3.2</span><span class="hljs-number">.8</span><br>$ make<br></code></pre>

<blockquote>
  <p>PS: <a href="https://github.com/luin/medis" target="_blank">Redis 客户端</a></p>
</blockquote>

<h3 id="ngix">ngix</h3>

<ol start="1"><li rel="1">创建文件：<code>/etc/yum.repos.d/nginx.repo</code>，内容为：</li>
</ol>



<pre class="prettyprint hljs-dark"><code class="hljs ini"><span class="hljs-title">[nginx]</span><br><span class="hljs-setting">name=<span class="hljs-value">nginx repo</span></span><br><span class="hljs-setting">baseurl=<span class="hljs-value">http://nginx.org/packages/centos/<span class="hljs-number">7</span>/<span class="hljs-variable">$basearch</span>/</span></span><br><span class="hljs-setting">gpgcheck=<span class="hljs-value"><span class="hljs-number">0</span></span></span><br><span class="hljs-setting">enabled=<span class="hljs-value"><span class="hljs-number">1</span></span></span><br></code></pre>

<p></p><ol start="2"><li rel="2">安装，<code>sudo yum install nginx</code></li>
<li rel="3">启动，<code>service nginx start</code></li>
<li rel="3">查看启动状态，<code>service nginx status</code> OR <code>systemctl status nginx.service</code> <br></li></ol><p></p>

<blockquote>
  Default configuration directory: /etc/nginx/ <br>
  Default SSL and vhost config directory: /etc/nginx/conf.d/ <br>
  Default log file directory: /var/log/nginx/ <br>
  Default document root directory: /usr/share/nginx/html <br>
  Default configuration file: /etc/nginx/nginx.conf <br>
  Default server access log file: /var/log/nginx/access.log <br>
  Default server access log file: /var/log/nginx/error.log <br>
  <br>
  CentOS 7 默认使用firewall，不是iptables。在不开防火墙的情况下，80端口默认是关闭的，必须开放80端口，才能访问服务器 <br>
  <code>firewall-cmd --zone=public --add-port=80/tcp --permanent</code> <br>
  <code>firewall-cmd --reload</code> <br>
   <code>firewall-cmd --list-ports</code>

  </blockquote>


<h3 id="ssh登录服务器"><a href="#ssh登录服务器" class="headerlink" title="ssh登录服务器"></a>ssh登录服务器</h3><p><code>ssh username@domain
$ ssh -p vps 端口号 root@vpsIP 地址
示例:  ssh -p 27887 root@104.224.173.167</code></p>
<p>新建文件夹:<br><code>mkdir /tmp/wp</code></p>
<p>查看80端口是否被占用<br><code>sudo netstat -tnlp | grep :80  or   ss -tnlp | grep :80</code></p>
<h3 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h3><p>查看docker程序是否正常工作<br><code>sudo docker info</code></p>
<p>常看 docker 运行<br><code>docker ps -a</code></p>
<p><code>yum install docker</code> #安装docker<br><code>systemctl start docker.service</code>#启动docker<br><code>systemctl enable docker.service</code> #docker开机启动<br><code>docker -v</code> #查看docker版本<br><code>docker info</code> #查看docker具体信息<br><code>docker pull centos</code>#下载官网centos image<br><code>docker images</code> #显示已有image<br><code>docker stop $(docker ps -a -q)</code>#停止所有容器<br><code>docker stop container_id</code> #停止特定容器<br><code>docker rm $(docker ps -a -q)</code> #删除所有container<br><code>docker rmi $(docker images -q)</code> #删除所有image<br><code>docker inspect container_name</code> #查看容器信息<br><code>docker inspect container_name | grep IPAddress</code> #查看当前容器ip地地址<br><code>docker attach --sig-proxy=false 304f5db405ec</code>  (按control +c 退出不停止容器)<br><code>docker commit</code>  &lt;容器id&gt;  &lt;新镜像名称&gt;<br><code>docker rmi  imageid</code> #删除image<br><code>sudo usermod -a -G docker wisely</code>#非root用户使用<br><code>docker run -i -t centos /bin/bash</code> #启动系统 此方式运行的容器，退出后容器就会关闭。</p>
<p>进入 docker 容器<br><code>docker exec -ti phabricator bash</code></p>
<h3 id="Linux-命令"><a href="#Linux-命令" class="headerlink" title="Linux 命令"></a>Linux 命令</h3><p>新建一个文件夹<br><code>/srv/docker</code></p>
<p>权限问题<br><code>sudo chmod -R 777 /srv/</code></p>
<p>结束程序:<br><code>killall -9 wnTKYg</code></p>
<p>查看是否有 java程序<br><code>ps aux | grep java</code></p>
<p>查看临时文件夹<br><code>ls /tmp/</code></p>
<p>查看所有的东西<br><code>ls la</code></p>
<p>查看操作系统的版本<br><code>cat /etc/redhat-release</code></p>
<p>查看当前打开的端口<br><code>netstat –an</code></p>
<p>查看磁盘信息<br><code>fdisk –l</code><br><code>df –h</code></p>
<p>查看cpu的信息<br><code>cat /proc/cpuinfo</code></p>
<p>查看内存信息<br><code>cat /proc/meminfo</code></p>
<p>查看板卡信息<br><code>lspci</code><br><code>cat /proc/pci</code></p>
<p>查看当前系统运行情况<br><code>ps –aux</code></p>
<p>输入下面的ps命令，显示所有运行中的进程：<br><code>ps aux | less</code></p>
<p>scp 复制<br><code>scp [OPTIONS] file_source file_target</code></p>
<blockquote>
<p>OPTIONS：<br>-v 和大多数 linux命令中的-v意思一样，用来显示进度。可以用来查看连接、认证、或是配置错误<br>-C 使能压缩选项<br>-P 选择端口<br>-r 复制目录<br>示例:<br><code>scp /Users/rookie/Desktop/appdistribute.zip root@218.61.208.73:/home/test</code></p>
</blockquote>
<h3 id="安装-zip-unzip"><a href="#安装-zip-unzip" class="headerlink" title="安装 zip unzip"></a>安装 zip unzip</h3><p>检查是否有包含 zip（unzip） 的软件包<br><code>yum provides zip</code></p>
<p>安装 zip、unzip</p>
<figure class="highlight plain"><figcaption><span>yum install zip  </span></figcaption><table><tr><td class="code"><pre><span class="line">$ yum install unzip</span><br></pre></td></tr></table></figure>

<p>常用命令<br> 将当前目录下的所有文件和文件夹全部压缩成 myfile.zip 文件，-r 表示递归压缩子目录下所有文件.<br><code>zip -r myfile.zip ./*</code></p>
<p> 把 myfile.zip 文件解压到 /home/sunny/<br> -o ：不提示的情况下覆盖文件<br> -d：将文件解压缩到指定目录下<br><code>unzip -o -d /home/sunny myfile.zip</code></p>
<p> 删除压缩文件中 smart.txt 文件<br> <code>zip -d myfile.zip smart.txt</code></p>
<p>向压缩文件中 myfile.zip 中添加 rpm_info.txt 文件<br> <code>zip -m myfile.zip ./rpm_info.txt</code></p>
<h3 id="wget-安装与配置"><a href="#wget-安装与配置" class="headerlink" title="wget 安装与配置"></a>wget 安装与配置</h3><p> 安装<br> <code>yum -y install wget</code></p>
<h3 id="centOS-分区"><a href="#centOS-分区" class="headerlink" title="centOS 分区"></a>centOS 分区</h3><p> <a href="http://support.hwclouds.com/usermanual-ecs/zh-cn_topic_0048217143.html" target="_blank" rel="noopener">华为云参照</a></p>
<h3 id="淘宝资料"><a href="#淘宝资料" class="headerlink" title="淘宝资料"></a>淘宝资料</h3><p><a href="http://116.62.27.51/bc-atlassian-jira-software-7.3.1.zip" target="_blank" rel="noopener">http://116.62.27.51/bc-atlassian-jira-software-7.3.1.zip</a><br><a href="http://116.62.27.51/bc-atlassian-confluence-6.2.0.zip" target="_blank" rel="noopener">http://116.62.27.51/bc-atlassian-confluence-6.2.0.zip</a><br><a href="http://116.62.27.51/jdk-8u91-linux-x64.tar.gz" target="_blank" rel="noopener">http://116.62.27.51/jdk-8u91-linux-x64.tar.gz</a><br><a href="http://116.62.27.51/xx/jira安装指南v1.0.pdf" target="_blank" rel="noopener">http://116.62.27.51/xx/jira安装指南v1.0.pdf</a><br><a href="http://116.62.27.51/xx/confluence安装指南v1.1.pdf" target="_blank" rel="noopener">http://116.62.27.51/xx/confluence安装指南v1.1.pdf</a><br>对方消息中包含的链接安全性未知，请谨慎访问。<br><a href="http://116.62.27.51/AdminJIRAServer073-130117-0317-654.pdf" target="_blank" rel="noopener">http://116.62.27.51/AdminJIRAServer073-130117-0317-654.pdf</a></p>
<h3 id="jira"><a href="#jira" class="headerlink" title="jira"></a>jira</h3><p>superadmin superadmin</p>
<p>service jira stop关闭</p>
<p>service jira start启动</p>
<p>service confluence stop</p>
<p>service confluence start</p>
<h3 id="安装-sbDoc"><a href="#安装-sbDoc" class="headerlink" title="安装 sbDoc"></a>安装 sbDoc</h3><ol>
<li>安装Development Tools<br><code># yum group install &quot;Development Tools&quot;</code></li>
</ol>
<p>1.1 验证是否成功</p>
<p><code>[kael@localhost Download]$ whereis gcc</code><br><code>gcc: /usr/bin/gcc /usr/lib/gcc /usr/libexec/gcc /usr/share/man/man1/gcc.1.gz
[kael@localhost Download]$ gcc --version
gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-4)
Copyright (C) 2015 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></p>
<ol start="2">
<li>安装 nodejs<br><code>wget https://nodejs.org/dist/v6.11.0/node-v6.11.0.tar.gz</code></li>
<li>1 解压<br><code>tar -xvf node-v6.11.0.tar.gz</code></li>
<li>2 进入 node目录<br><code>cd node-v6.11.0</code></li>
<li>3 执行脚本<br><code>./configure</code></li>
<li>4 编译代码<br><code>make</code></li>
<li>5 编译完成之后，安装到本地<br><code>make install</code></li>
<li>6 安装完成，接下来验证一下<br><code>[kael@localhost node-v6.9.1]$ node --version
v6.9.1</code><br>安装完成</li>
</ol>
<p>查看正在运行<br><code>ps -ef | grep mongo</code></p>
<h3 id="CentOS-中使用-yum-安装-mongodb"><a href="#CentOS-中使用-yum-安装-mongodb" class="headerlink" title="CentOS 中使用 yum 安装 mongodb"></a><a href="http://yijiebuyi.com/blog/9daac70a111e4c3298a4cb69b5dc6214.html" target="_blank" rel="noopener">CentOS 中使用 yum 安装 mongodb</a></h3>]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 项目添加 React Native</title>
    <url>/2017/05/03/reactnativeaddios/</url>
    <content><![CDATA[<h3 id="package-json-中的版本号"><a href="#package-json-中的版本号" class="headerlink" title="package.json 中的版本号"></a>package.json 中的版本号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;testReactNative&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;16.0.0-alpha.12&quot;,</span><br><span class="line">    &quot;react-native&quot;: &quot;0.45.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<blockquote>
<p>需要注意 react版本号 , 和 react-native 版本号<br>这里需要注意”react-native”: “0.45.1”, “react”: “16.0.0-alpha.12”, , 可能会报错,<br>修改成: “react”: “16.0.0-alpha.6”,<br>        “react-native”: “0.46.1”<br>有待测试</p>
</blockquote>
<h3 id="podfile-中需要添加-yoga"><a href="#podfile-中需要添加-yoga" class="headerlink" title="podfile 中需要添加 yoga"></a>podfile 中需要添加 yoga</h3><pre><code>[!] Unable to find a specification for `Yoga (= 0.42.3.React)` depended upon by `React/Core`</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Your &apos;node_modules&apos; directory is probably in the root of your project,</span><br><span class="line">  # but if not, adjust the `:path` accordingly</span><br><span class="line">  pod &apos;Yoga&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/yoga&apos; </span><br><span class="line">  pod &apos;React&apos;, :path =&gt; &apos;../node_modules/react-native&apos;, :subspecs =&gt; [</span><br><span class="line">      &apos;Core&apos;,</span><br><span class="line">      &apos;RCTText&apos;,</span><br><span class="line">      &apos;RCTNetwork&apos;,</span><br><span class="line">      &apos;RCTWebSocket&apos;, # needed for debugging</span><br><span class="line">      # Add any other subspecs you want to use in your project</span><br><span class="line">  ]</span><br><span class="line">  pod &apos;Yoga&apos;, :path =&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注意配配置-podfiel-的路径问题"><a href="#注意配配置-podfiel-的路径问题" class="headerlink" title="注意配配置 podfiel 的路径问题"></a>注意配配置 podfiel 的路径问题</h3><pre><code>pod &apos;Yoga&apos;, :path =&gt; &apos;../node_modules/react-native/ReactCommon/yoga&apos;</code></pre><h3 id="JavaScriptCore-h-file-not-found-问题"><a href="#JavaScriptCore-h-file-not-found-问题" class="headerlink" title="JavaScriptCore.h file not found 问题"></a>JavaScriptCore.h file not found 问题</h3><blockquote>
<p>pod请升级到1.2.1以上 ,<br>这里也可能是 react native 版本问题</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">更新gem：sudo gem update --system</span><br><span class="line">删除gem源：gem sources --remove https://ruby.taobao.org/</span><br><span class="line">修改gem源：gem sources -a https://gems.ruby-china.org</span><br><span class="line">查看gem源是否是最新的：gem sources -l</span><br><span class="line">升级cocoapods：sudo gem install -n /usr/local/bin cocoapods --pre</span><br><span class="line">查看升级后的cocoapods版本：pod --version</span><br><span class="line">卸载:sudo gem uninstall cocoapods</span><br><span class="line">安装:sudo gem install cocoapods</span><br><span class="line">安装特定版本:sudo gem install cocoapods -v 0.35.0</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/facebook/react-native/issues/13010" target="_blank" rel="noopener">问题地址</a></p>
<h3 id="设置允许Http请求"><a href="#设置允许Http请求" class="headerlink" title="设置允许Http请求:"></a>设置允许Http请求:</h3><blockquote>
<p>直接运行项目会报Could not connect to development server错误<br>解决方式：打开info.plist文件，添加下面配置即可：<br>如果有在 appdelegate崩溃处崩溃的, 可能也是因为没有允许 http 请求</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;  </span><br><span class="line">&lt;dict&gt;  </span><br><span class="line">    &lt;key&gt;NSExceptionDomains&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;localhost&lt;/key&gt;</span><br><span class="line">        &lt;dict&gt;</span><br><span class="line">            &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt;</span><br><span class="line">            &lt;true/&gt;</span><br><span class="line">        &lt;/dict&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br></pre></td></tr></table></figure>



<h3 id="帮助地址"><a href="#帮助地址" class="headerlink" title="帮助地址"></a>帮助地址</h3><p><a href="http://facebook.github.io/react-native/releases/0.42/docs/integration-with-existing-apps.html#app-transport-security" target="_blank" rel="noopener">官方说明文档</a><br><a href="http://www.jianshu.com/p/3dc9d70a790f" target="_blank" rel="noopener">简书中文 - React Native 集成到原生项目(iOS)</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>reactnative</tag>
      </tags>
  </entry>
  <entry>
    <title>我的作品</title>
    <url>/2017/05/02/mycreation/</url>
    <content><![CDATA[<p><code>有一部分软件已经下架或者需要硬件支持，如果不能下载请查看作品截图。</code></p>
<h3 id="小E办公"><a href="#小E办公" class="headerlink" title="小E办公"></a>小E办公</h3><h4 id="作品链接"><a href="#作品链接" class="headerlink" title="作品链接"></a>作品链接</h4><blockquote>
<p>使用语言： OC 在线迭代中，内管OA软件</p>
</blockquote>
<p><a href="https://appsto.re/cn/XAjT-.i" target="_blank" rel="noopener">App Store地址</a></p>
<h4 id="作品截图"><a href="#作品截图" class="headerlink" title="作品截图"></a>作品截图</h4><p><img src="http://static.zybuluo.com/Rookie/o6lrgh8fklqhxq7xuqehvpzb/image_1bm1onhtobbe1s14mj41drmtvv2d.png" alt="image_1bm1onhtobbe1s14mj41drmtvv2d.png-731.1kB"></p>
<a id="more"></a>

<h3 id="闹吧"><a href="#闹吧" class="headerlink" title="闹吧"></a>闹吧</h3><h4 id="作品链接-1"><a href="#作品链接-1" class="headerlink" title="作品链接"></a>作品链接</h4><blockquote>
<p>使用语言： OC  软件需要硬件支持</p>
</blockquote>
<p><a href="https://appsto.re/cn/eMcjgb.i" target="_blank" rel="noopener">App Store地址</a></p>
<h4 id="作品截图-1"><a href="#作品截图-1" class="headerlink" title="作品截图"></a>作品截图</h4><p><img src="http://static.zybuluo.com/Rookie/vnxhtsol9qx1y534995l5opx/image_1bm1ol5dv1sb0s011rq311g72a320.png" alt="image_1bm1ol5dv1sb0s011rq311g72a320.png-239kB"></p>
<h3 id="V51音乐"><a href="#V51音乐" class="headerlink" title="V51音乐"></a>V51音乐</h3><blockquote>
<p>使用语言：OC 已下架</p>
</blockquote>
<h4 id="作品截图-2"><a href="#作品截图-2" class="headerlink" title="作品截图"></a>作品截图</h4><p><img src="http://static.zybuluo.com/Rookie/ei9ojmn5yq5vweoco3cbmhjm/image_1bm1or7p11o0b1bj2fhddag1mbq3a.png" alt="image_1bm1or7p11o0b1bj2fhddag1mbq3a.png-1016.1kB"></p>
<h3 id="粮多多"><a href="#粮多多" class="headerlink" title="粮多多"></a>粮多多</h3><h4 id="作品链接-2"><a href="#作品链接-2" class="headerlink" title="作品链接"></a>作品链接</h4><blockquote>
<p>使用语言： OC   项目还在开发阶段</p>
</blockquote>
<p><a href="https://appsto.re/cn/r47Ykb.i" target="_blank" rel="noopener">App Store地址</a></p>
<h4 id="作品截图-3"><a href="#作品截图-3" class="headerlink" title="作品截图"></a>作品截图</h4><p><img src="http://static.zybuluo.com/Rookie/rv7dqjnshqrnb4wzbfye3dd7/image_1bm1ohv7l1cpe1kcpnbn1r6b18at1j.png" alt="image_1bm1ohv7l1cpe1kcpnbn1r6b18at1j.png-788.5kB"></p>
<h3 id="假期管理"><a href="#假期管理" class="headerlink" title="假期管理"></a>假期管理</h3><blockquote>
<p>使用语言： Swift   项目暂时未上架</p>
</blockquote>
<h4 id="作品截图-4"><a href="#作品截图-4" class="headerlink" title="作品截图"></a>作品截图</h4><p><img src="http://static.zybuluo.com/Rookie/1vh87yxstl2px63fsaqmu8re/image_1bm1oaaskpf61rglrbsd67v0f9.png" alt="image_1bm1oaaskpf61rglrbsd67v0f9.png-398kB"></p>
<h3 id="智慧党建"><a href="#智慧党建" class="headerlink" title="智慧党建"></a>智慧党建</h3><blockquote>
<p>使用语言：Swift  项目暂时未上架</p>
</blockquote>
<h4 id="作品截图-5"><a href="#作品截图-5" class="headerlink" title="作品截图"></a>作品截图</h4><p><img src="http://static.zybuluo.com/Rookie/j5vf5dq6ho97g66upzai2w84/image_1bm1oe2uahnu55n11aitu1hpmm.png" alt="image_1bm1oe2uahnu55n11aitu1hpmm.png-741.2kB"></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>作品</tag>
      </tags>
  </entry>
  <entry>
    <title>配置多个 SSH Key</title>
    <url>/2017/04/03/sshkey/</url>
    <content><![CDATA[<p>起因<br>前几天同事问我, 一个Mac 下怎么配置多个 SSH key , 使用场景是 SSH key 可以连接 github 和 公司自己的 gitlab. 之前也碰到过这样的问题, 同事说要配置 config 文件 , 我说不用啊 , 经过研究发现实力打脸, 在不配置 config情况下, 只有id_rsa.pub 类型的 SSH Key 是好用的 , 其余的重新起名字的都没有办法生效. 实力打脸 ,发现自己都是通过 http来 clone 的, 拍拍拍</p>
<a id="more"></a>

<hr>
<p>SSH Key 是什么<br>SSH 密钥对可以让您方便的登录到 SSH 服务器，而无需输入密码。由于您无需发送您的密码到网络中，SSH 密钥对被认为是更加安全的方式。再加上使用密码短语 (passphrase) 的使用，安全性会更上一层楼。 同时，我们可以使用 SSH agent 来帮助我们记住密码短语，无需我们记住每一个密钥对的密码短语，减轻了我们的负担。</p>
<hr>
<p>多个SSH Key<br>生成1个SSH Key:</p>
<blockquote>
<p>$ ssh-keygen -t rsa -C “<a href="mailto:youremail@xxx.com" target="_blank" rel="noopener">youremail@xxx.com</a>“</p>
</blockquote>
<p>按回车后：</p>
<blockquote>
<p>Generating public/private rsa key pair.<br>Enter file in which to save the key (/Users/Shinancao/.ssh/id_rsa): id_rsa_TestSSH_github(取个名字)<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in<br>id_rsa_TestSSH_github.<br>Your public key has been saved in<br>id_rsa_TestSSH_github.pub.</p>
</blockquote>
<p>最好每次生成时都给SSH Key取个名字，这样后面在管理时自己也一目了然。我这里的格式是idrsa项目名git提供方，我生成的所有key都遵循这个规则命名。建议你也有你自己的一种命名方式，并且保持统一。如果不取名字，默认的是idrsa，如果后面生成时不命名，会把这个覆盖掉。密码可以不设置，免得每次提交时还要输入一次，安全性自己衡量吧。第一次生成key时，会在~目录下创建一个.ssh目录。</p>
<blockquote>
<p>cd ~/.ssh<br>$ ls</p>
</blockquote>
<p>把idrsaTestSSH_github.pub添加到github对应的项目的Deploy keys中。<br>创建本地的配置文件 ~/.ssh/config，编辑如下：</p>
<blockquote>
<p>Host TestSSH.github.com<br>    HostName github.com<br>    User git<br>    PreferredAuthentications publickey<br>    IdentityFile ~/.ssh/id_rsa_TestSSH_github<br>Host YourProjectName.gitlab.com<br>    HostName gitlab.com<br>    User git<br>    PreferredAuthentications publickey<br>    IdentityFile ~/.ssh/id_rsa_YourProjectName_gitlab</p>
</blockquote>
<p>Host的名字可以随意取，我这边按照的规则是项目名.git服务器来源，接下来会用到这个名字。测试是否配置正确：</p>
<blockquote>
<p>ssh -T <a href="mailto:git@TestSSH.github.com" target="_blank" rel="noopener">git@TestSSH.github.com</a> (就是刚刚你给Host取的名字)</p>
</blockquote>
<p>敲一下回车，如下出现下面的提示就连接成功了：</p>
<blockquote>
<p>Hi shinancao/TestSSH! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
</blockquote>
<p>基本上就大功告成了 . 后面还有一些别的设置, 可以查看参考连接<br>最后放出我自己的 config 文件</p>
<blockquote>
<p>#######github– myself<br>Host github.com<br>HostName github.com<br>User <a href="mailto:411152955@qq.com" target="_blank" rel="noopener">411152955@qq.com</a><br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/myself  </p>
</blockquote>
<blockquote>
<p>#######github – ued<br>Host github.com<br>HostName github.com<br>User <a href="mailto:ued@tton.co" target="_blank" rel="noopener">ued@tton.co</a><br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/github_ued</p>
</blockquote>
<blockquote>
<p>#######tton gitlab<br>Host git.tton.co<br>HostName git.tton.co<br>User <a href="mailto:liuyafang@tton.co" target="_blank" rel="noopener">liuyafang@tton.co</a><br>IdentityFile ~/.ssh/git_tton_rsa</p>
</blockquote>
<p>忠告<br>好好学习, 不被打脸…..</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://shinancao.github.io/2016/12/18/Programming-Git-1/" target="_blank" rel="noopener">同一个Mac，配置多个SSH Key</a><br><a href="https://wiki.archlinux.org/index.php/SSH_keys_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">SSH keys</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>常用代码快整理</title>
    <url>/2017/03/25/daimakuai/</url>
    <content><![CDATA[<p>##注释代码快</p>
<ul>
<li>方法注释<br><code>快捷键 - gg</code></li>
</ul>
<blockquote>
<p>/**</p>
</blockquote>
<ul>
<li>//MARK: &lt;#mark#&gt;</li>
<li>@author: rookie</li>
<li>Time: &lt;#time#&gt;</li>
<li>params: &lt;#params#&gt;</li>
<li>/</li>
</ul>
<a id="more"></a>



<ul>
<li>警告注释<br><code>快捷键 - ww</code></li>
</ul>
<blockquote>
<p>/**</p>
</blockquote>
<ul>
<li>//!!!: &lt;#mark#&gt; !!!—警告注释, 前方高能, 注意躲避</li>
<li>@author: rookie</li>
<li>Time: &lt;#time#&gt;</li>
<li>params: &lt;#params#&gt;</li>
<li>/</li>
</ul>
<ul>
<li>属性注释<br><code>快捷键 - ss</code></li>
</ul>
<blockquote>
<p>/<em>* &lt;#属性注释#&gt;</em>/</p>
</blockquote>
<p>##属性代码快</p>
<ul>
<li>copy:<blockquote>
<p>/** &lt;#注释#&gt; */<br>@property (nonatomic,copy) NSString *&lt;#string#&gt;;</p>
</blockquote>
</li>
</ul>
<ul>
<li>strong:<blockquote>
<p>/** &lt;#注释#&gt; */<br>@property (nonatomic,strong) &lt;#Class#&gt; *&lt;#object#&gt;;</p>
</blockquote>
</li>
</ul>
<ul>
<li>weak:<blockquote>
<p>/** &lt;#注释#&gt; */<br>@property (nonatomic,weak) &lt;#Class#&gt; *&lt;#object#&gt;;</p>
</blockquote>
</li>
</ul>
<ul>
<li>assign:<blockquote>
<p>/** &lt;#注释#&gt; */<br>@property (nonatomic,assign) &lt;#Class#&gt; &lt;#property#&gt;;</p>
</blockquote>
</li>
</ul>
<ul>
<li>delegate:<blockquote>
<p>/** &lt;#注释#&gt; */<br>@property (nonatomic,weak) id&lt;&lt;#protocol#&gt;&gt; &lt;#delegate#&gt;;</p>
</blockquote>
</li>
</ul>
<ul>
<li>block:<blockquote>
<p>/** &lt;#注释#&gt; */<br>@property (nonatomic,copy) &lt;#Block#&gt; &lt;#block#&gt;;</p>
</blockquote>
</li>
</ul>
<p>##tableview代码快</p>
<blockquote>
<p><code>#pragma mark - tableView Delegate</code><br>-(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView<br>{<br>    return 1;<br>}<br>-(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section<br>{<br>    return &lt;#expression#&gt;<br>}<br>-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath<br>{<br>    return &lt;#expression#&gt;<br>}<br>-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath<br>{<br>    &lt;#classCell#&gt; * cell = [tableView dequeueReusableCellWithIdentifier:&lt;#(nonnull NSString *)#&gt;];<br>    return cell;<br>}<br>-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath<br>{<br>        [tableView deselectRowAtIndexPath:indexPath animated:NO];<br>}</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>代码块</tag>
      </tags>
  </entry>
  <entry>
    <title>分发平台调研</title>
    <url>/2017/03/08/fenfa/</url>
    <content><![CDATA[<h3 id="Fim-im"><a href="#Fim-im" class="headerlink" title="Fim.im"></a><a href="https://fir.im" target="_blank" rel="noopener">Fim.im</a></h3><table>
<thead>
<tr>
<th>价格</th>
<th align="right">下载次数</th>
<th align="center">赠送</th>
</tr>
</thead>
<tbody><tr>
<td>￥25</td>
<td align="right">1,000</td>
<td align="center">0</td>
</tr>
<tr>
<td>￥225</td>
<td align="right">10,000</td>
<td align="center">1666</td>
</tr>
<tr>
<td>￥2000</td>
<td align="right">100,000</td>
<td align="center">18888</td>
</tr>
</tbody></table>
<a id="more"></a>


<hr>
<h3 id="蒲公英"><a href="#蒲公英" class="headerlink" title="蒲公英"></a><a href="https://www.pgyer.com/?utm_source=next.36kr.com" target="_blank" rel="noopener">蒲公英</a></h3><table>
<thead>
<tr>
<th>价格</th>
<th align="right">下载次数</th>
<th align="center">短信/邮件通知</th>
</tr>
</thead>
<tbody><tr>
<td>￥0 / 月</td>
<td align="right">300</td>
<td align="center">5</td>
</tr>
<tr>
<td>￥39 / 月</td>
<td align="right">2,000</td>
<td align="center">60</td>
</tr>
<tr>
<td>￥199/月</td>
<td align="right">10,000</td>
<td align="center">1,000</td>
</tr>
</tbody></table>
<hr>
<h3 id="大福分发托管平台"><a href="#大福分发托管平台" class="headerlink" title="大福分发托管平台"></a><a href="http://dafuvip.com" target="_blank" rel="noopener">大福分发托管平台</a></h3><p>APP &lt; 100M</p>
<table>
<thead>
<tr>
<th>价格</th>
<th align="right">下载次数</th>
<th align="center">赠送</th>
</tr>
</thead>
<tbody><tr>
<td>￥35</td>
<td align="right">100</td>
<td align="center">0</td>
</tr>
<tr>
<td>￥105</td>
<td align="right">3,000</td>
<td align="center">200</td>
</tr>
<tr>
<td>￥350</td>
<td align="right">10,000</td>
<td align="center">1,000</td>
</tr>
</tbody></table>
<p>APP &lt; 300M</p>
<table>
<thead>
<tr>
<th>价格</th>
<th align="right">下载次数</th>
<th align="center">赠送</th>
</tr>
</thead>
<tbody><tr>
<td>￥100</td>
<td align="right">1,000</td>
<td align="center">0</td>
</tr>
<tr>
<td>￥300</td>
<td align="right">3,000</td>
<td align="center">200</td>
</tr>
<tr>
<td>￥1000</td>
<td align="right">10,000</td>
<td align="center">1,000</td>
</tr>
</tbody></table>
<hr>
<h3 id="Pre"><a href="#Pre" class="headerlink" title="Pre"></a><a href="http://pre.im" target="_blank" rel="noopener">Pre</a></h3><ul>
<li>内测分发(暂时免费), Appstore 加速审核</li>
</ul>
<hr>
<h3 id="Testin"><a href="#Testin" class="headerlink" title="Testin"></a><a href="http://www.testin.cn" target="_blank" rel="noopener">Testin</a></h3><ul>
<li>测试分发平台 ,主要针对测试兼容,性能,安全等测试,也有分发功能. </li>
</ul>
<hr>
<h3 id="TestFlight"><a href="#TestFlight" class="headerlink" title="TestFlight"></a>TestFlight</h3><ul>
<li>iOS 平台专用</li>
<li>支持 iOS8+</li>
<li>内部测试人员最多25个, 外部测试最多2000人,并且有效测试时间为60天</li>
</ul>
<hr>
<h2 id="国外分发"><a href="#国外分发" class="headerlink" title="国外分发"></a>国外分发</h2><h3 id="HockeyApp"><a href="#HockeyApp" class="headerlink" title="HockeyApp"></a><a href="http://hockeyapp.net/" target="_blank" rel="noopener">HockeyApp</a></h3><p>HockeyApp 是一个最佳的方法用来分发你的程序并收集应用的崩溃报告的测试平台，支持 Mac OS X 、iOS 和 Android 平台。</p>
<h3 id="个人觉得"><a href="#个人觉得" class="headerlink" title="个人觉得"></a>个人觉得</h3><p>目前分发平台有很多,好用的都有收费服务. 但是每天还是有一定免费下载量.而且目前就 Appstore 以及安卓各个渠道来讲审核速度都比较快,程序快速迭代也完全没有问题.</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>分发平台</tag>
      </tags>
  </entry>
  <entry>
    <title>InfoPlist 权限</title>
    <url>/2017/02/14/infoplist/</url>
    <content><![CDATA[<blockquote>
<p>提交到 Appstore 后, 如果没有报错. 构建找不到的话, 请到开发者邮箱查看是否有描述填写不完整</p>
</blockquote>
<a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 相册 --&gt; </span><br><span class="line">&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt; </span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问相册&lt;/string&gt; </span><br><span class="line">&lt;!-- 相机 --&gt; </span><br><span class="line">&lt;key&gt;NSCameraUsageDescription&lt;/key&gt; </span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问相机&lt;/string&gt; </span><br><span class="line">&lt;!-- 麦克风 --&gt; </span><br><span class="line">&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; </span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问麦克风&lt;/string&gt; </span><br><span class="line">&lt;!-- 位置 --&gt; </span><br><span class="line">&lt;key&gt;NSLocationUsageDescription&lt;/key&gt; </span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问位置&lt;/string&gt; </span><br><span class="line">&lt;!-- 在使用期间访问位置 --&gt; </span><br><span class="line">&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt; </span><br><span class="line">&lt;string&gt;App需要您的同意,才能在使用期间访问位置&lt;/string&gt; </span><br><span class="line">&lt;!-- 始终访问位置 --&gt; </span><br><span class="line">&lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt; </span><br><span class="line">&lt;string&gt;App需要您的同意,才能始终访问位置&lt;/string&gt; </span><br><span class="line">&lt;!-- 日历 --&gt; </span><br><span class="line">&lt;key&gt;NSCalendarsUsageDescription&lt;/key&gt; </span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问日历&lt;/string&gt; </span><br><span class="line">&lt;!-- 提醒事项 --&gt; </span><br><span class="line">&lt;key&gt;NSRemindersUsageDescription&lt;/key&gt; </span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问提醒事项&lt;/string&gt; </span><br><span class="line">&lt;!-- 运动与健身 --&gt; </span><br><span class="line">&lt;key&gt;NSMotionUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问运动与健身&lt;/string&gt; </span><br><span class="line">&lt;!-- 健康更新 --&gt; </span><br><span class="line">&lt;key&gt;NSHealthUpdateUsageDescription&lt;/key&gt; </span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问健康更新 &lt;/string&gt; </span><br><span class="line">&lt;!-- 健康分享 --&gt; </span><br><span class="line">&lt;key&gt;NSHealthShareUsageDescription&lt;/key&gt; </span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问健康分享&lt;/string&gt; </span><br><span class="line">&lt;!-- 蓝牙 --&gt; </span><br><span class="line">&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt; </span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问蓝牙&lt;/string&gt; </span><br><span class="line">&lt;!-- 媒体资料库 --&gt; </span><br><span class="line">&lt;key&gt;NSAppleMusicUsageDescription&lt;/key&gt; </span><br><span class="line">&lt;string&gt;App需要您的同意,才能访问媒体资料库&lt;/string&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title>OC代码规范</title>
    <url>/2017/01/09/objectCnorm/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/01192DC1-B6CE-4EFD-B1C7-324D97753915.png?imageView2/1/w/600/h/300"/>
<a id="more"></a>
Objective-C 编码规范
======================

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><a name='TOC'/></a>目录</h2><ul>
<li><a href="#folder-structure">目录结构</a><ul>
<li><a href="#project-structure">项目目录</a></li>
<li><a href="#resource-structure">资源目录</a></li>
</ul>
</li>
<li><a href="#naming">命名</a><ul>
<li><a href="#naming-basic-principle">基本原则</a></li>
<li><a href="#namespace">命名空间</a></li>
<li><a href="#naming-viewcontroller">视图命名</a></li>
<li><a href="#naming-method">方法名</a></li>
<li><a href="#naming-protocol">协议名</a></li>
<li><a href="#naming-notifications">通知命名</a></li>
<li><a href="#naming-temporary-variable">临时变量命名</a></li>
<li><a href="#naming-constant">常量命名</a></li>
<li><a href="#naming-resource">资源名</a></li>
<li><a href="#naming-match-case">大小写</a></li>
<li><a href="#abbreviation">缩写</a></li>
<li><a href="#naming-others">其他</a></li>
</ul>
</li>
<li><a href="#formatting">代码格式化</a><ul>
<li><a href="#spaces">空格</a></li>
<li><a href="#braces">花括号</a></li>
<li><a href="#line-wrap">折行</a></li>
</ul>
</li>
<li><a href="#code-organization">代码组织</a></li>
<li><a href="#class">类</a><ul>
<li><a href="#property-attributes">Property attributes</a></li>
</ul>
</li>
<li><a href="#comment">注释</a><ul>
<li><a href="#block-comment">块注释</a> </li>
</ul>
</li>
<li><a href="#others">其他</a><ul>
<li><a href="#exception">异常</a></li>
</ul>
</li>
<li><a href="#reference">参考</a></li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a><a name='folder-structure'/></a>目录结构</h2><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a><a name='project-structure'></a>项目目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">———Vendors      //不使用CocoaPod时第三方类库</span><br><span class="line">———Models</span><br><span class="line">———ViewModels   //MVVM设计模式时需要使用</span><br><span class="line">———Views</span><br><span class="line">———Controllers</span><br><span class="line">———Networks </span><br><span class="line">———Utils</span><br><span class="line">   ———Category</span><br><span class="line">   ———Helpers</span><br><span class="line">   ———Tools</span><br><span class="line">———Resources</span><br><span class="line">   ———Documents</span><br><span class="line">   ———Images</span><br><span class="line">   ———Audios</span><br><span class="line">   ———Data</span><br><span class="line">———Mscros</span><br></pre></td></tr></table></figure>
<h3 id="资源目录"><a href="#资源目录" class="headerlink" title="资源目录"></a><a name='resource-structure'></a>资源目录</h3><ul>
<li>所有的需要适配的图片应该使用Xcode推荐的images.xcassets并根据使用的视图控制器分文件夹管理，通用的请放入Base文件夹</li>
<li>部分不需要适配而进行强制拉伸的图片应该以@3x比例制作并存放于Resources/Images目录  </li>
</ul>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a><a name='naming'/></a>命名</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a><a name='naming-basic-principle'></a>基本原则</h3><ul>
<li>仿照 Cocoa 风格来，使用长命名风格</li>
<li>变量命名推荐的命名语素顺序是：最开头是命名空间简写，然后越重要、区别度越大的语素越要往前放。经典的结构是：作用范围+限定修饰+类型。例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern ushort APIDefaultPageSize;        // 还行，能明白意思了</span><br><span class="line">extern ushort APIDefaultFetchPageSize;   // 加上些限定更好一些</span><br><span class="line">extern ushort APIFetchPageSizeDefault;   // 再好些，把重要的往前放</span><br><span class="line"></span><br><span class="line">YHToolbarComment    // 不推荐</span><br><span class="line">YHCommentToolbar    // OK，把类型（toolbar）置后</span><br></pre></td></tr></table></figure>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a><a name='namespace'></a>命名空间</h3><ul>
<li>类名、protocols、C 函数、常量、结构体和枚举应带有命名空间前缀；</li>
<li>类方法不要带前缀，结构体字段也不要带前缀</li>
</ul>
<h3 id="视图命名"><a href="#视图命名" class="headerlink" title="视图命名"></a><a name='naming-viewcontroller'></a>视图命名</h3><p>为了举例，我们假定有 <code>User</code>、<code>Tag</code>、<code>Category</code> 这几种 model 类型。</p>
<p>对象展示一般分列表和单个详情，其 view controller 分别使用 <strong>Model</strong>ListController 和 <strong>Model</strong>DetailController，推荐的语素顺序是：<code>Model名 + 限定与修饰 + ListController|DetailController</code>。举例说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// OK</span><br><span class="line">TagUserUsedListController</span><br><span class="line">TagInCategoryListController</span><br><span class="line">CategoryDetailController</span><br><span class="line"></span><br><span class="line">// 不推荐，列表统一使用 ListController，不指明是 table view 还是 collection view</span><br><span class="line">UserFollowerTableViewController</span><br><span class="line"></span><br><span class="line">// OK</span><br><span class="line">UserFollowerListController</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">UserLikedTagListController</span><br><span class="line"></span><br><span class="line">// OK，把显示的对象放在第一位</span><br><span class="line">TagUserLikedListController</span><br><span class="line"></span><br><span class="line">// 糟糕，如果是 view controller，必须以 Controller 或 Displayer 结尾</span><br><span class="line">TagListView</span><br></pre></td></tr></table></figure>

<p>经常为了便于多个界面复用，我们会把 model 的显示统一在一个 view controller 中，在其他界面嵌入这个 view controller。我们把这类专门管理显示的 view controller 叫做 <code>displayer</code>。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UserListDisplayer</span><br><span class="line">TagListDisplayer</span><br></pre></td></tr></table></figure>

<p>UIView 级别的组件不要以 Controller 或 Displayer 结尾，如果起到管理作用可以使用 control 结尾。</p>
<p><strong>动机</strong></p>
<blockquote>
<p>把 model 名放在首位（如 TagUserLikedListController 而不是 UserLikedTagListController）的主要考量是便于搜索。因为 Xcode 不支持乱序搜索，关键词只能从前往后才会有结果。</p>
<p>如果限定词在前，因为不同人理解差异，自己也会遗忘，这个限定词经常是输入不能的，只能搜 TagList 再从列表中查找，等于第一位的查找语素就废掉了。当 model 类型在第一位时，基本上熟悉这个项目的人都清楚要查找的视图显示的是什么类型，第一位正确了，后面添加/修改限定就很方便了。</p>
<p>另一个便利的场景是参考之前界面实现另一个界面时，查找的大都是相同类型的界面，如实现 UserFollowerListController 参考 UserFollowingListController；而相同限定的场景比较少见，像 UserLikedTagListController 参考 UserLikedCategoryListController 的可能性就较少。</p>
<p>PS: 务必经常使用 Xcode 的 Open Quickly（默认快捷键 Command+Shift+O）</p>
</blockquote>
<h3 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a><a name='naming-method'></a>方法名</h3><ul>
<li>以 <code>alloc</code>、<code>copy</code>、<code>init</code>、<code>mutableCopy</code>、<code>new</code> 开头的方法要注意，它们会改变ARC的行为。[^1]</li>
<li>以 <code>get</code>、<code>set</code> 开头的方法有特殊的意义，不要随意定义。<ol>
<li>set 是属性默认的设置方法，如果函数不是为了设置类成员，则不要用 <code>set</code> 开头，可用 <code>setup</code> 替代。</li>
<li>get 和属性方法无关，但在 Cocoa 中，其标准行为是通过引用传值，而不是直接返回结果的。欲获取变量，直接以变量名为名，如：<code>userInfomation</code>，而不是 <code>getUserInfomation</code>。</li>
</ol>
</li>
</ul>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objective-C</span><br><span class="line">// OK</span><br><span class="line">- (NSString *)name;</span><br><span class="line"></span><br><span class="line">// 糟糕，应用上面的写法</span><br><span class="line">- (NSString *)getName;</span><br><span class="line"></span><br><span class="line">// OK，但极少使用</span><br><span class="line">- (void)getName:(NSString **)buffer range:(NSRange)inRange;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// OK</span><br><span class="line">- (NSSize)cellSize;</span><br><span class="line"></span><br><span class="line">// 糟糕，应用上面的写法</span><br><span class="line">- (NSSize)calcCellSize;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">// 对 controller 做一般设置，OK</span><br><span class="line">- (void)setupController;</span><br><span class="line"></span><br><span class="line">// 列出具体设置的内容，更好</span><br><span class="line">- (void)setupControllerObservers;</span><br><span class="line"></span><br><span class="line">// 糟糕，set 专用于设置属性</span><br><span class="line">- (void)setController;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objective-C</span><br><span class="line">// 来自官方文档</span><br><span class="line">insertObject:atIndex:    // OK</span><br><span class="line">insert:at:               // 不清晰，插入了什么？at 具体指哪里？</span><br><span class="line">removeObjectAtIndex:     // OK</span><br><span class="line">removeObject:            // OK</span><br><span class="line">remove:                  // 糟糕，什么被移除了？</span><br></pre></td></tr></table></figure>

<h3 id="协议名"><a href="#协议名" class="headerlink" title="协议名"></a><a name='naming-protocol'></a>协议名</h3><p>好的协议名应能立刻让人分辨出这不是一个类名，除了以常用的 delegate、dateSource 做结尾外，还可以使用 …ing 这种形式，如：<code>NSCoding</code>、<code>NSCopying</code>、<code>NSLocking</code>。</p>
<h3 id="通知命名"><a href="#通知命名" class="headerlink" title="通知命名"></a><a name='naming-notifications'></a>通知命名</h3><p>基本命名格式是：<code>[与通知相关的类名] + [Did | Will] + [UniquePartOfName] + Notification</code>，例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objective-C</span><br><span class="line">NSApplicationDidBecomeActiveNotification</span><br><span class="line">NSWindowDidMiniaturizeNotification</span><br><span class="line">NSTextViewDidChangeSelectionNotification</span><br><span class="line">NSColorPanelColorDidChangeNotification</span><br></pre></td></tr></table></figure>

<h3 id="临时变量命名"><a href="#临时变量命名" class="headerlink" title="临时变量命名"></a><a name='naming-temporary-variable'></a>临时变量命名</h3><ul>
<li>临时变量可以写得很短，如 i、k、vc 这样；</li>
<li>临时变量可以使用匈牙利前缀，但数据类型不可以作为前缀：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// OK</span><br><span class="line">wCell, vcMaster, vToolbar</span><br><span class="line"></span><br><span class="line">// 糟糕，数据类型作为前缀</span><br><span class="line">bool_switchState, floatBoxHeight</span><br></pre></td></tr></table></figure>

<p>推荐的前缀：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ix</td>
<td>序号，起始为0</td>
</tr>
<tr>
<td>in</td>
<td>序号（自然数范围），起始为1</td>
</tr>
<tr>
<td>if</td>
<td>类型为浮点的“序号”</td>
</tr>
<tr>
<td>x</td>
<td>坐标</td>
</tr>
<tr>
<td>y</td>
<td>坐标</td>
</tr>
<tr>
<td>w</td>
<td>宽度</td>
</tr>
<tr>
<td>h</td>
<td>高度</td>
</tr>
<tr>
<td>vc</td>
<td>视图控制器</td>
</tr>
<tr>
<td>v</td>
<td>视图</td>
</tr>
</tbody></table>
<h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a><a name='naming-constant'></a>常量命名</h3><ul>
<li>尽量避免使用预处理命令#define来定义常量，因为#define定义的 常量是全局的，会将工程中所有定义使用的标示符替换为定义的常量，可能因为定义的标示符重复而引起问题，且不易排查。  </li>
<li>尽量使用static const来进行常量的定义，好处是可以明显地知道常量的类型，且避免用预处理命令#define引起的问题  </li>
<li>用static const进行常量的定义的时候，首写字母要大写，并加小写字母前缀k</li>
<li>对于枚举常量，使用typedef NS_ENUM，对于位掩码常量，使用typedef NS_OPTION，这两个宏已经对C和C++进行了不同的枚举处理  </li>
</ul>
<p>除以上规则约定外，其他常量约定了以下前缀：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>k</td>
<td>宏常量</td>
</tr>
<tr>
<td>CDEN</td>
<td>Core Data entity name</td>
</tr>
<tr>
<td>UDk</td>
<td>User Default key</td>
</tr>
<tr>
<td>KCk</td>
<td>Key Chain key</td>
</tr>
<tr>
<td>APIURL</td>
<td>接口地址</td>
</tr>
</tbody></table>
<p>另见：<a href="#constant">常量管理</a></p>
<h3 id="资源命名"><a href="#资源命名" class="headerlink" title="资源命名"></a><a name='naming-resource'></a>资源命名</h3><p>图片资源在放入xcassets中相应视图控制器文件夹的基础上，根据<code>[相应的功能] + [Btn | BtnClick | Icon]</code>，例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UserAvatarDefaultIcon</span><br><span class="line">PostCommentBtn</span><br><span class="line">ClickShowWebsiteBtn</span><br></pre></td></tr></table></figure>

<h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a><a name='naming-match-case'></a>大小写</h3><ul>
<li>类名采用大驼峰（<code>UpperCamelCase</code>）</li>
<li>类成员、方法小驼峰（<code>lowerCamelCase</code>）</li>
<li>局部变量大小写首选小驼峰，也可使用小写下划线的形式（<code>snake_case</code>）</li>
<li>C函数的命名用大驼峰</li>
</ul>
<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a><a name='abbreviation'/></a>缩写</h3><p>可以使用广泛使用的缩写，如 <code>URL</code>、<code>JSON</code>，并且缩写要大写。但像将<code>download</code>简写为<code>dl</code>这种是不可以的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objective-C</span><br><span class="line">// OK</span><br><span class="line">ID, URL, JSON, WWW</span><br><span class="line"></span><br><span class="line">// 糟糕</span><br><span class="line">id, Url, json, www</span><br><span class="line"></span><br><span class="line">destinationSelection       // OK</span><br><span class="line">destSel                    // 糟糕</span><br><span class="line">setBackgroundColor:        // OK</span><br><span class="line">setBkgdColor:              // 糟糕</span><br></pre></td></tr></table></figure>


<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><a name='naming-others'></a>其他</h3><p>i，j专用于循环标号</p>
<p>为私有方法命名不要直接以“_”开头，而应以“命名空间_”开头。</p>
<h2 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a><a name='formatting'/></a>代码格式化</h2><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a><a name='spaces'></a>空格</h3><p>类方法声明在方法类型与返回类型之间要有空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objective-C</span><br><span class="line">// 糟糕</span><br><span class="line">-(void)methodName:(NSString *)string;</span><br><span class="line"></span><br><span class="line">// OK</span><br><span class="line">- (void)methodName:(NSString *)string;</span><br></pre></td></tr></table></figure>

<p>条件判断的括号内侧不应有空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 糟糕</span><br><span class="line">if ( a &lt; b ) &#123;</span><br><span class="line">    // something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// OK</span><br><span class="line">if (a &lt; b) &#123;</span><br><span class="line">    // something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关系运算符（如 <code>&gt;=</code>、<code>!=</code>）和逻辑运算符（如 <code>&amp;&amp;</code>、<code>||</code>）两边要有空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// OK</span><br><span class="line">(someValue &gt; 100)? YES : NO</span><br><span class="line"></span><br><span class="line">// OK</span><br><span class="line">(items)?: @[]</span><br></pre></td></tr></table></figure>

<p>二元算数运算符两侧是否加空格不确定，根据情况自己定。一元运算符与操作数之前没有空格。</p>
<p>多个参数逗号后留一个空格（这也符合正常的西文语法）。</p>
<h3 id="花括号"><a href="#花括号" class="headerlink" title="花括号"></a><a name='braces'></a>花括号</h3><p>方法的花括号推荐另起一行。方法内部需要写在一行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)methodName:(NSString *)string &#123;</span><br><span class="line"> ↑空格                                ↑空格，推荐花括号在一行</span><br><span class="line">    if () &#123;</span><br><span class="line">   空格↑  ↑空格，花括号不要另起一行</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line"> 要换行↑ ↑空格，花括号不要另起一行</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动机</strong></p>
<blockquote>
<p>Xcode 默认的花括号位置是这样的：方法内部的各种补全都是在同一行的；方法定义的比较混乱，默认模版另起一行，但从 Interface Builder 中连线生成的方法在同一行的。</p>
<p>考虑到 Xcode 的默认行为，方法内部要另起一行，方法所在行不强制定死。另外，模版可以定制，而 IB 生成的代码不可定制，所以不另起一行的写法优先。</p>
<p>另起一行的写法在代码折叠后非常难看。</p>
</blockquote>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a><a name='line-wrap'></a>空行</h3><p>相对独立的程序块之间、变量说明之后必须加空行。</p>
<h3 id="折行"><a href="#折行" class="headerlink" title="折行"></a><a name='line-wrap'></a>折行</h3><p>与多数其他规范不同，不建议手动折行。</p>
<p><strong>动机</strong></p>
<blockquote>
<p>手动折行的效果严重宽度依赖于窗口宽度——窗口过宽浪费宝贵的屏幕空间，较窄时可能无法阅读。而且 Xcode 自动折行的效果还是不错的。</p>
</blockquote>
<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a><a name='code-organization'></a>代码组织</h2><ul>
<li>函数长度（行数）不应超过100行。例外：对于顺序执行的初始化函数，如果其中的过程没有提取为独立方法的必要，则不必限制长度。</li>
<li>单个文件方法数不应超过30个</li>
<li>不要按类别排序（如把IBAction放在一块），应按任务把相关的组合在一起</li>
<li>禁止出现超过两层循环的代码，用函数或block替代。</li>
</ul>
<p>尽早返回错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 为了简化示例，没有错误处理，并使用了伪代码</span><br><span class="line"></span><br><span class="line">// 糟糕的例子</span><br><span class="line">- (Task *)creatTaskWithPath:(NSString *)path &#123;</span><br><span class="line">    Task *aTask;</span><br><span class="line">    if ([path isURL]) &#123;</span><br><span class="line">        if ([fileManager isWritableFileAtPath:path]) &#123;</span><br><span class="line">            if (![taskManager hasTaskWithPath:path]) &#123;</span><br><span class="line">                aTask = [[Task alloc] initWithPath:path];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return aTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 改写的例子</span><br><span class="line">- (Task *)creatTaskWithPath:(NSString *)path &#123;</span><br><span class="line">    if (![path isURL]) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (![fileManager isWritableFileAtPath:path]) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ([taskManager hasTaskWithPath:path]) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Task *aTask = [[Task alloc] initWithPath:path];</span><br><span class="line">    return aTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类"><a href="#类" class="headerlink" title="类"></a><a name='class'/></a>类</h2><p>禁止在类的 interface 中定义任何 iVar 成员，只允许使用属性，但可以在特定情形中使用属性生成的 iVar。</p>
<p>尽量总是使用点操作符访问属性，而不是属性生成的 iVar 变量。以下情形除外：</p>
<ul>
<li>明确要避免修改产生 KVO 通知的；</li>
<li>需重写属性 getter 或 setter 的；</li>
<li>性能分析确定使用属性会导致性能不可接受的；</li>
<li>多线程环境中，为防止互斥一次进行多个修改的；</li>
<li>init、dealloc 方法中。</li>
</ul>
<p>动机</p>
<blockquote>
<p>如果使用 iVar，很多情况要特殊处理，容易出错。总是使用成员，规则简单，不易出问题。</p>
<p>直接访问 iVar 的 block 会 retain iVar 所属的对象，这点很容易被忽略</p>
<p>定义和使用 iVar 都会产生编译警告，只不过默认设置没启用这两个警告</p>
</blockquote>
<h3 id="Property-attributes"><a href="#Property-attributes" class="headerlink" title="Property attributes"></a><a name='property-attributes'></a>Property attributes</h3><p>什么时候使用 copy？</p>
<ul>
<li>block 属性要定义成 copy。</li>
<li>当一个属性赋值后不期望改变时应当用 copy，最常见的类型如 NSString、NSURL。可变类型的成员，如 NSMutableArray、NSMutableDictionary 不能定成 copy 的。</li>
</ul>
<p>相关 Demo 可在 <a href="https://github.com/BB9z/PropertyTest" target="_blank" rel="noopener">https://github.com/BB9z/PropertyTest</a> 获得。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a><a name='constant'></a>常量</h2><p>除非调试用的、控制不同编译模式行为的常量可用宏外，其他常量不得用宏定义。</p>
<p>常量定义示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 头文件</span><br><span class="line">extern ushort APIFetchPageSizeDefault;    // 无const，可在外部修改</span><br><span class="line"></span><br><span class="line">// 实现文件</span><br><span class="line">ushort APIFetchPageSizeDefault = 10;</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><a name='comment'></a>注释</h2><p>使用Xcode插件VVDocumenter-Xcode可以有效的进行编写注释的需求<br>所有的.h文件中对外的接口方法定义中必须进行注释，而.m文件中除非已经在.h中已经注释的方法或者是get/set方法可以不注释外，其余函数必须进行注释。<br>修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。<br>最后一点，尽量让代码可以自表述，而不是依赖注释。</p>
<blockquote>
<p>注释应该表达那些代码没有表达以及无法表达的东西。如果一段注释被用于解释一些本应该由这段代码自己表达的东西，我们就应该将这段注释看成一个改变代码结构或编码惯例直至代码可以自我表达的信号。我们重命名那些糟糕的方法和类名，而不是去修补。我们选择将长函数中的一些代码段抽取出来形成一些小函数，这些小函数的名字可以表述原代码段的意图，而不是对这些代码段进行注释。尽可能的通过代码进行表达。你通过代码所能表达的和你想要表达的所有事情之间的差额将为注释提供了一个合理的候选使用场合。对那些代码无法表达的东西进行注释，而不要仅简单地注释那些代码没有表达的东西。”[^2]</p>
</blockquote>
<h3 id="块注释"><a href="#块注释" class="headerlink" title="块注释"></a><a name='block-comment'></a>块注释</h3><p>方法内部禁止使用块注释。除非要临时注释大段代码，一般情况总应使用行注释。</p>
<p><strong>动机</strong></p>
<blockquote>
<p>因为块注释不能正确嵌套。</p>
</blockquote>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a><a name='others'></a>其他</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a><a name='exception'></a>异常</h3><ul>
<li>作为被调用模块的维护者，当被调用不当时（参数有问题、不和时宜），如何处理需要考虑（抛出异常还是返回错误状态）；</li>
<li>不要依赖 try catch，它不是代替你做检查、填补遗漏的工具。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><a name='reference'></a>参考</h2><ul>
<li><a href="https://github.com/Chinamobo/iOS-Team-Norms/blob/master/CodeStyle.md" target="_blank" rel="noopener">Chinamobo Objective-C 编码规范</a></li>
<li><a href="http://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="noopener">Coding Guidelines for Cocoa</a></li>
<li><a href="https://github.com/raywenderlich/swift-style-guide" target="_blank" rel="noopener">https://github.com/raywenderlich/swift-style-guide</a></li>
<li><a href="https://github.com/github/swift-style-guide" target="_blank" rel="noopener">https://github.com/github/swift-style-guide</a></li>
<li><a href="https://github.com/github/objective-c-conventions" target="_blank" rel="noopener">https://github.com/github/objective-c-conventions</a></li>
<li><a href="https://github.com/jverkoey/iOS-Best-Practices" target="_blank" rel="noopener">https://github.com/jverkoey/iOS-Best-Practices</a></li>
<li><a href="https://github.com/troyharris/Complete-iOS-StyleGuide" target="_blank" rel="noopener">https://github.com/troyharris/Complete-iOS-StyleGuide</a></li>
<li><a href="https://github.com/objc-zen/objc-zen-book" target="_blank" rel="noopener">https://github.com/objc-zen/objc-zen-book</a></li>
<li><a href="//www.v2ex.com/t/25732">你们是如何为 View Controller 的变量命名的呢？ - V2EX</a></li>
<li><a href="http://www.amazon.cn/dp/B0061XKRXA" target="_blank" rel="noopener">代码大全(第2版) - 亚马逊</a></li>
</ul>
<p><a name='footnote'></a><br>[^1]: <a href="http://pingguohe.net/2012/06/22/talk_arc_again/" target="_blank" rel="noopener">再谈ARC - 苹果核</a><br>[^2]: <a href="http://bigwhite.blogbus.com/logs/125602412.html" target="_blank" rel="noopener">只对代码无法表达的东西写注释 - Tony Bai</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>swift代码规范</title>
    <url>/2017/01/02/swiftnorm/</url>
    <content><![CDATA[<p>##一、命名<br>###1.类型</p>
<ul>
<li>类型名称（如 struct, enum, class, typedef, associatedtype, protocol 等）使用<strong>大驼峰命名法</strong>命名。</li>
<li>变量和常量则以<strong>小驼峰命名法</strong>命名。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> mercury, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mobileNo: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>###2.协议<br>根据苹果接口设计指导准则，协议名称用来描述一些东西是什么的时候是名词，例如：Collection, WidgetFactory。若协议名称用来描述能力应该以 -ing, -able, 或 -ible 结尾，例如：Equatable, Resizing。</p>
<p>###3.类前缀</p>
<ul>
<li>Swift中类别(类，结构体)在编译时会把模块设置为默认的命名空间，所以不用为了区分类别而添加前缀，比如RW。</li>
<li>如果担心来自不同模块的两个名称发生冲突，可以在使用时添加模块名称来区分。注意不要滥用模块名称，仅在有可能发生冲突或疑惑的场景下使用。如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import SomeModule </span><br><span class="line">let myClass = SomeModule.UsefulClass()</span><br></pre></td></tr></table></figure>

<p>###4.参数命名<br>####委托<br>在定义委托方法时，第一个未命名参数应是委托数据源。<br>正确代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func namePickerView(_ namePickerView: NamePickerView, didSelectName name: String)</span><br><span class="line"></span><br><span class="line">func namePickerViewShouldReload(_ namePickerView: NamePickerView) -&gt; Bool</span><br></pre></td></tr></table></figure>

<p>错误代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func didSelectName(namePicker: NamePickerViewController, name: String)</span><br><span class="line"></span><br><span class="line">func namePickerShouldReload() -&gt; Bool</span><br></pre></td></tr></table></figure>

<p>####泛型<br>泛型类参数应具有描述性，遵守“大骆驼命名法”。如果一个参数名没有具体的含义，可以使用传统单大写字符，如T,  U, 或V等。<br>正确代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Stack&lt;Element&gt;&#123; ... &#125;</span><br><span class="line">func writeTo &lt;Target: OutputStream&gt;(to Target: inout Target)</span><br><span class="line">func swap(_ a: inout T, _ b: inout T)</span><br></pre></td></tr></table></figure>

<p>错误代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Stack&lt;T&gt;&#123; ... &#125;</span><br><span class="line">func write&lt;target: OutputStream&gt; (to target: inout target)</span><br><span class="line">func swap&lt;Thing&gt;(_ a: inout Thing, _ b: inout Thing)</span><br></pre></td></tr></table></figure>


<p>##二、代码逻辑<br>###1.类型推断<br>尽量使用类型推断以减少多余的冗余类型信息，例如：<br>正确的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let currentLocation = Location()</span><br></pre></td></tr></table></figure>

<p>错误的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let currentLocation: Location = Location()</span><br></pre></td></tr></table></figure>

<p>###2.self推断</p>
<ul>
<li>让编译器在所有允许的地方推断 self 。</li>
<li>在 init 中设置参数时显性地使用 self 。</li>
<li>在 non-escaping closures 中显性地使用 self 。</li>
<li>在避免命名冲突时使用 self 。<br>例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BoardLocation  &#123;</span><br><span class="line">    let row: Int, column: Int</span><br><span class="line">    init(row: Int, column: Int)  &#123;</span><br><span class="line">        self.row = row</span><br><span class="line">        self.column = column</span><br><span class="line">        let closure = &#123;</span><br><span class="line">            print(self.row)    </span><br><span class="line">         &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###3.常量</p>
<ul>
<li>类常量应该在类型里声明为<code>static</code>。使用<code>static</code>修饰常量可以允许他们在被引用的时候不需要实例化类型。</li>
<li>除了单例以外，应尽量避免生成全局常量。</li>
<li>定义常量使用 <strong>let</strong> 关键字，定义变量使用 <strong>var</strong> 关键字， 如果变量的值未来不会发生变化要使用常量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct PhysicsModel &#123;</span><br><span class="line">    static var speedOfLightInAVacuum = 299_792_458</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Spaceship &#123;</span><br><span class="line">    static let topSpeed = PhysicsModel.speedOfLightInAVacuum</span><br><span class="line">    var speed: Double</span><br><span class="line">     </span><br><span class="line">    func fullSpeedAhead() &#123;</span><br><span class="line">        speed = Spaceship.topSpeed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###4.计算型类型属性</p>
<ul>
<li>当只需要继承 getter 方法时，返回简单的 Computed 属性即可。</li>
</ul>
<p>正确代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Example &#123;</span><br><span class="line">    var age: UInt32 &#123;</span><br><span class="line">        return arc4random()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Example &#123;</span><br><span class="line">    var age: UInt32 &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return arc4random()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果你在属性中添加了 set 或者 didSet ，那么你应该显示地提供 get 方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var age: Int &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return Int(arc4random())</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            print(&quot;That&apos;s not your age.&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###5.单例<br>Swift中单例很简单，Swift 的 runtime 会保证单例的创建并且采用线程安全的方式访问：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ControversyManager &#123;</span><br><span class="line">    static let sharedInstance = ControversyManager()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单例通常只需要访问”sharedInstance”的静态属性，除非你有不得已的原因去重命名它。注意，不要用静态函数或者全局函数去访问你的单例。</p>
<p>###6.错误处理<br>可以使用<code>do/try/catch</code>机制，避免使用<code>try!</code>和<code>try?</code></p>
<p>###7.可选值</p>
<ul>
<li>声明一个函数的某个参数可以为 nil 时，用<code>？</code></li>
<li>当你确定某个变量在使用时已经确定不是 nil 时，在后面加<code>!</code></li>
</ul>
<p>###8.扩展声明周期<br>用 [weak self] 和 guard let strongSelf = self else { return } 模式扩展生命周期。用 [weak self] 比 [unowned self] 更好。<br>正确代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resource.request().onComplete &#123; [weak self] response in</span><br><span class="line">  guard let strongSelf = self else &#123; return &#125;</span><br><span class="line">  let model = strongSelf.updateModel(response)</span><br><span class="line">  strongSelf.updateUI(model)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// might crash if self is released before response returns</span><br><span class="line">resource.request().onComplete &#123; [unowned self] response in</span><br><span class="line">  let model = self.updateModel(response)</span><br><span class="line">  self.updateUI(model)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// deallocate could happen between updating the model and updating UI</span><br><span class="line">resource.request().onComplete &#123; [weak self] response in</span><br><span class="line">  let model = self?.updateModel(response)</span><br><span class="line">  self?.updateUI(model)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>##三、代码结构<br>###1.注释</p>
<ul>
<li>使用Xcode8自带的注释功能，快捷键<code>Option+Command+/</code></li>
<li>使用<code>// MARK:</code>分隔代码（类似于OC中的<code>#pragma mark</code>） </li>
</ul>
<p>###2.缩进<br>遵守Xcode内置的缩进格式</p>
<p>###3.类型<br>优先使用Swift原生类型，可以根据需要使用Objective-C提供的方法，因为Swift提供了到Objective-C的桥接 。<br>正确代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let width = 120.0  // Double</span><br><span class="line">let widthString = (width as NSNumber).stringValue // String</span><br></pre></td></tr></table></figure>

<p>错误代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let width: NSNumber = 120.0 // NSNumber</span><br><span class="line">let widthString: NSString=width.stringValue  // NSString</span><br></pre></td></tr></table></figure>


<p>###4.协议一致性<br>当一个对象要实现协议一致性时，推荐使用 <strong>extension</strong> 隔离协议中的方法集，这样让相关方法和协议集中显示在一起，也简化了类支持一个协议和实现相关方法的流程。<br>正确代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyViewcontroller: UIViewController &#123;</span><br><span class="line">      // 方法</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">extension MyViewcontroller: UITableViewDataSource &#123;</span><br><span class="line">      // UITableViewDataSource 方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension MyViewcontroller: UIScrollViewDelegate &#123;</span><br><span class="line">      // UIScrollViewDelegate 方法</span><br><span class="line">&#125; </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">错误代码：</span><br></pre></td></tr></table></figure>
<p>class MyViewcontroller: UIViewController, UITableViewDataSource, UIScrollViewDelegate {<br>       // 所有的方法<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###5.良好的类定义</span><br><span class="line">* 属性，变量，常量和参数等在声明定义时，其中: 符号后有空格，而: 符号前没有空格，比如x: Int, 和Circle: Shape</span><br><span class="line">* 定义多个变量/数据结构时，出于相同的目的和上下文，可以定义在同一行。</span><br><span class="line">* 缩进 getter，setter 的定义和属性观察器的定义。</span><br><span class="line">* 不需要添加`internal`这样的默认的修饰符。也不需要在重写一个方法时添加访问修饰符。</span><br><span class="line">* 给那些不打算被继承的类使用`final`修饰符</span><br></pre></td></tr></table></figure>
<p>final class Circle: Shape {<br>  var x: Int, y: Int<br>  var radius: Double<br>  var diameter: Double{<br>      get {<br>        returnradius * 2<br>     }<br>     set {<br>        radius=newValue/2<br>    }<br>  }<br>  init(x: Int, y: Int, radius: Double) {<br>      self.x = x<br>      self.y = y<br>      self.radius = radius<br>  }</p>
<p>  convenience init(x: Int, y: Int, diameter: Double) {<br>     self.init(x: x, y: y, radius: diameter/2)<br>  }</p>
<p>  func describe() -&gt; String{<br>    return”I am a circle at(centerString())with an        area of(computeArea())”<br>  }<br>  override func computeArea() -&gt; Double{<br>    return M_PI * radius * radius<br>  }</p>
<p>  private func centerString()-&gt;String{<br>    return “((x),(y))”<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###6.控制流程</span><br><span class="line">* 循环使用for-in表达式，而不使用 while 表达式。  </span><br><span class="line">正确代码：</span><br></pre></td></tr></table></figure>
<p>for _ in 0..&lt;3 {<br>  print(“Hello three times”)<br>}</p>
<p>for(index, person) in attendeeList.enumerate() {<br>    print(“(person)is at position #(index)”)<br>}</p>
<p>for index in 0.stride(from: 0, to: items.count, by: 2) {<br>  print(index)<br>}<br>for index in (0…3).reverse() {<br>    print(index)<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">错误代码：</span><br></pre></td></tr></table></figure>
<p>var i=0<br>while i&lt;3 {<br>  print(“Hello three times”)<br>  i+=1<br>}</p>
<p>var i=0<br>while i&lt;3 {<br>  let person = attendeeList[i]<br>  print(“(person)is at position #(i)”)<br>  i+=1<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* Switch 模块中不用显式使用break。</span><br><span class="line"></span><br><span class="line">###7.黄金路径</span><br><span class="line">当编码遇到条件判断时，左边的距离是黄金路径或幸福路径，因为路径越短，速度越快。不要嵌套if循环，多个返回语句是可以的。guard 就为此而生的。  </span><br><span class="line">正确代码：</span><br></pre></td></tr></table></figure>
<p>func computeFFT(context: Context?, inputData: InputData?)  throws -&gt; Frequencies {<br>    guard let context = context else {throwFFTError.NoContext }</p>
<p>   guard let inputData = inputData else { throwFFTError.NoInputData }</p>
<p>  //计算frequencies<br>  return frequencies<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">错误代码：</span><br></pre></td></tr></table></figure>
<p>func computeFFT(context: Context?, inputData: InputData?) throws -&gt; Frequencies {<br>if let context = context {<br>    if let inputData = inputData {<br>           // 计算frequencies<br>          return frequencies<br>    } else {<br>         throwFFTError.NoInputData<br>     }<br>   } else {<br>      throwFFTError.NoContext<br>   }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">当有多个条件需要用 guard 或 if let 解包，可用复合语句避免嵌套。</span><br></pre></td></tr></table></figure>
<p>guard let number1=number1, number2=number2, number3=number3 else{<br>    fatalError(“impossible”)<br>}<br>// 处理number</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###8.语法糖</span><br></pre></td></tr></table></figure>
<p>//对空的数据和字典，使用类型注解<br>var names:  [String] = []<br>var lookup:  [String: Int] = [:]</p>
<p>var deviceModels: [String]<br>var employees: [Int:String]<br>var faxNumber: Int?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###9.函数</span><br><span class="line">自由函数不依附于任何类或类型，应该节制地使用。  </span><br><span class="line">正确代码：</span><br></pre></td></tr></table></figure>
<p>let sorted = items.mergeSort() // 易发现性<br>rocket.launch()  // 可读性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">错误代码：</span><br></pre></td></tr></table></figure>
<p>let sorted = mergeSort(items)// 不易被发现<br>launch(&amp;rocket)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">天然的自由函数：</span><br></pre></td></tr></table></figure>
<p>let value = max(x,y,z)  // another free function that feels natural</p>
<pre><code>

参考链接：  
[最详尽的 Swift 代码规范指南](http://www.cocoachina.com/swift/20160725/17176.html)  
[Swift 3.0 编码规范](http://www.jianshu.com/p/583025f702a8)  
[17条 Swift 最佳实践规范](http://www.cocoachina.com/swift/20151010/13664.html)  
[一份比较通用的iOS代码规范，包括Objective-C和Swift](https://github.com/ValiantCat/iOS-Code-Style)  
[Swift 编码规范（中文）](http://www.jianshu.com/p/288ea00dcfcf)

</code></pre>]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>上传 Appstore 错误 - ERROR ITMS-90168</title>
    <url>/2016/12/13/aboutuploadAppstoreProblem/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/1F91FE85-B2FC-46A2-B73D-6652DFAD856D.png?imageView2/1/w/600/h/200" />
<a id="more"></a>

<h3 id="关于错误信息"><a href="#关于错误信息" class="headerlink" title="关于错误信息."></a>关于错误信息.</h3><pre><code>打包上传到 Appstore 出现错误. 错误信息: ERROR ITMS-90168: &quot;The binary you uploaded was invalid.&quot; 
问题好奇葩, 没有任何提示说我包中有什么错误, 哪里不符合规范 , </code></pre><img src="http://7xisto.com1.z0.glb.clouddn.com/1F91FE85-B2FC-46A2-B73D-6652DFAD856D.png"/>

<h3 id="解决思路1-百度"><a href="#解决思路1-百度" class="headerlink" title="解决思路1 百度"></a>解决思路1 百度</h3><pre><code>百度一下网上也有很多人碰到这个问题 . 关于这个问题的错误有的说图片有问题, 有的包里面含有私有 API 等,
还有的说第三方使用冲突, 但是一一尝试过后 , 呵呵 , 百度真的没有什么用. </code></pre><h3 id="结局思路2-谷歌"><a href="#结局思路2-谷歌" class="headerlink" title="结局思路2 谷歌 ."></a>结局思路2 谷歌 .</h3><pre><code>谷歌上面爷有出现此问题的 , 而且好多人都在问同一个问题, 解决方法如下: </code></pre><p>``<br>cd ~/.itmstransporter</p>
<p>rm update_check*</p>
<p>mv softwaresupport softwaresupport.bak</p>
<p>cd UploadTokens</p>
<p>rm *.token<br>``<br>    但是发现并没有什么乱用 , 上传后依旧报错, 然后发现有人说可能是 xcode 上传的问题, 然后使用 Application Loader 来上传, 依然不行, 继续查找, 说是可能是 Application Loader 的版本问题, 然后3.6 - 3.0 版本的 Application Loader 都尝试一遍, 呵呵 , </p>
<img src=" http://7xisto.com1.z0.glb.clouddn.com/C85B38806E7E5F3E5ACABE8669736760.jpg"/>
    还是不行.配合清除代码依然不可用, 上传依旧报错.而且还是同一个错误 , 错误信息: ERROR ITMS-90168: "The binary you uploaded was invalid."
<img src="http://7xisto.com1.z0.glb.clouddn.com/97FD91CF-CF3E-486E-9C04-ADB1EB4DBDA0.png"/>
### 解决思路3 放弃
    想放弃了 . 我擦来, 但是版本要上线啊 , 怎么办呢 ? 还要继续尝试. 主要是因为真的不知道那里报错.
     我擦咧.想要给客服打电话问问吧, 周末人家不上班 ,但是我们要上线呀....

<h3 id="怀疑是苹果服务器问题"><a href="#怀疑是苹果服务器问题" class="headerlink" title="怀疑是苹果服务器问题"></a>怀疑是苹果服务器问题</h3><pre><code>怀疑是苹果服务器有问题, 造成上传失败. 而后新建一个 APP , 
上传, 我擦咧, 竟然成功了, 那说明并不是人家的问题,还是我们自己的问题.</code></pre><img src="http://7xisto.com1.z0.glb.clouddn.com/WechatIMG59.jpeg"/>

<h3 id="求救大神"><a href="#求救大神" class="headerlink" title="求救大神"></a>求救大神</h3><pre><code>打电话给大神, 大神很忙 , 首先没有遇到过这个问题, 猜想可能是网络问题,
 然后换了多个网络环境,开启 VPN 也有尝试, 最终还是 GG. </code></pre><h3 id="问题还是自己身上"><a href="#问题还是自己身上" class="headerlink" title="问题还是自己身上"></a>问题还是自己身上</h3><pre><code>问题应该还是在自己程序上, 耐住性子找吧 , 程序本身代码应该没有问题, 
先从第三方开始入手, 先吧所有的第三方都注掉, 花了二个多小时, 
把所有用到的第三方都注释掉并且删除, 错误都修改好,重新上传, word 天, 竟然好用了 . 
what fuck, 问题竟然在第三方上, 然后一个一个注掉测试 , 最终定位在一个第三方上 就是一个富文本的第三方. 
说起来很简单,但是定位这个问题我们三个开发找了近四个小时.然后定位发现.找个第三方中的 
bundle文件中有一个 info.plist 文件冲突, 我滴个妈 , 删除,大功告成... 
如果有用到找个第三方的请注意下 , 然后没有然后了.好坑的说</code></pre><img src="http://7xisto.com1.z0.glb.clouddn.com/C1628D75-6834-4D8D-A7F1-3002E1C9144D.png"/>
<img src="http://7xisto.com1.z0.glb.clouddn.com/WechatIMG59.jpeg"/>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><pre><code>没啥好总结的, 比较坑的问题, 记录给大家, 如果遇到同样的问题,不要慌张,
请详细看他的报错信息和报错流程,总会遭到你的问题. 如果有遇到, 呵呵 , 祝你好运.....</code></pre>]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Appstore</tag>
      </tags>
  </entry>
  <entry>
    <title>你的名字观后感</title>
    <url>/2016/12/05/lookmoviewforyousname/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/lookmoviewforyousname1.png?imageView2/1/w/600/h/200" />
<a id="more"></a>

<blockquote>
<p>2016-12-05 22:59:41. 记录时间</p>
</blockquote>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>作为一个对日本的了解只限于几个熟悉的女主角的人来对, 对日本的电影可谓是了解的少之又少, 对于日本的动画片更是没有概念,因为从来不看任何动漫. 说白了也就是一个日本盲, 虽然内心中有千万的不解,但是内心中不知为何会对日本的民族有一种敬佩感, 针日狂请轻喷.没有任何原因, 也更说不出个所以然. 不知何事内心中对日本民族有更多的其实是佩服,敬佩以及敬畏之心仅此而已.</p>
<hr>
<h3 id="初感"><a href="#初感" class="headerlink" title="初感"></a>初感</h3><img src="http://7xisto.com1.z0.glb.clouddn.com/lookmoviewforyousname2.png?imageView2/1/w/800/h/500" />

<blockquote>
<p>今天被同时拉去看了这部电影, 你的名字. 开始看没有什么感觉, 但是当看完的时候,说实话心中泛起了波澜. 作为一部动画电影，影片的每一帧镜头都美得可以用作壁纸，彗星在夜空中划过的奇异紫色光芒，整部片的帧级别的颜色多颜色搭配已经整个画面的协调,是无法用言语来描述的美丽.故事情节跌宕起伏, 有起有落, 整个过程中都是牵动着你的心来走, 有松有驰, 感觉任何一帧画面都不是多余的. </p>
</blockquote>
<blockquote>
<p>梦里相逢人不见，若知是梦何须醒. 也许是过了相信爱情的年纪, 也许对爱情也没有那么高的期望. 但是感觉新海诚这部电影平凡去油动人心弦的纯真感情, 巧妙的情节被如诗般的呈现出来. 瞬间引发共鸣, 像是一首质朴的抒情小诗, 看似不懂, 但是蕴含着无穷意味, 令人回味良久.</p>
</blockquote>
<blockquote>
<p>爱情中永恒的主题, 距离, 寂寞和等待. 但是这个距离是独具思辨性的: 当两个人交换了身体, 他们的距离有没有更近呢?当两人被时空隔阂,他们的距离是不是最远呢.当两个陌生人的轨迹在某一点相交时,他们的心是否也能紧密相联呢?距离的加入是爱情更加神秘,也使影片散发出诗意的哲学意味.</p>
</blockquote>
<h3 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h3><img src="http://7xisto.com1.z0.glb.clouddn.com/lookmoviewforyousname3.png?imageView2/1/w/800/h/400" />

<blockquote>
<p>故事发生在千年后再度回归的彗星造访地球的一个月前，日本深山的某个乡下小镇。女主人公三叶在小镇过着忧郁的生活，处于过多在意周围人目光的年龄，因此对大都市的憧憬日益强烈。某一天做梦醒来之后，她发现自己与生活在东京的高中男生花泷（男主人公）互换了身体，在交换期间两人互相了解、认识，最终互相产生爱慕。然而在时空之间不断地穿越中，他们始终没能相遇</p>
</blockquote>
<blockquote>
<p>爱情之外，故事又加入了彗星来临的“末日情绪”，男女主人公为了拯救即将被彗星毁灭的小镇，共同经历了千辛万苦，但最后两人却互相遗忘了梦中的故事，忘记了那个不能忘，也不想忘的名字，只是隐隐记得一直在追寻的那个人。说实话有些深意的东西我真的没有看懂 , 比如宗教, 世俗, 记忆以及家族…</p>
</blockquote>
<img src="http://7xisto.com1.z0.glb.clouddn.com/lookmoviewforyousname4.png?imageView2/1/w/800/h/450" />


<blockquote>
<p>每个人生命中心底总是会有那么一个忘不掉的人总是在寻找着某个人，总是在等待着某个人，因为命运的齿轮总会转出你意想不到的事情。它让你焦急，却又震撼着你的心灵。在新海诚的世界中，即便如此心境却依然充满希望。《你的名字。》虽仍浪漫矫情得无可救药，但它也借彗星撞击地球从而导致某乡村一夜殒灭的故事，借喻现实，慰藉着日本社会的某种情绪。  – 部分摘抄</p>
</blockquote>
<h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><blockquote>
<p>现实也许不会像电影一样, 但是每个人生的阶段我们都会有忘不掉的人和一直在寻找等待的扔. 不分对错, 但依旧执着. 在相信爱情的年纪就用力去爱着,在现实的生活中也要努力浪漫着, 任何人都是自己的主角, 自己也是自己的导演, 自己的这部戏怎么才能精彩只有你自己才能导出来. 爱情不一定轰轰烈烈, 只要依然爱着那么爱情依旧延续着. 珍惜眼前人, 珍重过往事, 珍爱爱你的人, 生活不易, 且行且珍惜.  </p>
</blockquote>
]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>你的名字</tag>
      </tags>
  </entry>
  <entry>
    <title>统计整个Xcode工程代码行数</title>
    <url>/2016/12/05/xcodelins/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/xcodelins.png?imageView2/1/w/600/h/200" />
<a id="more"></a>


<blockquote>
<p>打开终端，用cd命令定位到工程所在的目录，然后调用以下命名即可把每个源代码文件行数及总数统计出来：</p>
</blockquote>
<p><code>find . &quot;(&quot; -name &quot;*.m&quot; -or -name &quot;*.mm&quot; -or -name &quot;*.cpp&quot; -or -name &quot;*.h&quot; -or -name &quot;*.rss&quot; &quot;)&quot; -print | xargs wc -l</code></p>
<blockquote>
<p>其中，-name “*.m” 就表示扩展名为.m的文件。同时要统计java文件和xml文件的命令分别是：</p>
</blockquote>
<p><code>find . &quot;(&quot; -name &quot;*.java&quot;  &quot;)&quot; -print | xargs wc -l</code></p>
<p><code>find . &quot;(&quot; -name &quot;*.xml&quot;  &quot;)&quot; -print | xargs wc -l</code></p>
<h3 id="2016-12-16-重新编辑"><a href="#2016-12-16-重新编辑" class="headerlink" title="2016-12-16 重新编辑"></a>2016-12-16 重新编辑</h3><pre><code>今天使用了一下上面的, 发现呵呵, 统计出来有十几二十万行代码 , 后来发现他把里面的第三方文件和Pods 里面的都统计进去了,

后来在网上查找 , 发现[Mac OS 下统计代码行数的工具](http://www.lai18.com/content/8307733.html) 验证, 这个统计的靠谱些 .  </code></pre><h4 id="首先，安装homebrew，已安装的请跳过。"><a href="#首先，安装homebrew，已安装的请跳过。" class="headerlink" title="首先，安装homebrew，已安装的请跳过。"></a>首先，安装homebrew，已安装的请跳过。</h4><pre><code>打开终端工具Terminal，输入下列命令。过程中会让你按RETURN键以及输入mac桌面密码，按照提示进行操作即可：</code></pre><p><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;[/code]</code></p>
<h4 id="利用homebrew下载并安装cloc。"><a href="#利用homebrew下载并安装cloc。" class="headerlink" title="利用homebrew下载并安装cloc。"></a>利用homebrew下载并安装cloc。</h4><pre><code>继续在Terminal中输入：</code></pre><p><code>brew install cloc</code></p>
<h4 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h4><pre><code>统计当前文件夹代码行数(请先cd 到目标目录)：</code></pre><p><code>cloc ./</code></p>
<pre><code>排除当前目录下的某个文件夹的代码，比较常见的是排除Pods中的代码，因为Pods中的一半为第三方库，所以这里以Pods文件夹为例：</code></pre><p><code>cloc ./ --exclude-dir=Pods</code></p>
<pre><code>如果我们要排除更多的文件夹该怎么处理呢？每个人的记忆能力是有限的，想知道更多的用法最好的方式就是查看cloc的使用文档，在terminal中输入：</code></pre><p><code>cloc --help</code></p>
<pre><code>这样就简单了，于是我们敲出下列命令达到我们的目的：</code></pre><p><code>cloc ./ --exclude-dir=Pods,WuJieCaoJokeTest</code></p>
<pre><code>此外，基于文档，我们还可以过滤掉特定的后缀(ext)等。</code></pre>]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS9新特性Storyboard References</title>
    <url>/2016/02/17/Storyboard-References/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/gifblog_large_ios_automate_storyboard.jpg?imageView2/1/w/600/h/200" />

<a id="more"></a>
<blockquote>
<p>现在想想还有点激动呢, 先说说为什么会这么激动呢?<br>最近在在开发项目中使用到Storyboard, 但是我们的项目管理是使用SVN(其实个人感觉使用Git在合并的时候xcode自带的diff功能还是很强大的, 可以再合并前进行调整修改, 其实SVN当然也可以diff,但是有些时候真的是搞得头大),还要进行多人协作, 看到这里有的人肯定会说你这个不是自己找不自在嘛! 现实情况也是这样的, 在两个人同时修改Storyboard的时候, 然后进行合并, 那么问题就会一大堆真的是一大堆,要么就是就是Storyboard各种错误(有的说不是删除爆红的地方就可以了吗, 但是删除了有些时候还是会各种开不开Storyboard), 要么就是Storyboard直接瘫痪了….  之前就有关注iOS9的新特性, 就是在使用Storyboard时候多人协作很方便, 但是没有关注, 最近看了一下, 简直就是爽歪歪了…..</p>
</blockquote>
<h3 id="为什么使用Storyboard呢"><a href="#为什么使用Storyboard呢" class="headerlink" title="为什么使用Storyboard呢?"></a>为什么使用Storyboard呢?</h3><p>其实如果是一个中大型的项目, 使用Storyboard时候其实看起来反而会很头疼,因为各种segue, 看的都头疼了. 所以就想能不能把Storyboard拆分一下呢.. 其实也有类似的解决方案 <a href="https://github.com/rob-brown/RBStoryboardLink" target="_blank" rel="noopener">RBStoryboardLink</a> (可以看看这个是什么) 但是这样就是失去Storyboard的原有的本质, 有些很直观的逻辑一下就断掉了. 那和xib又有什么区别呢?</p>
<p>这里我也不多说了. 各有优缺点, 可以看看—<a href="http://onevcat.com/2013/12/code-vs-xib-vs-storyboard/" target="_blank" rel="noopener">代码手写UI，xib和StoryBoard间的博弈，以及Interface Builder的一些小技巧</a> 有些内容有些老了. 请自行更新吧 … 不过有些小技巧很实用的呢….. </p>
<p>不过我个人看来现在的Storyboard简直就是神器了(segue, AutoALayout,良好的团队协作,可重用)….. 专治各种不服….</p>
<h3 id="重点来了—Storyboard-References"><a href="#重点来了—Storyboard-References" class="headerlink" title="重点来了—Storyboard References"></a>重点来了—Storyboard References</h3><p>直接上Demo  </p>
<ol>
<li>比如我原来的Storyboard的界面是这样样子的<img src="http://7xisto.com1.z0.glb.clouddn.com/gifWeChat_1455678316.jpeg" />

</li>
</ol>
<p>我们想把第一个VC的后面的试图进行拆分怎么办呢</p>
<ul>
<li>首先选中我们要进行拆分的试图</li>
<li>然后Editor – Refactor to Storyboard</li>
</ul>
<img src="http://7xisto.com1.z0.glb.clouddn.com/gif08368378-9CA0-44DD-B46A-74C42B9393D4.png" />

<ul>
<li><p>然后给你拆分的Storyboard进行命名. 这里我就FirstSB.storyboard了</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/gif711D5C00-A730-4CAA-B538-15E3E3E8928C.png" />
</li>
<li><p>拆分之后变成了这个样纸….发现你的工程里面多一个FirstSB.storyboard文件,打开是这样样纸的, 然后发现里面的试图就是我们之前选择合并的试图了, 这样我们就可以在这里面为所欲为了….</p>
</li>
</ul>
<img src="http://7xisto.com1.z0.glb.clouddn.com/gifEAE1381F-B940-4966-AC13-3C508B978FF6.png" />

<ul>
<li>而主视图就变成这个样子了, 多了一个FirstSB的Storyboard References控件了</li>
</ul>
<img src="http://7xisto.com1.z0.glb.clouddn.com/gifEE2C793F-A243-4EF8-B649-42797AA2BD5D.png" />

<p>这样我们就把主视图上的一些复杂的东西给拆分出来了…. 是不是很简单的呢</p>
<h3 id="试图的合并"><a href="#试图的合并" class="headerlink" title="试图的合并"></a>试图的合并</h3><ul>
<li>对于以前已经拆分在各个StoryBorad文件里的兄弟们，可以通过添加Storyboard References来链接进行添加合并</li>
</ul>
<p>我这里再新建了一个工程, 并生成了一个OtherVC.storyboard的文件, 然后拖进我自己的工程中, 来模拟合并的过程.<br><img src="http://7xisto.com1.z0.glb.clouddn.com/gifD81FE6F2-EE17-42CE-BC2B-BCB2D439C994.png" /></p>
<ul>
<li>比如我们想把这个页面想让第三个vc来push进来. 我们在主视图中新建个拖拽一个Button. 然后在拖拽一个 Storyboard References控件,然后进行关联</li>
</ul>
<img src="http://7xisto.com1.z0.glb.clouddn.com/gif9F8CAA01-78A3-49FA-A6AD-D3C80FEC3B8F.png" />

<ul>
<li>然后在给OtherVC.storyboard设置一个storyboard ID , 我这里设置他为pushOtherVC</li>
</ul>
<img src="http://7xisto.com1.z0.glb.clouddn.com/gif34C4A423-277D-4217-A410-73FE2E910C85.png" />


<ul>
<li>最后对main.storyboard的Storyboard References进行关联, </li>
<li>在Storyboard中选择我们刚刚的OtherVC</li>
<li>Referenced ID 设置成我们刚刚给OtherVCC 设置的storyboard ID  , 也即是就是pushOtherVC</li>
</ul>
<img src="http://7xisto.com1.z0.glb.clouddn.com/gif6A48A1FD-CA00-47E3-8697-4B882FFF7F49.png" />


<p>亲测,OK了, 如果有兴趣的可以搞搞啊.. 这个无论我们用SVN还是git, 使用起来都很方便, 而且逻辑清晰. 棒棒哒..<br>我的公众账号 … 不时会更新一些小姿势…希望关注一些啊  …<br><img src="http://7xisto.com1.z0.glb.clouddn.com/qrcode_for_gh_17c8b4e90d30_1280.jpg?imageView2/1/w/300/h/300" /></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>References</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中静态库-.a文件生成和使用</title>
    <url>/2015/12/24/StaticLibary/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/F0093439-EBF0-40F1-B810-6D7BF25B7D9B.png?imageView2/1/w/600/h/200" />

<a id="more"></a>

<blockquote>
<p>最近在使用使用一个网上的Demo的时候. 出现另一令人烦恼的问题 . 就是它里面有嵌套的工程. 如下图所示. 工程里面还嵌套有一个工程. 真的是让人煞费苦心 …<br>其实这个问题看起来并不是很难, 如果是一般的工程的话, 解决方法有两种:</p>
</blockquote>
<ol>
<li>我可把嵌套工程里面的文件拖拽出来. 修改一些属性什么的应该可以使用了</li>
<li>还有一种方法就是我把嵌套里面的工程整个生成一个静态库文件.把我需要使用的文件的.h暴露出来使用.<br>但是这个工程比较奇葩. 他里面是c++de一些文件. 如果直接拖拽的话会有各种引用文件错误的问题. 没办法现在只能使用第二种方法. 生成.a的文件了. 虽说现在还在努力中,但是至少能看见些希望了吧!</li>
</ol>
<img src="http://7xisto.com1.z0.glb.clouddn.com/96075632-19E7-443F-B09E-9BC02DF8992C.png?imageView2/1/w/400/h/400" />

<h2 id="iOS-静态库，动态库与-Framework"><a href="#iOS-静态库，动态库与-Framework" class="headerlink" title="iOS 静态库，动态库与 Framework"></a>iOS 静态库，动态库与 Framework</h2><h3 id="静态库与动态库的区别"><a href="#静态库与动态库的区别" class="headerlink" title="静态库与动态库的区别"></a>静态库与动态库的区别</h3><p>首先来看什么是库，库(Library)说白了就是一段编译好的二进制代码，加上头文件就可以供别人使用。</p>
<p>什么时候我们会用到库呢？一种情况是某些代码需要给别人使用，但是我们不希望别人看到源码，就需要以库的形式进行封装，只暴露出头文件。另外一种情况是，对于某些不会进行大的改动的代码，我们想减少编译的时间，就可以把它打包成库，因为库是已经编译好的二进制了，编译的时候只需要 Link 一下，不会浪费编译时间。</p>
<p>上面提到库在使用的时候需要 Link，Link 的方式有两种，静态和动态，于是便产生了静态库和动态库。</p>
<h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>静态库即静态链接库（Windows 下的 .lib，Linux 和 Mac 下的 .a）。之所以叫做静态，是因为静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了。</p>
<p>静态库的好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。</p>
<h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>动态库即动态链接库（Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib）。与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。</p>
<p>动态库的优点是，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行（Linux 下喜闻乐见的 lib not found 错误）。</p>
<h3 id="iOS-Framework"><a href="#iOS-Framework" class="headerlink" title="iOS Framework"></a>iOS Framework</h3><p>除了上面提到的 .a 和 .dylib 之外，Mac OS/iOS 平台还可以使用 Framework。Framework 实际上是一种打包方式，将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发。</p>
<p>在 iOS 8 之前，iOS 平台不支持使用动态 Framework，开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework，Foundation.Framework 等。这种限制可能是出于安全的考虑。换一个角度讲，因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，实际上动态库也就没有存在的必要了。</p>
<p>由于上面提到的限制，开发者想要在 iOS 平台共享代码，唯一的选择就是打包成静态库 .a 文件，同时附上头文件（例如微信的SDK）。但是这样的打包方式不够方便，使用时也比较麻烦，大家还是希望共享代码都能能像 Framework 一样，直接扔到工程里就可以用。于是人们想出了各种奇技淫巧去让 Xcode Build 出 iOS 可以使用的 Framework，具体做法参考这里和这里，这种方法产生的 Framework 还有 “伪”(Fake) Framework 和 “真“(Real) Framework 的区别。</p>
<p>iOS 8/Xcode 6 推出之后，iOS 平台添加了动态库的支持，同时 Xcode 6 也原生自带了 Framework 支持（动态和静态都可以），上面提到的的奇技淫巧也就没有必要了（新的做法参考这里）。为什么 iOS 8 要添加动态库的支持？唯一的理由大概就是 Extension 的出现。Extension 和 App 是两个分开的可执行文件，同时需要共享代码，这种情况下动态库的支持就是必不可少的了。但是这种动态 Framework 和系统的 UIKit.Framework 还是有很大区别。系统的 Framework 不需要拷贝到目标程序中，我们自己做出来的 Framework 哪怕是动态的，最后也还是要拷贝到 App 中（App 和 Extension 的 Bundle 是共享的），因此苹果又把这种 Framework 称为 Embedded Framework。</p>
<h3 id="Swift-支持"><a href="#Swift-支持" class="headerlink" title="Swift 支持"></a>Swift 支持</h3><p>跟着 iOS8 / Xcode 6 同时发布的还有 Swift。如果要在项目中使用外部的代码，可选的方式只有两种，一种是把代码拷贝到工程中，另一种是用动态 Framework。使用静态库是不支持的。</p>
<p>造成这个问题的原因主要是 Swift 的 Runtime 没有被包含在 iOS 系统中，而是会打包进 App 中（这也是造成 Swift App 体积大的原因），静态库会导致最终的目标程序中包含重复的 Runtime（这是苹果自家的解释）。同时拷贝 Runtime 这种做法也会导致在纯 ObjC 的项目中使用 Swift 库出现问题。苹果声称等到 Swift 的 Runtime 稳定之后会被加入到系统当中，到时候这个限制就会被去除了。</p>
<h3 id="CocoaPods-的做法"><a href="#CocoaPods-的做法" class="headerlink" title="CocoaPods 的做法"></a>CocoaPods 的做法</h3><p>在纯 ObjC 的项目中，CocoaPods 使用编译静态库 .a 方法将代码集成到项目中。在 Pods 项目中的每个 target 都对应这一个 Pod 的静态库。不过在编译过程中并不会真的产出 .a 文件。如果需要 .a 文件的话，可以参考<a href="http://www.cnblogs.com/brycezhang/p/4117180.html" target="_blank" rel="noopener">这里</a>，或者使用 <a href="https://github.com/CocoaPods/cocoapods-packager" target="_blank" rel="noopener">CocoasPods-Packager</a> 这个插件。</p>
<p>当不想发布代码的时候，也可以使用 Framework 发布 Pod，CocoaPods 提供了 vendored_framework 选项来使用第三方 Framework，具体的做法可以参考<a href="http://www.telerik.com/blogs/how-to-use-a-third-party-framework-in-a-private-cocoapod" target="_blank" rel="noopener">这里</a>和<a href="https://stackoverflow.com/questions/18219286/podspec-link-binary-library" target="_blank" rel="noopener">这里</a>。</p>
<p>对于 Swift 项目，CocoaPods 提供了动态 Framework 的支持，通过 use_frameworks! 选项控制。</p>
<p>更多有关代码分发的扩展资料可以参考这篇博客： <a href="http://geeklu.com/2014/02/objc-lib/" target="_blank" rel="noopener">http://geeklu.com/2014/02/objc-lib/</a></p>
<p>上文转自:<a href="https://skyline75489.github.io/post/2015-8-14_ios_static_dynamic_framework_learning.html" target="_blank" rel="noopener">https://skyline75489.github.io/post/2015-8-14_ios_static_dynamic_framework_learning.html</a>  </p>
<h2 id="静态库怎么生成呢"><a href="#静态库怎么生成呢" class="headerlink" title="静态库怎么生成呢?"></a>静态库怎么生成呢?</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>在企业开发中，一些核心技术或者常用框架，出于安全性和稳定性的考虑，不想被外界知道，所以会把核心代码打包成静态库，只暴露头文件给程序员使用（比如：友盟、百度地图等第三方的sdk）</p>
</blockquote>
<ul>
<li>库的分类-根据源代码的公开情况，库可以分为2种类型</li>
</ul>
<ol>
<li>开源库 – 公开源代码，能看到具体实现<br>比如SDWebImage、AFNetworking</li>
<li>闭源库 – 不公开源代码，是经过编译后的二进制文件，看不到具体实<br>　　　主要分为：静态库、动态库</li>
</ol>
<ul>
<li>静态库和动态库的区别<br><strong><em>静态库</em></strong>：链接时，静态库会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝</li>
</ul>
<img src="http://7xisto.com1.z0.glb.clouddn.com/14093923_vV23.png" />
___动态库___：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存
<img src="http://7xisto.com1.z0.glb.clouddn.com/14093923_1g94.png" />

<p><code>注意:项目中如果使用了动态库，会苹果拒接</code> – 待验证</p>
<h3 id="静态库文件的版本（4种）"><a href="#静态库文件的版本（4种）" class="headerlink" title="静态库文件的版本（4种）"></a>静态库文件的版本（4种）</h3><ul>
<li>真机-Debug版本</li>
<li>真机-Release版本</li>
<li>模拟器-Debug版本</li>
<li>模拟器-Release版本</li>
</ul>
<p>Debug(调试)版本</p>
<blockquote>
<p>1.含完整的符号信息，以方便调试<br>2.不会对代码进行优化</p>
</blockquote>
<p>Release(发布)版本</p>
<blockquote>
<p>1.不会包含完整的符号信息<br>2.的执行代码是进行过优化的<br>3.的大小会比Debug版本的略小<br>4.在执行速度方面，Release版本会更快些（但不意味着会有显著的提升）</p>
</blockquote>
<p><code>所以我们一般开发中都打包Release（发布）版本，提供外界</code></p>
<h3 id="设备的CPU架构简介"><a href="#设备的CPU架构简介" class="headerlink" title="设备的CPU架构简介"></a>设备的CPU架构简介</h3><p>模拟器：</p>
<blockquote>
<p>4s<del>5 : i386<br>5s</del>6plus : x86_64</p>
</blockquote>
<p>真机：</p>
<blockquote>
<p>3gs<del>4s : armv7<br>5</del>5c : armv7s （静态库只要支持了armv7，就可以跑在armv7s的架构上）<br>5s~6plus : arm64</p>
</blockquote>
<p>制作静态库 - Debug版<br>1.新建项目<br>2.添加静态库并命名</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/295346-3ba22aa4242cfef6.png?imageView2/1/w/400/h/400" />

<img src="http://7xisto.com1.z0.glb.clouddn.com/295346-2df90ab04cfe3938.png?imageView2/1/w/400/h/200" />

<p>3.需要打包到进静态库的代码，放在这个文件夹内</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/295346-d0beca5a623c0dcc.png?imageView2/1/w/400/h/200" />

<p>4.重新创建测试类（HSCalculate），提供外界计算两个数和的方法</p>
<p><code>HSCalculate.h</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface HSCalculate : NSObject</span><br><span class="line">+ (NSInteger)sumNum1:(NSInteger)num1 num2:(NSInteger)num2;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>HSCalculate.m</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;HSCalculate.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation HSCalculate</span><br><span class="line"></span><br><span class="line">+ (NSInteger)sumWithNum1:(NSInteger)num1 num2:(NSInteger)num2</span><br><span class="line">&#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>5.需要暴露给外界的文件（接口）<br><img src="http://7xisto.com1.z0.glb.clouddn.com/295346-ab40935b8c2847df.png?imageView2/1/w/600/h/400" /></p>
<p>6.打包支持模拟器和真机的静态库（分别选择真机和模拟器运行，就会生成对应的静态库）</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/295346-981f009327fcdf49.png?imageView2/1/w/600/h/600" />

<p>7.查看打包好的静态库</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/295346-3de4e36ffe0fc617.png?imageView2/1/w/600/h/600" />

<p>两个文件夹，里面的.a文件就是打包好的静态库</p>
<blockquote>
<p>Debug-iphoneos ： 真机<br>Debug-iphonesimulator：模拟器</p>
</blockquote>
<p>可用下面命令查看静态库支持的cpu架构（可查看上面描述的cpu架构类型）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lipo -info xxx.a</span><br></pre></td></tr></table></figure>

<p>分别查看打包好的模拟器与真机的静态库所支持的cpu架构</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/295346-7c7a18cd2f531bf3.png?imageView2/1/w/900/h/600" />

<p>你会发现模拟器的静态库少了4s~5 : i386架构</p>
<p>原因：</p>
<blockquote>
<p>下面Debug：Yes表示只编译选中模拟器对应的架构，No则为编译所有模拟器支持的cup架构（Debug的Yes状态改为No即可）</p>
</blockquote>
<img src="http://7xisto.com1.z0.glb.clouddn.com/295346-5d69d5ec642836ae.png?imageView2/1/w/10000/h/600" />

<p>修改完后，重新编译：</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/295346-aaaaaaaaaa.png?imageView2/1/w/10000/h/600" />

<p>8.在本项目对该静态库进行调试，<code>ViewController.m</code>导入<code>HSCalculate.h</code>，测试运行，你会发现报错了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;HSCalculate.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">NSInteger result = [HSCalculate sumWithNum1:23 num2:25];</span><br><span class="line">NSLog(@&quot;result: %d&quot;, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>报错：</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/295346-c2a84e5ac9532f88.png?imageView2/1/w/10000/h/600" />

<p>原因：</p>
<blockquote>
<p>需要导入静态库（编译即可运行成功）</p>
</blockquote>
<img src="http://7xisto.com1.z0.glb.clouddn.com/295346-5955afb64a2f287c.png?imageView2/1/w/10000/h/600" />

<p>9.同时支持真机与模拟器的静态库（需要合并）</p>
<blockquote>
<p>真机和模拟器的静态库，是不一样的，不能同时适用在真机和模拟器上，但要满足这要求的话，要对编译好的两个静态库进行合并</p>
</blockquote>
<p>合并好坏：</p>
<blockquote>
<p>好：开发过程中既可以在真机上调试，也可以在模拟器上调试<br>坏：如果静态库太大，合并打包后，会非常大，因此很多第三方的静态库的.a是区分版本的</p>
</blockquote>
<p>合并产生新的静态库：</p>
<p><code>lipo -create Debug-iphoneos/xxx.a Debug-iphonesimulator/xxx.a -output xxx.a</code></p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/295346-d31ddd54a4d2d7aa.png?imageView2/1/w/10000/h/600" />

<p>10.把合并好的静态库和外界访问的文件拉入到新工程，即可使用（inc文件自己建立的）<br><img src="http://7xisto.com1.z0.glb.clouddn.com/295346-de9df951d58a0d87.png?imageView2/1/w/10000/h/600" /></p>
<p>新建工程测试：</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/295346-09ddbed7ac075455.png?imageView2/1/w/10000/h/600" />

<h3 id="制作静态库-Release版"><a href="#制作静态库-Release版" class="headerlink" title="制作静态库 - Release版"></a>制作静态库 - Release版</h3><p>跟Debug版步骤一样，只不过在编译时，改下面的选项即可</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/295346-8b103416181defa3.png?imageView2/1/w/10000/h/600" />

<img src="http://7xisto.com1.z0.glb.clouddn.com/295346-f768cdfd8172da3d.png?imageView2/1/w/10000/h/600" />


<blockquote>
<p>大概步骤差不多就这些. 其实看起来还不是很麻烦的嘛  OK  祝你好远喽… 以后肯定会用到的. 恩恩. mark—-先</p>
</blockquote>
<p>参考:<br>部分转载与 – <a href="http://www.jianshu.com/p/8f5b9855efb8" target="_blank" rel="noopener">iOS 静态库开发</a><br><a href="http://my.oschina.net/u/2344008/blog/400807?fromerr=NK9EOmgp" target="_blank" rel="noopener">iOS开发拓展篇—静态库</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title>block的原理介绍及使用</title>
    <url>/2015/12/16/useBlock/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/THBL15_logo.png?imageView2/1/w/600/h/200" />

<a id="more"></a>

<p>特别声明</p>
<blockquote>
<p>本文转自<a href="https://www.zybuluo.com/MicroCai/note/51120" target="_blank" rel="noopener">https://www.zybuluo.com/MicroCai/note/51120</a> –  MicroCai </p>
</blockquote>
<p>最近使用到block , 虽说是会用, 但是对原理及其模糊, 和在什么情况下该注意些什么东西, 脑海中印象比较模糊, 顾整理一些资料, 方便学习和查阅吧. </p>
<h1 id="block的实现"><a href="#block的实现" class="headerlink" title="block的实现"></a>block的实现</h1><h2 id="什么是block"><a href="#什么是block" class="headerlink" title="什么是block"></a>什么是block</h2><p>block 顾名思义就是<code>代码块</code>，将同一逻辑的代码放在一个块，使代码更简洁紧凑，易于阅读，而且它比函数使用更方便，代码更美观，因而广受开发者欢迎。但同时 block 也是 iOS 开发中坑最多的地方之一，因此有必要了解下 block 的实现原理，知其然，更知其所以然，才能从根本上避免挖坑和踩坑。</p>
<p>需要知道的是，block 只是 Objective-C 对闭包的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，名称不同而已。</p>
<p>特别声明</p>
<blockquote>
<p>以下研究所用的过程代码由 clang 编译前端生成，仅作理解之用。实际上 clang 根本不会将 block 转换成人类可读的代码，它对 block 到底做了什么，谁也不知道。<br>所以，<strong><strong>切勿将过程代码当做block的实际实现，切记切记！！！</strong></strong></p>
</blockquote>
<hr>
<p>将下面的<code>test.m</code> 代码用 <code>clang</code>工具翻译 <code>test.cpp</code>代码</p>
<blockquote>
<p>clang -rewrite-objc test.m</p>
</blockquote>
<p><code>test.m 代码</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/************* Objective-C 源码 *************/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">void (^blk)(void) = ^&#123; printf(&quot;Block\n&quot;); &#125;; </span><br><span class="line">blk();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>test.cpp</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/************* 使用 clang 翻译后如下 *************/</span><br><span class="line">struct __block_impl</span><br><span class="line">&#123;</span><br><span class="line">void *isa;</span><br><span class="line">int Flags;</span><br><span class="line">int Reserved;</span><br><span class="line">void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line">struct __main_block_impl_0</span><br><span class="line">&#123;</span><br><span class="line">struct __block_impl impl;</span><br><span class="line">struct __main_block_desc_0* Desc;</span><br><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0)</span><br><span class="line">&#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Block\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">static struct __main_block_desc_0</span><br><span class="line">&#123;</span><br><span class="line">size_t reserved;</span><br><span class="line">size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0) &#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">void (*blk)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们逐一来看下这些函数和结构体</p>
<h2 id="block-结构体信息详解"><a href="#block-结构体信息详解" class="headerlink" title="block 结构体信息详解"></a>block 结构体信息详解</h2><blockquote>
<p>struct __block_impl</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// __block_impl 是 block 实现的结构体</span><br><span class="line">struct __block_impl</span><br><span class="line">&#123;</span><br><span class="line">void *isa;</span><br><span class="line">int Flags;</span><br><span class="line">int Reserved;</span><br><span class="line">void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>isa</code><br>指向实例对象，表明 block 本身也是一个 Objective-C 对象。block 的三种类型：<code>_NSConcreteStackBlock</code>、<code>_NSConcreteGlobalBlock</code>、<code>_NSConcreteMallocBlock</code>，即当代码执行时，isa 有三种值 </p>
<blockquote>
<p>impl.isa = &amp;_NSConcreteStackBlock;   // 保存在栈中的 block，当函数返回时会被销毁<br>impl.isa = &amp;_NSConcreteMallocBlock;   //保存在堆中的 block，当引用计数为 0 时会被销毁。<br>impl.isa = &amp;_NSConcreteGlobalBlock;  //全局的静态 block，不会访问任何外部变量。</p>
</blockquote>
</li>
<li><p><code>Flags</code><br>按位承载 block 的附加信息；</p>
</li>
<li><p><code>Reserved</code><br>保留变量；</p>
</li>
<li><p><code>FuncPtr</code><br>函数指针，指向 Block 要执行的函数，即{ printf(“Block\n”) };</p>
</li>
</ol>
<blockquote>
<p>struct __main_block_impl_0</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// __main_block_impl_0 是 block 实现的结构体，也是 block 实现的入口</span><br><span class="line">struct __main_block_impl_0</span><br><span class="line">&#123;</span><br><span class="line">struct __block_impl impl;</span><br><span class="line">struct __main_block_desc_0* Desc;</span><br><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0)</span><br><span class="line">&#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>impl</code><br>block 实现的结构体变量，该结构体前面已说明；</p>
</li>
<li><p><code>Desc</code><br>描述 block 的结构体变量；</p>
</li>
<li><p><code>__main_block_impl_0</code><br>结构体的构造函数，初始化结构体变量 impl、Desc；</p>
</li>
</ol>
<blockquote>
<p>static void __main_block_func_0</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// __main_block_func_0 是 block 要最终要执行的函数代码</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Block\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>static struct __main_block_desc_0</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// __main_block_desc_0 是 block 的描述信息结构体</span><br><span class="line">static struct __main_block_desc_0</span><br><span class="line">&#123;</span><br><span class="line">size_t reserved;</span><br><span class="line">size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0) &#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>reserved</code><br>结构体信息保留字段</p>
</li>
<li><p><code>Block_size</code><br>结构体大小</p>
</li>
</ol>
<p>此处已定义了一个该结构体类型的变量 __main_block_desc_0_DATA</p>
<p>##block 实现的执行流程<br><img src="http://7xisto.com1.z0.glb.clouddn.com/C75D9409-DA3C-4F41-865C-86190A7B7935.png" /></p>
<h2 id="block-获取外部变量"><a href="#block-获取外部变量" class="headerlink" title="block 获取外部变量"></a>block 获取外部变量</h2><blockquote>
<p>运行下面的代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int intValue = 1;</span><br><span class="line">void (^blk)(void) = ^&#123; printf(&quot;intValue = %d\n&quot;, intValue); &#125;;</span><br><span class="line">blk();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<blockquote>
<p>intValue = 1</p>
</blockquote>
<p>和第一段源码不同的是，这里多了个局部变量<code>intValue</code>，而且还在 block 里面获取到了。<br>通过前一段对 block 源码的学习，我们已经了解到 block 的函数定义在 main() 函数之外，那它又是如何获取 main() 里面的局部变量呢？为了解开疑惑，我们再次用 clang 重写这段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __block_impl</span><br><span class="line">&#123;</span><br><span class="line">void *isa;</span><br><span class="line">int Flags;</span><br><span class="line">int Reserved;</span><br><span class="line">void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line">struct __main_block_impl_0</span><br><span class="line">&#123;</span><br><span class="line">struct __block_impl impl;</span><br><span class="line">struct __main_block_desc_0* Desc;</span><br><span class="line">int intValue;</span><br><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _intValue, int flags=0) : intValue(_intValue)</span><br><span class="line">&#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself)</span><br><span class="line">&#123;</span><br><span class="line">int intValue = __cself-&gt;intValue; // bound by copy</span><br><span class="line">printf(&quot;intValue = %d\n&quot;, intValue);</span><br><span class="line">&#125;</span><br><span class="line">static struct __main_block_desc_0</span><br><span class="line">&#123;</span><br><span class="line">size_t reserved;</span><br><span class="line">size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int intValue = 1;</span><br><span class="line">void (*blk)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, intValue);</span><br><span class="line">((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来 block 通过参数值传递获取到<code>intValue</code> 变量，通过函数</p>
<blockquote>
<p>__main_block_impl_0 (void *fp, struct __main_block_desc_0 *desc, int _intValue, int flags=0) : intValue(_intValue)</p>
</blockquote>
<p>保存到<code>__main_block_impl_0</code>结构体的同名变量<code>intValue</code>，通过代码 <code>int intValue = __cself-&gt;intValue</code>; 取出 <code>intValue</code>，打印出来。</p>
<blockquote>
<p>构造函数 __main_block_impl_0 冒号后的表达式 intValue(_intValue) 的意思是，用 _intValue 初始化结构体成员变量 intValue。</p>
</blockquote>
<blockquote>
<p>有四种情况下应该使用初始化表达式来初始化成员：<br>1：初始化const成员<br>2：初始化引用成员<br>3：当调用基类的构造函数，而它拥有一组参数时<br>4：当调用成员类的构造函数，而它拥有一组参数时</p>
</blockquote>
<blockquote>
<p>参考：C++类成员冒号初始化以及构造函数内赋值: <a href="http://blog.csdn.net/zj510/article/details/8135556" target="_blank" rel="noopener">http://blog.csdn.net/zj510/article/details/8135556</a></p>
</blockquote>
<hr>
<h1 id="block和变量的内存管理"><a href="#block和变量的内存管理" class="headerlink" title="block和变量的内存管理"></a>block和变量的内存管理</h1><p>了解了 block的实现，我们接着来聊聊 block 和变量的内存管理。将介绍可写变量、block的内存段、__block变量的内存段等内容，看完本文会对 block 和变量的内存管理有更加清晰的认识。</p>
<blockquote>
<ul>
<li>全局变量</li>
</ul>
</blockquote>
<ul>
<li>全局静态变量</li>
<li>静态变量</li>
</ul>
<p><code>全局变量</code> 和<code>全局静态变量</code> 由于作用域在全局，所以在 block 内访问和读写这两类变量和普通函数没什么区别，而 <code>静态变量</code> 作用域在 block 之外，是怎么对它进行读写呢？通过<code>clang</code> 工具，我们发现原来 <code>静态变量</code> 是通过指针传递，将变量传递到 block 内，所以可以修改变量值。而上文中的外部变量是通过值传递，自然没法对获取到的外部变量进行修改。由此，可以给我们一个启示，当我们需要修改外部变量时，是不是也可以像 <code>静态变量</code> 这样通过指针来修改外部变量的值呢？</p>
<p>Apple 早就为我们准备了这么一个东西 —— “__block”</p>
<h2 id="block-说明符"><a href="#block-说明符" class="headerlink" title="__block 说明符"></a>__block 说明符</h2><p>按照惯例，重写一小段代码看看 __block 的真身</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/************* 使用 __block 的源码 *************/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">__block int intValue = 0;</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">intValue = 1;</span><br><span class="line">&#125;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/************* 使用 clang 翻译后如下 *************/</span><br><span class="line">struct __block_impl</span><br><span class="line">&#123;</span><br><span class="line">void *isa;</span><br><span class="line">int Flags;</span><br><span class="line">int Reserved;</span><br><span class="line">void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line">struct __Block_byref_intValue_0</span><br><span class="line">&#123;</span><br><span class="line">void *__isa;</span><br><span class="line">__Block_byref_intValue_0 *__forwarding;</span><br><span class="line">int __flags;</span><br><span class="line">int __size;</span><br><span class="line">int intValue;</span><br><span class="line">&#125;;</span><br><span class="line">struct __main_block_impl_0</span><br><span class="line">&#123;</span><br><span class="line">struct __block_impl impl;</span><br><span class="line">struct __main_block_desc_0* Desc;</span><br><span class="line">__Block_byref_intValue_0 *intValue; // by ref</span><br><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_intValue_0 *_intValue, int flags=0) : intValue(_intValue-&gt;__forwarding)</span><br><span class="line">&#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself)</span><br><span class="line">&#123;</span><br><span class="line">__Block_byref_intValue_0 *intValue = __cself-&gt;intValue; // bound by ref</span><br><span class="line">(intValue-&gt;__forwarding-&gt;intValue) = 1;</span><br><span class="line">&#125;</span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0 *dst, struct __main_block_impl_0 *src)</span><br><span class="line">&#123;</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;intValue, (void*)src-&gt;intValue, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">&#125;</span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0 *src)</span><br><span class="line">&#123;</span><br><span class="line">_Block_object_dispose((void*)src-&gt;intValue, 8/*BLOCK_FIELD_IS_BYREF*/);</span><br><span class="line">&#125;</span><br><span class="line">static struct __main_block_desc_0</span><br><span class="line">&#123;</span><br><span class="line">size_t reserved;</span><br><span class="line">size_t Block_size;</span><br><span class="line">void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123;  0, </span><br><span class="line">sizeof(struct __main_block_impl_0), </span><br><span class="line">__main_block_copy_0, </span><br><span class="line">__main_block_dispose_0</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">__attribute__((__blocks__(byref))) __Block_byref_intValue_0 \</span><br><span class="line">intValue = </span><br><span class="line">&#123;</span><br><span class="line">(void*)0,</span><br><span class="line">(__Block_byref_intValue_0 *)&amp;intValue, </span><br><span class="line">0, </span><br><span class="line">sizeof(__Block_byref_intValue_0), </span><br><span class="line">0</span><br><span class="line">&#125;;</span><br><span class="line">void (*blk)(void) = (void (*)()) &amp;__main_block_impl_0   \</span><br><span class="line">(</span><br><span class="line">(void *)__main_block_func_0,            \</span><br><span class="line">&amp;__main_block_desc_0_DATA,              \</span><br><span class="line">(__Block_byref_intValue_0 *)&amp;intValue,  \</span><br><span class="line">570425344                               \</span><br><span class="line">);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在加了<code>__block</code> 之后，代码量增加了不少，仔细查看，其实只是比原来多了</p>
<blockquote>
<ol>
<li>__Block_byref_intValue_0 结构体：用于封装 __block 修饰的外部变量。</li>
<li>_Block_object_assign 函数：当 block 从栈拷贝到堆时，调用此函数。</li>
<li>_Block_object_dispose 函数：当 block 从堆内存释放时，调用此函数。</li>
</ol>
</blockquote>
<p>OC源码中的 <code>__block intValue</code> 翻译后变成了<code>__Block_byref_intValue_0</code>结构体指针变量 intValue，通过指针传递到 <code>block</code> 内，这与前面说的<code>静态变量</code> 的指针传递是一致的。除此之外，整体的执行流程与不加<code>__block</code> 基本一致，不再赘述。但 <code>__Block_byref_intValue_0</code> 这个结构体需特别注意下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 存储 __block 外部变量的结构体</span><br><span class="line">struct __Block_byref_intValue_0</span><br><span class="line">&#123;</span><br><span class="line">void *__isa; // 对象指针</span><br><span class="line">__Block_byref_intValue_0 *__forwarding; // 指向自己的指针</span><br><span class="line">int __flags; // 标志位变量</span><br><span class="line">int __size; // 结构体大小</span><br><span class="line">int intValue; // 外部变量</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<img src="http://7xisto.com1.z0.glb.clouddn.com/image_note57603_1.png" />
在已有结构体指针指向 `__Block_byref_intValue_0` 时，结构体里面还多了个` __forwarding` 指向自己的指针变量，难道不显得多余吗？一点也不，本文后面会阐述。
</blockquote>
<h2 id="block-的内存管理"><a href="#block-的内存管理" class="headerlink" title="block 的内存管理"></a>block 的内存管理</h2><p>在前文中，已经提到了 block 的三种类型 <code>NSConcreteGlobalBlock</code>、<code>_NSConcreteStackBlock</code>、<code>_NSConcreteMallocBlock</code>，见名知意，可以看出三种 block 在内存中的分布</p>
<blockquote>
<img src="http://7xisto.com1.z0.glb.clouddn.com/image_note57603_2.png" />
</blockquote>
<h3 id="NSConcreteGlobalBlock"><a href="#NSConcreteGlobalBlock" class="headerlink" title="_NSConcreteGlobalBlock"></a>_NSConcreteGlobalBlock</h3><blockquote>
<p>1、当 block 字面量写在全局作用域时，即为 global block；<br>2、当 block 字面量不获取任何外部变量时，即为 global block；</p>
</blockquote>
<p>除了上述描述的两种情况，其他形式创建的 block 均为 stack block。</p>
<p>// 下面 block 虽然定义在 for 循环内，但符合第二种情况，所以也是 global block</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int (^blk_t)(int);</span><br><span class="line">for (int rate = 0; rate &lt; 10; ++rate) </span><br><span class="line">&#123;</span><br><span class="line">blk_t blk = ^(int count)&#123;return rate * count;&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_NSConcreteGlobalBlock</code> 类型的 block 处于内存的 ROData 段，此处没有局部变量的骚扰，运行不依赖上下文，内存管理也简单的多。</p>
<h3 id="NSConcreteStackBlock"><a href="#NSConcreteStackBlock" class="headerlink" title="_NSConcreteStackBlock"></a>_NSConcreteStackBlock</h3><p><code>_NSConcreteStackBlock</code> 类型的 <code>block</code>处于内存的栈区。<code>global bloc</code>k 由于处在 data 段，可以通过指针安全访问，但 <code>stack block</code>处在内存栈区，如果其变量作用域结束，这个 <code>block</code> 就被废弃，block 上的<code>__block</code> 变量也同样会被废弃。</p>
<blockquote>
<img src="http://7xisto.com1.z0.glb.clouddn.com/image_note57603_3.png" />
</blockquote>
<p>为了解决这个问题，block 提供了 copy 的功能，将 block 和<code>__block</code> 变量从栈拷贝到堆，就是下面要说的 <code>_NSConcreteMallocBlock</code>。</p>
<h3 id="NSConcreteMallocBlock"><a href="#NSConcreteMallocBlock" class="headerlink" title="_NSConcreteMallocBlock"></a>_NSConcreteMallocBlock</h3><img src="http://7xisto.com1.z0.glb.clouddn.com/image_note57603_4.png" />

<blockquote>
<p>当 block 从栈拷贝到堆后，当栈上变量作用域结束时，仍然可以继续使用 block</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">impl.isa = &amp;_NSConcreteMallocBlock;</span><br></pre></td></tr></table></figure>
<p>如果你细心的观察上面的转换后的代码，会发现访问结构体 <code>__Block_byref_intValue_0</code> 内部的成员变量都是通过访问 <code>__forwarding</code>指针完成的。为了保证能正确访问栈上的<code>__block</code> 变量，进行 <code>copy</code> 操作时，会将栈上的<code>__forwarding</code>指针指向了堆上的<code>block</code>结构体实例。</p>
<hr>
<h2 id="block-的自动拷贝和手动拷贝"><a href="#block-的自动拷贝和手动拷贝" class="headerlink" title="block 的自动拷贝和手动拷贝"></a>block 的自动拷贝和手动拷贝</h2><blockquote>
<p>在开启 ARC 时，大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上，只有当</p>
</blockquote>
<p>block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法；<br>但方法/函数在内部已经实现了一份拷贝了 block 参数的代码，或者如果编译器自动拷贝，那么调用者就不需再手动拷贝，比如：</p>
<blockquote>
<ul>
<li>当 <code>block</code> 作为函数返回值返回时，编译器自动将<code>block</code>作为 <code>_Block_copy</code> 函数，效果等同于 block 直接调用<code>copy</code>方法；</li>
</ul>
</blockquote>
<ul>
<li>当<code>block</code> 被赋值给 <code>__strong id</code>类型的对象或 <code>block</code> 的成员变量时，编译器自动将<code>block</code> 作为 <code>_Block_copy</code> 函数，效果等同于 <code>block</code>直接调用<code>copy</code> 方法；</li>
<li>当<code>block</code>作为参数被传入方法名带有 <code>usingBlock</code> 的<code>Cocoa Framework</code> 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 <code>block</code>调用 <code>copy</code> 或 <code>_Block_copy</code> 进行拷贝;</li>
</ul>
<p>让我们看个 block 自动拷贝的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/************ ARC下编译器自动拷贝block ************/</span><br><span class="line">typedef int (^blk_t)(int);</span><br><span class="line">blk_t func(int rate)</span><br><span class="line">&#123;</span><br><span class="line">return ^(int count)&#123;return rate * count;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 block 获取了外部变量，所以是创建在栈上，当 func 函数返回给调用者时，脱离了局部变量 rate 的作用范围，如果调用者使用这个 block 就会出问题。那 ARC 开启的情况呢？运行这个 block 一切正常。和我们的预期结果不一样，ARC 到底给 block 施了什么魔法？我们将上面的代码翻译下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blk_t func(int rate)</span><br><span class="line">&#123;</span><br><span class="line">blk_t tmp = &amp;__func_block_impl_0(__func_block_func_0, &amp;__func_block_desc_0_DATA, rate);</span><br><span class="line">tmp = objc_retainBlock(tmp);</span><br><span class="line">return objc_autoreleaseReturnValue(tmp); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>转换后出现两个新函数 <code>objc_retainBlock</code>、<code>objc_autoreleaseReturnValue</code>。如果你看过runtime 库（点此下载:<a href="http://opensource.apple.com/tarballs/objc4/objc4-493.9.tar.gz" target="_blank" rel="noopener">http://opensource.apple.com/tarballs/objc4/objc4-493.9.tar.gz</a>） ，在<code>runtime/objc-arr.mm</code>文件中就有这两个函数的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*********** objc_retainBlock() 的实现 ***********/</span><br><span class="line">id objc_retainBlock(id x) </span><br><span class="line">&#123;</span><br><span class="line">#if ARR_LOGGING</span><br><span class="line">objc_arr_log(&quot;objc_retain_block&quot;, x);</span><br><span class="line">++CompilerGenerated.blockCopies;</span><br><span class="line">#endif</span><br><span class="line">return (id)_Block_copy(x);</span><br><span class="line">&#125;</span><br><span class="line">// Create a heap based copy of a Block or simply add a reference to an existing one.</span><br><span class="line">// This must be paired with Block_release to recover memory, even when running</span><br><span class="line">// under Objective-C Garbage Collection.</span><br><span class="line">BLOCK_EXPORT void *_Block_copy(const void *aBlock)</span><br><span class="line">__OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_2);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*********** objc_autoreleaseReturnValue() 的实现 ***********/</span><br><span class="line">id objc_autoreleaseReturnValue(id obj)</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_RETURN_AUTORELEASE</span><br><span class="line">assert(_pthread_getspecific_direct(AUTORELEASE_POOL_RECLAIM_KEY) == NULL);</span><br><span class="line">if (callerAcceptsFastAutorelease(__builtin_return_address(0))) &#123;</span><br><span class="line">_pthread_setspecific_direct(AUTORELEASE_POOL_RECLAIM_KEY, obj);</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">return objc_autorelease(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码和注释，意思就很明显了，由于 <code>block</code> 字面量是创建在栈内存，通过 <code>objc_retainBlock()</code>函数拷贝到堆内存，让 <code>tmp</code> 重新指向堆上的 <code>block</code>，然后将<code>tmp</code> 所指的堆上的<code>block</code>作为一个<code>Objective-C</code> 对象放入 <code>autoreleasepool</code> 里面，从而保证了返回后的<code>block</code> 仍然可以正确执行。</p>
<p>看完了<code>block</code> 的自动拷贝，那么看看在<code>ARC</code> 下需要手动拷贝<code>block</code> 的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/************ ARC下编译器手动拷贝block ************/</span><br><span class="line">- (id)getBlockArray</span><br><span class="line">&#123;</span><br><span class="line">int val = 10;</span><br><span class="line">return [[NSArray alloc] initWithObjects: </span><br><span class="line">^&#123;NSLog(@&quot;blk0:%d&quot;, val);&#125;, </span><br><span class="line">^&#123;NSLog(@&quot;blk1:%d&quot;, val);&#125;, nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个例子就了然，返回的数组里面的 block 是不可用的，需要再手动拷贝一次才可以，这个较为简单，就不作过多解释。</p>
<p>关于 block 的拷贝操作可以用一张表总结下</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/image_note57603_5.png" />

<hr>
<h3 id="block-变量的内存管理"><a href="#block-变量的内存管理" class="headerlink" title="__block 变量的内存管理"></a>__block 变量的内存管理</h3><p>上面啰嗦一堆，这小节主要用图说话，必要时加文字说明。</p>
<ul>
<li>当 block 从栈内存被拷贝到堆内存时，__block 变量的变化如下图。需要说明的是，当栈上的 block 被拷贝到堆上，堆上的 block 再次被拷贝时，对 __block 变量已经没有影响了。</li>
</ul>
<blockquote>
<img src="http://7xisto.com1.z0.glb.clouddn.com/image_note57603_6.png" />
<img src="http://7xisto.com1.z0.glb.clouddn.com/image_note57603_7.png" />
</blockquote>
<ul>
<li><p>当多个 block 获取同一个 __block 变量，block 从栈被拷贝到堆时</p>
<blockquote>
<img src="http://7xisto.com1.z0.glb.clouddn.com/image_note57603_8.png" />
</blockquote>
</li>
<li><p>当 block 被废弃时，__block 变量被释放</p>
<blockquote>
<img src="http://7xisto.com1.z0.glb.clouddn.com/image_note57603_9.png" />
</blockquote>
</li>
<li><p><strong>forwarding<br>前文已经说过，当<code>block</code>从栈被拷贝到堆时，</strong>forwarding指针变量也会指向堆区的结构体。但是为什么要这么做呢？为什么要让原本指向栈区的结构体的指针，去指向堆区的结构体呢？看起来匪夷所思，实则原因很简单，要从<code>__forwarding</code> 产生的缘由说起。想想起初为什么要给<code>block</code> 添加<code>copy</code> 的功能，就是因为<code>block</code> 获取了局部变量，当要在其他地方（超出局部变量作用范围）使用这个 block 的时候，由于访问局部变量异常，导致程序崩溃。为了解决这个问题，就给 block 添加了 copy 功能。在将 block 拷贝到堆上的同时，将<code>__forwarding</code> 指针指向堆上结构体。后面如果要想使用 <code>__block</code> 变量，只要通过<code>__forwarding</code> 访问堆上变量，就不会出现程序崩溃了。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*************** __forwarding 的作用 ***************/</span><br><span class="line">//猜猜下面代码的打印结果？</span><br><span class="line">&#123;</span><br><span class="line">__block int val = 0;</span><br><span class="line">void (^blk)(void) = [^&#123;++val;&#125; copy];</span><br><span class="line">++val;</span><br><span class="line">blk();</span><br><span class="line">NSLog(@&quot;%d&quot;, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一定有很多人会猜<code>1</code>，其实打印<code>2</code>。原因很简单，当栈上的<code>bloc</code>k 被拷贝到堆上时，栈上的 <code>__forwarding</code>也会指向堆上的<code>__block</code> 变量的结构体。</p>
<p>上面的代码中<code>^{++val;}</code> 和 <code>++val</code>; 都会被转换成 <code>++(val.__forwarding-&gt;val)</code>;，堆上的 <code>val</code> 被加了两次，最后打印堆上的 <code>val</code> 为<code>2</code>。</p>
<blockquote>
<p>图解<br><img src="http://7xisto.com1.z0.glb.clouddn.com/image_note57603_10.png" /></p>
</blockquote>
<p>block 和变量的内存管理终于讲完了，看似很长，只要了解本质，其实很简单(PS: 其实我也是看的迷迷糊糊的, 似懂非懂. 留下来慢慢研究吧)</p>
<hr>
<h1 id="block和对象的内存管理"><a href="#block和对象的内存管理" class="headerlink" title="block和对象的内存管理"></a>block和对象的内存管理</h1><h2 id="获取对象"><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h2><p>照例先来段代码轻松下，瞧瞧 block 是怎么获取外部对象的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/********************** capturing objects **********************/</span><br><span class="line">typedef void (^blk_t)(id obj);</span><br><span class="line">blk_t blk;</span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">[self captureObject];</span><br><span class="line">blk([[NSObject alloc] init]);</span><br><span class="line">blk([[NSObject alloc] init]);</span><br><span class="line">blk([[NSObject alloc] init]);</span><br><span class="line">&#125;</span><br><span class="line">- (void)captureObject</span><br><span class="line">&#123;</span><br><span class="line">id array = [[NSMutableArray alloc] init];</span><br><span class="line">blk = [^(id obj) &#123;</span><br><span class="line">[array addObject:obj];</span><br><span class="line">NSLog(@&quot;array count = %ld&quot;, [array count]);</span><br><span class="line">&#125; copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译后的关键代码摘录如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* a struct for the Block and some functions */</span><br><span class="line">struct __main_block_impl_0</span><br><span class="line">&#123;</span><br><span class="line">struct __block_impl impl;</span><br><span class="line">struct __main_block_desc_0 *Desc;</span><br><span class="line">id __strong array;</span><br><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, id __strong _array, int flags=0) : array(_array)</span><br><span class="line">&#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock; </span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself, id obj)</span><br><span class="line">&#123;</span><br><span class="line">id __strong array = __cself-&gt;array;</span><br><span class="line">[array addObject:obj];</span><br><span class="line">NSLog(@&quot;array count = %ld&quot;, [array count]);</span><br><span class="line">&#125;</span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0 *dst, __main_block_impl_0 *src)</span><br><span class="line">&#123;</span><br><span class="line">_Block_object_assign(&amp;dst-&gt;array, src-&gt;array, BLOCK_FIELD_IS_OBJECT);</span><br><span class="line">&#125;</span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0 *src)</span><br><span class="line">&#123;</span><br><span class="line">_Block_object_dispose(src-&gt;array, BLOCK_FIELD_IS_OBJECT);</span><br><span class="line">&#125;</span><br><span class="line">struct static struct __main_block_desc_0</span><br><span class="line">&#123;</span><br><span class="line">unsigned long reserved;</span><br><span class="line">unsigned long Block_size;</span><br><span class="line">void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123;  0,</span><br><span class="line">sizeof(struct __main_block_impl_0),</span><br><span class="line">__main_block_copy_0,</span><br><span class="line">__main_block_dispose_0</span><br><span class="line">&#125;;</span><br><span class="line">/* Block literal and executing the Block */</span><br><span class="line">blk_t blk;</span><br><span class="line">&#123;</span><br><span class="line">id __strong array = [[NSMutableArray alloc] init];</span><br><span class="line">blk = &amp;__main_block_impl_0(__main_block_func_0, </span><br><span class="line">&amp;__main_block_desc_0_DATA, </span><br><span class="line">array, </span><br><span class="line">0x22000000);</span><br><span class="line">blk = [blk copy];</span><br><span class="line">&#125;</span><br><span class="line">(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);</span><br><span class="line">(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);</span><br><span class="line">(*blk-&gt;impl.FuncPtr)(blk, [[NSObject alloc] init]);</span><br></pre></td></tr></table></figure>

<p>在本例中，当变量变量作用域结束时，<code>array</code> 被废弃，强引用失效，<code>NSMutableArray</code> 类的实例对象会被释放并废弃。在这危难关头，block 及时调用了<code>copy</code> 方法，在 <code>_Block_object_assign</code> 中，将 <code>array</code>赋值给 <code>block</code> 成员变量并持有。所以上面代码可以正常运行，打印出来的 <code>array count</code>依次递增。</p>
<p>总结代码可正常运行的原因关键就在于 <code>block</code> 通过调用<code>copy</code> 方法，持有了 <code>__strong</code> 修饰的外部变量，使得外部对象在超出其作用域后得以继续存活，代码正常执行。</p>
<p>在以下情形中， block 会从栈拷贝到堆：</p>
<blockquote>
<ul>
<li>当 block 调用 copy 方法时，如果 block 在栈上，会被拷贝到堆上；</li>
</ul>
</blockquote>
<ul>
<li>当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>
<li>当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>
<li>当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 进行拷贝;<br>其实后三种情况在上篇文章block的自动拷贝已经做过说明</li>
</ul>
<p>除此之外，都需要手动调用。</p>
<blockquote>
<p> <strong><strong>延伸阅读：Objective-C 结构体中的 __strong 成员变量</strong></strong></p>
</blockquote>
<blockquote>
<p>注意到 __main_block_impl_0 结构体有什么异常没？在 C 结构体中出现了 __strong 关键字修饰的变量。</p>
</blockquote>
<blockquote>
<p>通常情况下， Objective-C 的编译器因为无法检测 C 结构体初始化和释放的时间，不能进行有效的内存管理，所以 Objective-C 的 C 结构体成员是不能用 <strong>strong、</strong>weak 等等这类关键字修饰。然而 runtime 库是可以在运行时检测到 block 的内存变化，如 block 何时从栈拷贝到堆，何时从堆上释放等等，所以就会出现上述结构体成员变量用 __strong 修饰的情况。</p>
</blockquote>
<h2 id="block-变量和对象"><a href="#block-变量和对象" class="headerlink" title="__block 变量和对象"></a>__block 变量和对象</h2><p>__block 说明符可以修饰任何类型的自动变量。下面让我们再看个小例子，啊，愉快的代码时间又到啦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/******* block 修饰对象 *******/</span><br><span class="line">__block id obj = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>
<p>ARC 下，对象所有权修饰符默认为 <code>__strong</code>，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__block id __strong obj = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/******* block 修饰对象转换后的代码 *******/</span><br><span class="line">/* struct for __block variable */</span><br><span class="line">struct __Block_byref_obj_0 </span><br><span class="line">&#123;</span><br><span class="line">void *__isa;</span><br><span class="line">__Block_byref_obj_0 *__forwarding;</span><br><span class="line">int __flags;</span><br><span class="line">int __size;</span><br><span class="line">void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class="line">void (*__Block_byref_id_object_dispose)(void*); </span><br><span class="line">__strong id obj;</span><br><span class="line">&#125;;</span><br><span class="line">static void __Block_byref_id_object_copy_131(void *dst, void *src) </span><br><span class="line">&#123;</span><br><span class="line">_Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br><span class="line">static void __Block_byref_id_object_dispose_131(void *src) </span><br><span class="line">&#123;</span><br><span class="line">_Block_object_dispose(*(void * *) ((char*)src + 40), 131);</span><br><span class="line">&#125;</span><br><span class="line">/* __block variable declaration */</span><br><span class="line">__Block_byref_obj_0 obj = &#123; 0,</span><br><span class="line">&amp;obj,</span><br><span class="line">0x2000000, </span><br><span class="line">sizeof(__Block_byref_obj_0), </span><br><span class="line">__Block_byref_id_object_copy_131, </span><br><span class="line">__Block_byref_id_object_dispose_131,</span><br><span class="line">[[NSObject alloc] init]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>__block id __strong obj</code> 的作用和 <code>id __strong obj</code> 的作用十分类似。当<code>__block id __strong obj</code> 从栈上拷贝到堆上时<code>，_Block_object_assig</code>n 被调用，<code>block</code> 持有 obj；当 <code>__block id __strong obj</code>从堆上被废弃时，<code>_Block_object_dispose</code>被调用用以释放此对象，block 引用消失。</p>
<p>所以，只要是堆上的 <code>__strong</code> 修饰符修饰的 <code>__block</code>对象类型的变量，和 <code>block</code>内获取到的 <code>__strong</code> 修饰符修饰的对象类型的变量，编译器都能对它们的内存进行适当的管理。</p>
<p>如果上面的 <code>__strong</code> 换成 <code>__weak</code>，结果会怎样呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">********************** capturing __weak objects **********************/</span><br><span class="line">typedef void (^blk_t)(id obj);</span><br><span class="line">blk_t blk;</span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">[self captureObject];</span><br><span class="line">blk([[NSObject alloc] init]);</span><br><span class="line">blk([[NSObject alloc] init]);</span><br><span class="line">blk([[NSObject alloc] init]);</span><br><span class="line">&#125;</span><br><span class="line">- (void)captureObject</span><br><span class="line">&#123;</span><br><span class="line">id array = [[NSMutableArray alloc] init]; </span><br><span class="line">id __weak array2 = array;</span><br><span class="line">blk = [^(id obj) &#123;</span><br><span class="line">[array2 addObject:obj];</span><br><span class="line">NSLog(@&quot;array2 count = %ld&quot;, [array2 count]);</span><br><span class="line">&#125; copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是：</p>
<blockquote>
<p>array2 count = 0<br>array2 count = 0<br>array2 count = 0</p>
</blockquote>
<p>原因很简单，array2 是弱引用，当变量作用域结束，array 所指向的对象内存被释放，array2 指向 nil，向 nil 对象发送 count 消息就返回结果 0 了。</p>
<p>如果 <strong>weak 再改成 __unsafe_unretained 呢？</strong>unsafe_unretained 修饰的对象变量指针就相当于一个普通指针。使用这个修饰符有点需要注意的地方是，当指针所指向的对象内存被释放时，指针变量不会被置为 nil。所以当使用这个修饰符时，一定要注意不要通过悬挂指针（指向被废弃内存的指针）来访问已经被废弃的对象内存，否则程序就会崩溃。</p>
<p>如果 __unsafe_unretained 再改成 __autoreleasing 会怎样呢？会报错，编译器并不允许你这么干！如果你这么写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_block id __autoreleasing obj = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>

<p>编译器就会报下面的错误，意思就是 __block 和 __autoreleasing 不能同时使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: __block variables cannot have __autoreleasing ownership __block id __autoreleasing obj = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>

<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>千辛万苦，重头戏终于来了。block 如果使用不小心，就容易出现循环引用，导致内存泄露。到底哪里泄露了呢？通过前面的学习，各位童鞋应该有个底了，下面就让我们一起进入这泄露地区瞧瞧，哪儿出了问题！</p>
<p>愉快的代码时间到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ARC enabled</span><br><span class="line">/************** MyObject Class **************/</span><br><span class="line">typedef void (^blk_t)(void);</span><br><span class="line">@interface MyObject : NSObject</span><br><span class="line">&#123;</span><br><span class="line">blk_t blk_;</span><br><span class="line">&#125; </span><br><span class="line">@end</span><br><span class="line">@implementation MyObject</span><br><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">self = [super init];</span><br><span class="line">blk_ = ^&#123;NSLog(@&quot;self = %@&quot;, self);&#125;; </span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;dealloc&quot;);</span><br><span class="line">&#125; </span><br><span class="line">@end</span><br><span class="line">/************** main function **************/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">id myObject = [[MyObject alloc] init]; </span><br><span class="line">NSLog(@&quot;%@&quot;, myObject);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 self 是<code>__strong</code> 修饰，在 ARC 下，当编译器自动将代码中的 block 从栈拷贝到堆时，block 会强引用和持有 self，而 self 恰好也强引用和持有了 <code>block</code>，就造成了传说中的循环引用。</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/image_note58470_2.png" />


<p>再看一个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface MyObject : NSObject</span><br><span class="line">&#123;</span><br><span class="line">blk_t blk_;</span><br><span class="line">id obj_; </span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@implementation MyObject </span><br><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">self = [super init];</span><br><span class="line">blk_ = ^&#123; NSLog(@&quot;obj_ = %@&quot;, obj_); &#125;; </span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>上面的例子中，虽然没有直接使用 self，却也存在循环引用的问题。因为对于编译器来说，obj_ 就相当于 self-&gt;obj_，所以上面的代码就会变成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blk_ = ^&#123; NSLog(@&quot;obj_ = %@&quot;, self-&gt;obj_); &#125;;</span><br></pre></td></tr></table></figure>
<p>所以这个例子只要用 __weak，在 init 方法里面加一行即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id __weak obj = obj_;</span><br></pre></td></tr></table></figure>
<p>破解循环引用还有一招，使用 __block 修饰对象，在 block 内将对象置为 nil 即可，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef void (^blk_t)(void);</span><br><span class="line">@interface MyObject : NSObject</span><br><span class="line">&#123;</span><br><span class="line">blk_t blk_;</span><br><span class="line">&#125; </span><br><span class="line">@end</span><br><span class="line">@implementation MyObject </span><br><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">self = [super init]; </span><br><span class="line">__block id tmp = self;</span><br><span class="line">blk_ = ^&#123; </span><br><span class="line">NSLog(@&quot;self = %@&quot;, tmp);</span><br><span class="line">tmp = nil; </span><br><span class="line">&#125;;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)execBlock</span><br><span class="line">&#123;</span><br><span class="line">blk_();</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;dealloc&quot;);</span><br><span class="line">&#125; </span><br><span class="line">@end</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">id object = [[MyObject alloc] init]; </span><br><span class="line">[object execBlock];</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子挺有意思的，如果执行 execBlock 方法，就没有循环引用，如果不执行就有循环引用，挺值得玩味的。一方面，使用 __block 挺危险的，万一代码中不执行 block ，就造成了循环引用，而且编译器还没法检查出来；另一方面，使用 __block 可以让我们通过 __block 变量去控制对象的生命周期，而且有可能在一些非常老旧的 MRC 代码中，由于不支持 __weak，我们可以使用此方法来代替 __unsafe_unretained，从而避免悬挂指针的问题。</p>
<p>还有个值得一提的时，在 MRC 下，使用 <strong>block 说明符也可以避免循环引用。因为当 block 从栈拷贝到堆时，</strong>block 对象类型的变量不会被 retain，没有 __block 说明符的对象类型的变量则会被 retian。正是由于 __block 在 ARC 和 MRC 下的巨大差异，我们在写代码时一定要区分清楚到底是 ARC 还是 MRC。</p>
<blockquote>
<p>尽管 ARC 已经如此普及，我们可能已经可以不用去管 MRC 的东西，但要有点一定要明白，ARC 和 MRC 都是基于引用计数的内存管理，其本质上是一个东西，只不过 ARC 在编译期自动化的做了内存引用计数的管理，使得系统可以在适当的时候保留内存，适当的时候释放内存。<br>循环引用到此为止，东西并不多。如果明白了之前的知识点，就会了解循环引用不过是前面知识点的自然延伸点罢了。</p>
</blockquote>
<h2 id="Copy-和-Release"><a href="#Copy-和-Release" class="headerlink" title="Copy 和 Release"></a>Copy 和 Release</h2><p>在 ARC 下，有时需要手动拷贝和释放 block。在 MRC 下更是如此，可以直接用 copy 和 release 来拷贝和释放</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void (^blk_on_heap)(void) = [blk_on_stack copy]; </span><br><span class="line">[blk_on_heap release];</span><br></pre></td></tr></table></figure>
<p>拷贝到堆后，就可以 用 retain 持有 block</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[blk_on_heap retain];</span><br><span class="line">``</span><br><span class="line">然而如果 block 在栈上，使用 retain 是毫无效果的，因此推荐使用 copy 方法来持有 block。</span><br><span class="line"></span><br><span class="line">block 是 C 语言的扩展，所以可以在 C 中使用 block 的语法。比如，在上面的例子中，可以直接使用 Block_copy 和 Block_release 函数来代替 copy 和 release 方法</span><br></pre></td></tr></table></figure>
<p>void (^blk_on_heap)(void) = Block_copy(blk_on_stack);<br>Block_release(blk_on_heap);</p>
<p>```<br>Block_copy 的作用相当于之前看到过的 _Block_copy 函数，而且 Objective-C runtime 库在运行时拷贝 block 用的就是这个函数。同理，释放 block 时，runtime 调用了 Block_release 函数。</p>
<p>最后这里有一篇总结 block 的文章的很不错，推荐大家看看：<a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/" target="_blank" rel="noopener">http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/</a><br>block在美团iOS的实践:<a href="http://tech.meituan.com/block-in-Meituan-iOS.html" target="_blank" rel="noopener">http://tech.meituan.com/block-in-Meituan-iOS.html</a><br>唐巧的技术博客:<a href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/" target="_blank" rel="noopener">http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/</a></p>
<p>总结:虽说是转载别人的帖子过来的. 但是还是收益匪浅…. 说实话这个看起来真的是很长, 但是慢慢的屡下来. 那么还是多少有一些明白的…. </p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>block的使用</tag>
      </tags>
  </entry>
  <entry>
    <title>DLAN是什么</title>
    <url>/2015/10/23/DLNAIntroduce/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/2568189_DLNA.jpg?imageView2/1/w/600/h/200" />

<a id="more"></a>

<blockquote>
<ul>
<li>DLNA最早由索尼、英特尔、微软等提出，全称是DIGITAL LIVING NETWORK ALLIANCE，旨在解决个人PC，消费电器，移动设备在内的无线网络和有线网络的互联互通，其实就是解决电脑和其他电子产品，比如手机、平板之间的通过无线或者有思安网络的互联互通，让我们的照片、视频、音乐能在以上设备中共享，使得数字媒体和内容服务的无限制的共享和增长成为可能</li>
<li>DLNA并不是创造技术，而是形成一种解决的方案，一种大家可以遵守的规范。所以，其选择的各种技术和协议都是当前所应用很广泛的技术和协议。</li>
<li>DLNA 成立于2003 年6 月24 日, 其前身是DHWG （Digital Home Working Group 数字家庭工作组），由Sony、Intel、Microsoft等发起成立、旨在解决个人PC ，消费电器，移动设备在内的无线网络和有线网络的互联互通，使得数字媒体和内容服务的无限制的共享和增长成为可能。DLNA的口号是Enjoy your music, photos and videos, anywhere anytime。</li>
</ul>
</blockquote>
<h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><blockquote>
<p>DMS　DMR　DMC　DMP<br>DMS：Digital Media Server 服务器<br>DMR：Digital Media Renderer 渲染器（受控端）<br>DMC：Digital Media Controller 控制器<br>DMP：Digital MediaPlayer 播放器（可理解为DMC+DMR）</p>
</blockquote>
<h2 id="组件构成"><a href="#组件构成" class="headerlink" title="组件构成"></a>组件构成</h2><table>
<thead>
<tr>
<th>功能组建</th>
<th>重要技术和协议</th>
</tr>
</thead>
<tbody><tr>
<td>Media</td>
<td>Formats</td>
</tr>
<tr>
<td>Media Format</td>
<td>Required and Optional Format Profiles</td>
</tr>
<tr>
<td>Device Discovery Control and Media Management</td>
<td>Device Discovery and Control UPnP Device Architecture 1.0 Media Management and Control UPnP AV 1.0 and UPnP Printer:1</td>
</tr>
<tr>
<td>Media Transport</td>
<td>Media Transport HTTP (Mandatory) and RTP (Optional)</td>
</tr>
<tr>
<td>Network Stack</td>
<td>Networking IPv4 Suite</td>
</tr>
<tr>
<td>Network Connectivity</td>
<td>Connectivity Ethernet,802.11, and Bluetooth</td>
</tr>
</tbody></table>
<h1 id="DLNA的5个功能组件"><a href="#DLNA的5个功能组件" class="headerlink" title="DLNA的5个功能组件"></a>DLNA的5个功能组件</h1><blockquote>
<p>DLNA将其整个应用规定成5个功能组件。从下到上依次为：网络互连，网络协议，媒体传输，设备的发现控制和管理，媒体格式。</p>
</blockquote>
<h2 id="1-网络互连"><a href="#1-网络互连" class="headerlink" title="1. 网络互连"></a>1. 网络互连</h2><blockquote>
<p>其规定了所接入网络的类型和协议。目前，主要包括：<br>有线网络：802.3.i/u 　<br>无线网络：802.11/a/b/g/n</p>
</blockquote>
<img src="http://7xisto.com1.z0.glb.clouddn.com/2568189_+1_thumb.jpg" />

<h2 id="2-网络协议"><a href="#2-网络协议" class="headerlink" title="2. 网络协议"></a>2. 网络协议</h2><blockquote>
<p>其规定了所使用的网络协议。目前，其规定必须支持IPv4。但是，考虑到地址空间等IPv4的缺点，将在不久的将来支持IPv6。当然，考虑已经存在的IPv4的诸多应用和设备。在未来的很长一段时间内同时支持IPv4和IPv6并保证IPv4和IPv6的互连的双重协议栈将会受到青睐。</p>
</blockquote>
<img src="http://7xisto.com1.z0.glb.clouddn.com/2568189_+2_thumb.jpg" />

<h2 id="3-媒体传输"><a href="#3-媒体传输" class="headerlink" title="3. 媒体传输"></a>3. 媒体传输</h2><blockquote>
<p>其规定了所有DLNA设备都必须支持使用HTTP协议进行媒体的传输。这将使得未来很长一段时间如何提高HTTP协议上高速安全的进行大数据量的传输成为一个课题。单纯就安全而然，TLS(安全传输层协议)也许是个不错的选择。另外，在IPv6的协议中IPSEC已经成为了一个必选项。这也在一定程度上解决了安全问题。不过好像使用软件做加解密的工作始终都不是个正确的选择。因为，在真正的应用中，很少有客户不对你的速度指手画脚。当然，同时你也可以使用RTP(实时传送协议)的其他专用的媒体流传输协议。但是，前提是你已经支持了HTTP协议下的传输。</p>
</blockquote>
<img src="http://7xisto.com1.z0.glb.clouddn.com/2568189_+3_thumb.jpg" />

<h2 id="4-设备的发现"><a href="#4-设备的发现" class="headerlink" title="4. 设备的发现"></a>4. 设备的发现</h2><blockquote>
<p>控制和媒体的管理。这个功能组件是最重要的一个层次。也许是由于英特尔是UPnP的发起者吧，所以，在其再次发起DLNA的时候，UPnP所有的东西当然其不会浪费了呀。是不是因为UPnP很长时间停留在协议阶段，很少有应用，IDG是个例外，英特尔才又来发起DLNA的呢，目前，其采用了UPnP Device Architecture 1.0和UPnP AV 1.0 and UPnP Printer:1。这只是UPnP论坛上一堆标准中的冰山一角了。将其UPnP的东西，好像还是蛮多的，这里就不详细讲了。总之，其通过一系列的步骤和协议来达到设备的发现和管理，同时也通过厂商定义的AV和Printer标准达到对媒体的管理。</p>
</blockquote>
<img src="http://7xisto.com1.z0.glb.clouddn.com/2568189_8_thumb.jpg" />

<h2 id="5-媒体格式"><a href="#5-媒体格式" class="headerlink" title="5.媒体格式"></a>5.媒体格式</h2><blockquote>
<p>这是最后的一个组件了。其规定了进行数字媒体和内容的共享和使用的时候的媒体格式。其必须支持的是：JPEG, LPCM(线性脉冲编码调制), MPEG2。其他可选的媒体格式。</p>
</blockquote>
<blockquote>
<p>其他可选的媒体格式有：<br>　　Image JPEG PNG, GIF, TIFF<br>　　Audio LPCM AAC, AC-3, ATRAC 3plus, MP3, WMA9<br>　　AV MPEG2 MPEG-1, MPEG-4*, AVC, WMV9</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>DLNA</tag>
      </tags>
  </entry>
  <entry>
    <title>超声波传输技术</title>
    <url>/2015/09/29/SortingAlgorithm/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/20150203003642717.png?imageView2/1/w/600/h/200" />
<a id="more"></a>


<h2 id="手机超声波通信技术介绍："><a href="#手机超声波通信技术介绍：" class="headerlink" title="手机超声波通信技术介绍："></a>手机超声波通信技术介绍：</h2><p>手机超声波通信，指利用超声波技术在手机间传递信息，比如大家熟知的支付宝的声波支付就是典型的超声波通信技术。其原理很简单，一句话就是把一段时长的频率作为一种信号，发送方把信号编码成很多段等长的频率，通过播音设备发射出去；接收方通过录音设备录制声音，然后将等长的频率识别出来，最后还原成对应的信号。这样就做到了声波传输，比如现在我们的编码是32进制的（0-31），对应的频率我们设定为1k－4.1k，每个信号对应的时长为100ms，如果我们发射信号3，2，10，30则对应的频率为1.3k，1.2k，2k，4k，每段频率的时长为为100ms，接受端识别器的主要作用就是识别这些100ms的频率，然后还原成信号。声波传输是利用声音实现文件的快速传输的一套技术解决方案：采用跨平台的技术，实现任何能够发送声波与接收声波的智能设备之间的数据传输。</p>
<h3 id="手机超声波通信功能介绍："><a href="#手机超声波通信功能介绍：" class="headerlink" title="手机超声波通信功能介绍："></a>手机超声波通信功能介绍：</h3><ol>
<li>声波传输支持一对一传输，也支持一对多的传输。</li>
<li>支持字母、数字、符号传输。</li>
<li>在安静情况下，有效传输距离可以达到5米左右，在一般应用场景下也能达到很可观的识别距离。</li>
<li>使用特殊的降噪算法，对噪声有很好的抑制作用，在汽车行驶过程中、公交车、食堂、大马路、办公场所等都可以达到良好的识别率。</li>
<li>在一般应用场景下数据传输正确率达到98%以上。程序中添加了自动纠错算法，可以在一定程度上自动纠正传输中发现的错误，同时也能在一定程度上保证收到数据的正确性。</li>
<li>支持的平台。目前该声波传输技术已经在iOS、OSX、Android、Windows、Linux、以及嵌入式平台（mips和arm指令集）上成功运行，并都有成功的商业案例。<br>7 .嵌入式特殊定制和优化。随着嵌入式智能设备的大量兴起（比如车载设备、智能摄像机、智能路由器等等），目前有大量的嵌入式应用需要集成声波传输功能，针对嵌入式平台我们专门对内存占用和运算效率作了优化，内存占用10K以内，cpu主频150M就可以顺利运行声波传输模块。</li>
<li>可定制性强，比如对不同的频率、不同的声音、音量等等进行定制。</li>
<li>超声波传输支持。我们可以为用户提供超声波传输版本，也即，在传输过程中听不到声音。</li>
<li>还可以为用户提供声音的叠加功能，比如类似支付宝的咻咻功能，也可以为用户添加其他特殊的声音，比如狗叫、猫喵等等。比如发送一段信息，发出的是狗叫，对方收到的是信息。</li>
</ol>
<h2 id="声波传输如何工作？"><a href="#声波传输如何工作？" class="headerlink" title="声波传输如何工作？"></a>声波传输如何工作？</h2><p>声波传输技术由两部分组成：音频协议与网络协议。音频协议将待传数据编码为一系列选定频率的音调；网络协议则将数据以键值形式存入服务器，其中键为与数据唯一对应的10个字符。</p>
<h3 id="音频协议"><a href="#音频协议" class="headerlink" title="音频协议"></a>音频协议</h3><p>音频协议的原理很简单，易于实现。建立一个含有32个字符（[0-9，a-v]）的表，并将每个字符映射到频率表。频率表是根据乐理，通过伴音的计算生成。</p>
<p>0 = 1760hz</p>
<p>1 = 1864hz</p>
<p>…</p>
<p>v = 10.5khz</p>
<p>一个完整的声波包包含20个音（即20个字符），每87.2毫秒发一个音 。前两位为信息头，采用“hj”，用以通知接收端开始接收。中间10位为有效的信息位，是有效的传输信息，即Key值经过映射后的频率信息。最后8位为RS（Reed-Solomon）校验位，通过RS校验算法，对中间10位进行计算，生成8位的校验信息。。如下图：</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/tech_2.jpg?imageView2/1/w/600/h/200" />

<p>校验主要用来处理由于噪声干扰造成的信息接收错误。通过RS校验，可以纠正25%的错误信息。</p>
<h3 id="发送端（编码器）"><a href="#发送端（编码器）" class="headerlink" title="发送端（编码器）"></a>发送端（编码器）</h3><p>发送端设备只需能够发送1.7khz到10.5khz的正弦声波即可。为了将发送出的声波变得更好听，可以对声音进行一些美化处理，比如在我们的例子中，采用了椭圆形窗对声波进行了音量上的优化。</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/tech_3.jpg?imageView2/1/w/600/h/200" />

<h3 id="接收端（解码器）"><a href="#接收端（解码器）" class="headerlink" title="接收端（解码器）"></a>接收端（解码器）</h3><p>接收端需要记录声音，并将其进行解码以及容错处理。其对算法的要求相对较高，降噪及容错处理对能否得到正确的解码信息是至关重要的。所以接收端需要一定的数字运算能力，对设备的硬件配置有一定的要求。对于算法的细节，我们会逐步的公开并开源。</p>
<h3 id="超声波通信技术应用场景："><a href="#超声波通信技术应用场景：" class="headerlink" title="超声波通信技术应用场景："></a>超声波通信技术应用场景：</h3><h4 id="1-声波支付"><a href="#1-声波支付" class="headerlink" title="1.声波支付"></a>1.声波支付</h4><p>支付宝作为支付相关的应用的代表，相信声波支付功能很多人都用过，但对其原理不一定都了解。</p>
<p>实现原理：声波支付听起来好像都是咻咻的声音，其实咻咻声并不是信息的载体，真正的信息是通过超声波传输的。比如A手机发起咻咻声（此时A也是不停的在循环发送信息），售货机B则在不停的监听。A手机在发送信息前，会先和后台服务器交互，把各种关键的交互信息上传到服务器，然后将要发送的信息加密（支付者的id信息），把加密后的信息转换成超声波，然后再叠加咻咻声，最后发送出去。B在正确收到A的信息后，解码成功后，就连接服务器，确认本次交易，确认成功后，支付生效。</p>
<p>关键点：</p>
<ol>
<li>发送的是支付者的id信息，一般10个字符以内。</li>
<li>发送信息的手机在不停的发送支付者的id。</li>
</ol>
<h4 id="2-传输文件"><a href="#2-传输文件" class="headerlink" title="2.传输文件"></a>2.传输文件</h4><p>chirp和茄子快传是最典型用于在手机间快速传递大量信息（不需要互联网）的应用，比如文件，视频等。茄子快传和chirp都可以传输大文件，但原理上有比较大的区别。</p>
<p>实现原理：A手机发送文件给B手机。B是接收者，B首先建立wifi热点，然后建立sockt通道，最后把wifi用户名和密码通过声波发送出去（用户名和密码在10字符左右）。A处于监听状态，在收到声波，解码出wifi用户名和密码后，连接wifi热点，连接成功后，通过socket把文件发送给B。茄子快传和chirp的根本不同在于chirp高度依赖于互联网；而茄子快传则不需要互联网，仅需要wifi。</p>
<p>关键点：</p>
<ol>
<li>发送的信息为10个字符左右的用户名和密码。</li>
<li>接收者不停的在发送wifi用户名和密码。</li>
<li>真正的信息传输是通过wifi传输的，声波作为握手的工具。</li>
</ol>
<h4 id="3-传输少量信息"><a href="#3-传输少量信息" class="headerlink" title="3.传输少量信息"></a>3.传输少量信息</h4><p>chirp是最典型的应用，比如两个应用之间直接传输少量的文本或者其他信息，原理和上面的差不多，我就不啰嗦了</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>声波传输</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 开发者旅途中的指南针 - LLDB 调试技术</title>
    <url>/2015/08/16/LLDB/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogFE81B772-9957-42C6-BA15-AE7630D0DCF0.png?imageView2/1/w/600/h/200" />
<a id="more"></a>

<p>文章转载于:<a href="http://www.jianshu.com/p/75a2b63106ff" target="_blank" rel="noopener">iOS 开发者旅途中的指南针 - LLDB 调试技术</a></p>
<p>今天给大家介绍的内容，无关乎任何功能性开发技术，但又对开发的效率影响至深，这就是调试技术。</p>
<p>何为调试呢，比如我们用 <code>print</code> 函数在指定位置进行输出，来定位某些节点的变量内的取值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let result = parseJSON(&quot;[1,2,3]&quot;);</span><br><span class="line">print(result);</span><br><span class="line"></span><br><span class="line">result = parseJSON(&quot;error&quot;);</span><br><span class="line">print(result);4</span><br></pre></td></tr></table></figure>

<p>相信我们大家看到类似这样的代码都不会陌生，估计为开发者朋友都会或多或少的用这样的方式对程序进行调试。</p>
<p>这种方式有它的方便之处，就是我们不需要太多思考，需要跟踪某些地方的时候，直接输出就可以得到调试信息了。但这样做也有它的弊端，就是我们每次这样调试，都要反复的编译，运行，然后写进新的 print 语句，再继续编译，运行。反复的编译，运行会比较消耗时间。并且我们再调试完之后，很容易会忘记将调试语句删除，导致很多输出语句遗留再代码中，随着项目的长期进展后，这样会对项目后期的调试造成很多干扰。</p>
<p>而且，当我们想再次调试这段区域的时候，我们不得不再次写上这些输出语句。而有时对于稍微复杂一些的调试场景，print 输出这样的方式，往往还不能太好的应对。</p>
<p>那么有什么办法能解决这些麻烦呢，那就是<strong><em>调试技术</em></strong>，调试器几乎在大多数现代的开发环境中都会有，所以，iOS 开发也不例外，Xcode 环境为我们提供的对应调试工具就是 LLDB。</p>
<p>###初识 LLDB</p>
<p>LLDB 就是 XCode 为我们提供的调试工具。那么说了这么多，到底什么是调试工具呢？ 也许说调试器你可能会感到比较陌生，但说到断点，相信你就会听着比较耳熟了。我们还以刚才我们提到的代码为例：<br><img src="http://www.swiftcafe.io/images/lldb/lldb_1.png" /></p>
<p>我们在第 23 行左边点击了一下，就创建了一个断点，这时我们再运行这个应用的时候，程序运行到这里就会被断点拦截：</p>
<img src="http://www.swiftcafe.io/images/lldb/lldb_2.png" />
并且在 Xcode 的命令行区域，显示了 (lldb) 提示符。

<p>###基本调试操作<br>我们回到最初的问题，如果不使用 print 输出，我们怎么能得到 result 的值呢，这就是我们要讨论的断点调试机制了，我们先看一下 XCode 底部调试区域的几个按钮：</p>
<img src="http://www.swiftcafe.io/images/lldb/lldb_3.png" />

<p>*第一个按钮是继续的意思，会让程序从断点处恢复，继续往下运行，我们点了这个按钮后，应用就会恢复正常运行状态。</p>
<p>*第二个按钮是(Step Over),单步执行的意思，每点这个按钮一次，程序就会从我们断点开始的地方，向下执行一步。</p>
<p>*第三个按钮是 (Step In)，进入执行的意思，简单来说就是如果我们当前的断点在一个函数调用上，把么断点会继续进入这个函数的内部进行调试。</p>
<p>*第四个按钮是(Step Out),跳出的意思, 就是如果我们当前再一个函数中，它会跳出当前的函数，回到函数的调用处。</p>
<p>恩。。你说了这么多,完全听不懂啊</p>
<p>没关系，我们一一道来，还是回到我们最初的需求，我们的断点现在停在给 result 变量赋值的这条语句中，断点所在位置的语句是还没有被执行的，所以我们需要点一下 Step Over 按钮(也就是我们刚才列出的四个按钮的第二个)，让程序执行一行代码。</p>
<p>执行完这行代码后，我们的 <code>result</code> 变量就被赋值完成了。那么问题来了，我们怎么得到 <code>result</code> 变量中得内容呢？</p>
<p>还记得我们的 LLDB 命令行么，我们使用一个叫做 po 的命令，就可以取到这个变量</p>
<img src="http://www.swiftcafe.io/images/lldb/lldb_4.png" />

<p>现在，我们使用 <code>LLDB</code> 命令达到了和 <code>print</code> 语句同样的效果，得到了<code>result</code> 变量的取值。那么问题又来了，这样做有什么好处呢，怎么感觉比直接使用 <code>print</code> 输出更麻烦了呢？</p>
<p>###LLDB 探索之旅<br><code>LLDB</code> 为我们提供了很多方便使用的命令，我们再 <code>LLDB</code> 命令行中，输入 <code>help</code> 命令即可看到这些命令的帮助信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Debugger commands:</span><br><span class="line"></span><br><span class="line">  apropos           -- Find a list of debugger commands related to a particular</span><br><span class="line">                       word/subject.</span><br><span class="line">  breakpoint        -- A set of commands for operating on breakpoints. Also see</span><br><span class="line">                       _regexp-break.</span><br><span class="line">  command           -- A set of commands for managing or customizing the</span><br><span class="line">                       debugger commands.</span><br><span class="line">  disassemble       -- Disassemble bytes in the current function, or elsewhere</span><br><span class="line">                       in the executable program as specified by the user.</span><br><span class="line">  expression        -- Evaluate an expression (ObjC++ or Swift) in the current</span><br><span class="line">                       program context, using user defined variables and</span><br><span class="line">                       variables currently in scope.</span><br><span class="line">  frame             -- A set of commands for operating on the current thread&apos;s</span><br><span class="line">                       frames.</span><br><span class="line">  ...............</span><br></pre></td></tr></table></figure>
<p>这里我们看到了<code>LLDB</code> 命令的列表，要想获得某个命令更详细的帮助，我们开可以输入 <code>help</code> 命令名, 比如我们输入 <code>help expression</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help expression</span><br><span class="line">     Evaluate an expression (ObjC++ or Swift) in the current program context,</span><br><span class="line">     using user defined variables and variables currently in scope.  This</span><br><span class="line">     command takes &apos;raw&apos; input (no need to quote stuff).</span><br><span class="line"></span><br><span class="line">Syntax: expression &lt;cmd-options&gt; -- &lt;expr&gt;</span><br><span class="line"></span><br><span class="line">Command Options Usage:</span><br><span class="line">  expression [-AFLORTg] [-f &lt;format&gt;] [-G &lt;gdb-format&gt;] [-l &lt;language&gt;] [-a &lt;boolean&gt;] [-i &lt;boolean&gt;] [-t &lt;unsigned-integer&gt;] [-u &lt;boolean&gt;] [-v[&lt;description-verbosity&gt;]] [-d &lt;none&gt;] [-S &lt;boolean&gt;] [-D &lt;count&gt;] [-P &lt;count&gt;] [-Y[&lt;count&gt;]] [-V &lt;boolean&gt;] -- &lt;expr&gt;</span><br><span class="line">  expression [-AFLORTg] [-l &lt;language&gt;] [-a &lt;boolean&gt;] [-i &lt;boolean&gt;] [-t &lt;unsigned-integer&gt;] [-u &lt;boolean&gt;] [-d &lt;none&gt;] [-S &lt;boolean&gt;] [-D &lt;count&gt;] [-P &lt;count&gt;] [-Y[&lt;count&gt;]] [-V &lt;boolean&gt;] -- &lt;expr&gt;</span><br></pre></td></tr></table></figure>

<p>就得到了关于 <code>expression</code> 命令的介绍。</p>
<p>基本情况就说这么多，那么咱们就来实践一下，体验一下 <code>LLDB</code> 的强大之处。</p>
<p>我们来看一个更强大的命令 <code>expression</code>, 我们来看一下它的描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Evaluate an expression (ObjC++ or Swift) in the current program context,</span><br><span class="line">using user defined variables and variables currently in scope. This</span><br><span class="line">command takes &apos;raw&apos; input (no need to quote stuff).</span><br></pre></td></tr></table></figure>

<p>翻译一下哈，意思就是在当前程序环境中，执行任何的表达式，并且可以定义和操作已存在的变量。</p>
<p>怎么样，让我说的更具体吧，有了 <code>LLDB</code>我们不但可以在断点处输出某个变量的值，我们还可以修改甚至重新定义某些变量的值。</p>
<p>咱们开始吧，将我们刚才的程序做一下修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var result = parseJSON(&quot;[1,2,3]&quot;);</span><br><span class="line"></span><br><span class="line">if result?.count == 0 &#123;</span><br><span class="line"></span><br><span class="line">    print(&quot;No Data&quot;);</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">    print(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里对 <code>result</code> 变量进行了判断，并进行了分别的输出。下面我们以让将断点设置到第一个语句上，然后运行程序。再断点处我们用 <code>po</code>命令来打印出 <code>result</code> 的值。</p>
<p>这时候，<code>result</code> 中的值，应该是解析后的 <code>JSON</code> 数组。所以我们恢复程序执行后，接下来的<code>if</code> 判断会走第二个分支，输出 <code>result</code> 中的内容。</p>
<p>那么如果我们在刚才断点时候，运行这个命令呢</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">e result = []</span><br></pre></td></tr></table></figure>
<p>这里我们将 <code>result</code>的值修改为一个空数组，然后我们继续程序，接着你会发现，下面的 <code>if</code> 判断走了第一个分支，也就是说我们在断点处对变量进行的修改，是对全局程序生效的。</p>
<p><strong><em>怎么样这个能力是我们之前的调试方法不能达到的吧~</em></strong></p>
<p><code>我们上面的 e 命令是 expression 命令的缩写，详情可以参考 LLDB help 命令的帮助。</code></p>
<p>###控制流快捷命令<br>我们继续探索，还记得前面我们提到的几个控制流按钮吗，也就是这张图片</p>
<img src="http://www.swiftcafe.io/images/lldb/lldb_3.png" />

<p>在 LLDB 命令行中，对于每个流程控制按钮都有相应的命令。</p>
<p>*<code>n</code> 命令，代表 Step Over 操作。</p>
<p>*<code>s</code> 命令，代表 Step Into 操作。</p>
<p>*<code>finish</code> 命令，代表 Step Out 操作。</p>
<p>*<code>c</code> 命令，代表恢复程序执行操作。</p>
<p><strong><em>我们还是以这个程序为例，这次我们使用控制流命令来进行操作</em></strong><br><img src="http://www.swiftcafe.io/images/lldb/lldb_5.png" /></p>
<p>我们运行这个程序，然后在断点检测到时，按照下面的顺序输入 LLDB 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s</span><br><span class="line">n</span><br><span class="line">n</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>我们第一个输入的<code>s</code> 命令，会步入 <code>parseJSON</code> 函数的调用，然后断点就会进入<code>parseJSON</code>函数中。</p>
<p>随后，我们又输入了<code>n</code> 命令，由于 <code>parseJSON</code> 中只有一个 return 语句，那么控制流就会跳出 <code>parseJSON</code> 函数体，重新回到开始处。</p>
<p>紧接着我们再次输入<code>n</code>命令，这时候程序就会将<code>parseJSON</code>的结果赋值给<code>result</code>。</p>
<p>最后我们按下 <code>c</code> 命令，来恢复程序的执行。随后的<code>if</code>判断中就会按照相应的条件输出内容了。<br>怎么样，这样操作起来就比较方便了，我们不必用鼠标点来点去了，完全用键盘敲命令就可以完成控制流的操作了。</p>
<p>###断点创建命令</p>
<p>我们除了通过用鼠标在代码行的左边点击的方式创建断点以外，我们还可以使用 <code>LLDB</code> 来创建断点，比如要创建一个我们之前这样的断点：</p>
<img src="http://www.swiftcafe.io/images/lldb/lldb_1.png" />

<p>我们可以输入这样一条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) breakpoint set -f ViewController.swift -l 28</span><br><span class="line">Breakpoint 2: where = Example`Example.ViewController.viewDidLoad (Example.ViewController)() -&gt; () + 478 at ViewController.swift:29, address= 0x000000010f74f61e</span><br></pre></td></tr></table></figure>
<p>输入命令后，紧接着会有一行输出，告诉我们断点创建成功，并且显示了创建的新断点的位置等基本信息。</p>
<p>这个命令也有简写形式：<code>b ViewController.swift:28</code></p>
<p>我们还可以将断点直接设置到函数上，假设我们有这样一个函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func add(a:Int, b:Int) -&gt; Int &#123;</span><br><span class="line"></span><br><span class="line">    return a + b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以这样设置断点：<code>b add</code></p>
<p>这样就将断点设置再了 <code>add</code> 函数调用的开始位置。</p>
<p>我们开可以设置符号断点,比如这样：<code>b -[NSArray objectAtIndex:]</code></p>
<p>这个断点会将所有对于 <code>NSArray</code> 的 <code>objectAtIndex</code> 方法的调用设置为断点。这里包括我们开发者对它的调用，以及系统框架内部对它的调用。符号断点对于调试是一个很好用的工具，它能够跟踪那些我们引用的系统库中的代码出现的问题。</p>
<p>我们还可以对已经创建的断点设置激发条件：<br><img src="http://www.swiftcafe.io/images/lldb/lldb_6.png" /></p>
<p>我们上面设置的条件表示，只有在 <code>result</code> 的 <code>count</code> 属性等于 0 的时候，断点才会被激发。</p>
<p>是不是觉得 <code>LLDB</code> 有点意思了呢。</p>
<p>###开始探险</p>
<p>那么现在我们就来用 <code>LLDB</code> 完成一些更加有意思的事情吧。</p>
<p>我们首先创建一个示例项目:</p>
<img src="http://www.swiftcafe.io/images/lldb/lldb_7.png" />

<p>项目类型选择 <strong><strong>Single View Application</strong></strong></p>
<p>然后点击 <strong><strong>Next</strong></strong>, 项目信息中的 <strong><strong>Language</strong></strong> 选择 <strong><strong>Swift</strong></strong>:</p>
<img src="http://www.swiftcafe.io/images/lldb/lldb_8.png" />

<p>点击 <strong><em>Next</em></strong> 然后出现项目存储位置的选择，选择一个你自己的存储位置。接下来我们在<strong>_ Main.storyboard_</strong> 中拖放一个 Button 放到右上角：</p>
<img src="http://www.swiftcafe.io/images/lldb/lldb_9.png" />

<p>随后，我们按住 <code>Option</code> 键，然后点击 <code>ViewController.swift</code> 文件，可以在设计界面旁边打开辅助界面。打开后，我们按住 <code>Control</code> 键，然后将我们刚刚创建的按钮拖动到代码视图中：</p>
<img src="http://www.swiftcafe.io/images/lldb/lldb_10.png" />

<p>然后松开鼠标按键，我们就会看到一个弹出菜单：</p>
<img src="http://www.swiftcafe.io/images/lldb/lldb_12.png" />

<p>我们将 <code>Connection</code> 的类型选择为 <code>Action</code>， <code>Name</code> 输入为<code>buttonClicked</code>，其他不用更改，然后点击`按钮。这样就完成了按钮事件的创建。</p>
<p>接下来，我们运行应用，就可以看到这样的界面了：</p>
<img src="http://www.swiftcafe.io/images/lldb/lldb_9.png" />

<p>一切就绪，现在就可以展开我们的 LLDB 大法啦~</p>
<p>其实我们还可以不通过断点的方式来打开 LLDB 命令行，在我们先将程序运行起来，然后我们看一下调试区域的按钮：</p>
<img src="http://www.swiftcafe.io/images/lldb/lldb_13.png" />

<p>注意下，蓝色的断点开关按钮右边还有一个暂停按钮，我们只需要点这个暂停按钮，就可以进入 LLDB 命令行调试状态。因为 LLDB 在 Xcode 运行中是一直驻留在后台的，所以我们其实是可以在任何时间都可以启动 LLDB 命令行的。</p>
<p>打开 <code>LLDB</code> 命令行后，我们可以输入这个命令，打印出当前的视图层级（又学一招~）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) po [[[UIApplication sharedApplication] keyWindow] recursiveDescription]</span><br><span class="line">&lt;UIWindow: 0x7ffcd2f0f1e0; frame = (0 0; 375 667); gestureRecognizers = &lt;NSArray: 0x7ffcd2f10170&gt;; layer = &lt;UIWindowLayer: 0x7ffcd2f0ea80&gt;&gt;</span><br><span class="line">   | &lt;UIView: 0x7ffcd2c6dc10; frame = (0 0; 375 667); autoresize = W+H; layer = &lt;CALayer: 0x7ffcd2c17f10&gt;&gt;</span><br><span class="line">   |    | &lt;UIButton: 0x7ffcd2c6dfc0; frame = (20 62; 78 30); opaque = NO; autoresize = RM+BM; layer = &lt;CALayer: 0x7ffcd2c6bc10&gt;&gt;</span><br><span class="line">   |    |    | &lt;UIButtonLabel: 0x7ffcd2f15af0; frame = (16 6; 46 18); text = &apos;Button&apos;; opaque = NO; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x7ffcd2f16120&gt;&gt;</span><br><span class="line">   |    | &lt;_UILayoutGuide: 0x7ffcd2c6fae0; frame = (0 0; 0 20); hidden = YES; layer = &lt;CALayer: 0x7ffcd2c6faa0&gt;&gt;</span><br><span class="line">   |    | &lt;_UILayoutGuide: 0x7ffcd2c70740; frame = (0 667; 0 0); hidden = YES; layer = &lt;CALayer: 0x7ffcd2c6d3d0&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>大家仔细看一下，每个视图的标识中，都有一个 16进制的字符串，代表这个视图的 <code>ID</code>，比如这个：</p>
<p><code>UIView: 0x7ffcd2c6dc10</code></p>
<p>这个 ID 的作用非常的强大，得到了这个 ID， 我们就可以通过这个命令来得到这个视图的引用了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) e id $view = (id) 0x7fbd71432590</span><br></pre></td></tr></table></figure>

<p>简单解释下，通过 <code>expressio</code>n命令(这里用缩写形式 e)，我们用 <code>View</code> 的 <code>ID</code> 值取得了这个 <code>View</code> 引用，并将它保存到 <code>$view</code> 变量中。</p>
<p>我们得到了引用之后，就可以对这个视图进行很多的操作了，比如我们可以在运行时改变这个视图的背景色：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) e (void) [$view setBackgroundColor:[UIColor redColor]]</span><br></pre></td></tr></table></figure>

<p>当然，我们运行完这条命令，界面上不会马上反应出来，我们还需要调用这个命令刷新一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) e (void)[CATransaction flush]</span><br></pre></td></tr></table></figure>

<p>这样，我们在看一下我们运行的程序，主界面的背景色变成红色了吧。</p>
<p>我们甚至还可以用它来找到某些控件上添加的事件，我们找到我们自己添加的 UIBUtton 的 ID：</p>
<p><code>UIButton: 0x7ffcd2c6dfc0</code></p>
<p>然后运行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) e id $button = (id) 0x7ffcd2c6dfc0</span><br><span class="line"></span><br><span class="line">(lldb) po [$button  allTargets]</span><br><span class="line">&#123;(</span><br><span class="line">    &lt;lldb.ViewController: 0x7feff2d67330&gt;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure>
<p>我们得到 UIButton 的引用后，然后又输出了他的 <code>allTargets</code> 属性，得到了这个<code>UIButton</code> 所对应的事件<code>target</code> 对象的地址，接下来我们再用刚刚得到的这个<code>target</code> 地址获取它的 <code>action</code> 属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) po [$button actionsForTarget:(id)0x7feff2d67330 forControlEvent:0]</span><br><span class="line">&lt;__NSArrayM 0x7feff2c22350&gt;(</span><br><span class="line">buttonClicked:</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>我们这样就得到了，这个按钮所对应的方法名了。那么接下来，我们可以在这个方法上设置断点，或者用 LLDB 的运行时能力替换这个方法的实现等等。总之，对于我们调试应用来说，LLDB 是一个非常强大而高效的工具。这里只介绍了它的冰山一角，关于更多的内容，大家可以使用 help 命令，进行深入的研究。相信大家发挥聪明才智，能够发现更多它的强大之处。</p>
<p>###一点点延展，关于 Chisel</p>
<p>最后，再给大家延展一下。LLDB 本身的命令系统非常健壮，并且它还支持 Python 的脚本扩展，这样它又有了很不错的扩展性，我们可以根据自己的需要来扩展自己的脚本。</p>
<p><a href="https://github.com/facebook/chisel" target="_blank" rel="noopener">Chisel</a> 正是 LLDB 扩展的一个典型例子，这是由 Facebook 团队开发的一个开源的 LLDB 的 Python 扩展集合，它再 LLDB 命令的基础上，又为我们提供了更加方便的操作接口。</p>
<p>比如我们要打印当前的视图层级，如果用 LLDB 原生的命令，我们需要这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) po [[[UIApplication sharedApplication] keyWindow] recursiveDescription]</span><br></pre></td></tr></table></figure>

<p><strong><strong>而 Chisel 为我们提供了更简洁的接口：</strong></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) pviews</span><br></pre></td></tr></table></figure>

<p>同样的，这条用于刷新显示的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) e (void)[CATransaction flush]</span><br></pre></td></tr></table></figure>

<p>Chisel 也为我们提供了简便的接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) caflush</span><br></pre></td></tr></table></figure>

<p>这里只给大家做一个简单的介绍，关于 Chisel 的更多内容，大家可以参看它的主页：<a href="https://github.com/facebook/chisel" target="_blank" rel="noopener">https://github.com/facebook/chisel</a></p>
<p>LLDB 自身完善的命令行系统，以及它的扩展能力，都成为提升我们开发效率的利器。正确的使用好调试工具，一定会帮助我们快速的解决更多的问题。</p>
<p>现在，通过 help 命令，来开始对 LLDB 命令行的探索吧，相信你能在这里发现更多的宝藏。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>ios 调试</tag>
      </tags>
  </entry>
  <entry>
    <title>公司用中会用到的iOS开源库和第三方组件(不断更新...)</title>
    <url>/2015/07/16/thirdToos/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog513845b040c30.jpg?imageView2/1/w/600/h/200" />
<a id="more"></a>

<p>分享一些目前我个人接触到的一些第三方组件和开源的库, 感谢开源, 减少了我们的开发成本, 节约了我们大量的时间, 让我们有更多的时间和精力专注做我们自己的产品.<br>总有没有接触过的 , 总有你会用到的 , 好用赞一下喽 . </p>
<table>
<thead>
<tr>
<th>项目名称</th>
<th>项目信息</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a></td>
<td>网络请求组件</td>
</tr>
<tr>
<td><a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a></td>
<td>本地数据库组件</td>
</tr>
<tr>
<td><a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a></td>
<td>多个缩略图缓存组件</td>
</tr>
<tr>
<td><a href="https://github.com/kishikawakatsumi/UICKeyChainStore" target="_blank" rel="noopener">UICKeyChainStore</a></td>
<td>存放用户账号密码组件</td>
</tr>
<tr>
<td><a href="https://github.com/tonymillion/Reachability" target="_blank" rel="noopener">Reachability</a></td>
<td>监测网络状态</td>
</tr>
<tr>
<td><a href="https://github.com/MatthewYork/DateTools" target="_blank" rel="noopener">DateTools</a></td>
<td>友好化时间</td>
</tr>
<tr>
<td><a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="noopener">MBProgressHUD</a></td>
<td>一款提示框第三方库</td>
</tr>
<tr>
<td><a href="https://github.com/mwaterfall/MWPhotoBrowser" target="_blank" rel="noopener">MWPhotoBrowser</a></td>
<td>一款简单的 iOS 照片浏览控件</td>
</tr>
<tr>
<td><a href="https://github.com/chiunam/CTAssetsPickerController" target="_blank" rel="noopener">CTAssetsPickerController</a></td>
<td>一个选择器组件, 支持从用户的相片库选择多张照片和视频。</td>
</tr>
<tr>
<td><a href="https://github.com/questbeat/QBPopupMenu" target="_blank" rel="noopener">QBPopupMenu</a></td>
<td>无需使用图片文件的 iOS 弹出式菜单</td>
</tr>
<tr>
<td><a href="https://github.com/UrbanApps/UAAppReviewManager" target="_blank" rel="noopener">UAAppReviewManager</a></td>
<td>一个能够让你方便地将提醒用户评分的功能加入 App 的工具</td>
</tr>
<tr>
<td><a href="https://github.com/nicklockwood/iRate" target="_blank" rel="noopener">iRate</a></td>
<td>也是一款让你加入提醒用户评分的工具</td>
</tr>
<tr>
<td><a href="https://github.com/Mantle/Mantle" target="_blank" rel="noopener">Mantle</a></td>
<td>主要用来将 JSON 数据模型化为 Model 对象</td>
</tr>
<tr>
<td><a href="https://github.com/tanis2000/MTLFMDBAdapter" target="_blank" rel="noopener">MTLFMDBAdapter</a></td>
<td>Mantle 和 FMDB 的转换工具</td>
</tr>
<tr>
<td><a href="https://github.com/layerhq/FMDBMigrationManager" target="_blank" rel="noopener">FMDBMigrationManager</a></td>
<td>支持 iOS SQLite 数据库迁移</td>
</tr>
<tr>
<td><a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" rel="noopener">MagicalRecord</a></td>
<td>CoreData来做存储数据</td>
</tr>
<tr>
<td><a href="https://github.com/bugsnag/bugsnag-cocoa" target="_blank" rel="noopener">Bugsnag</a></td>
<td>集成 Bugsnag 到应用中</td>
</tr>
<tr>
<td><a href="https://github.com/gangverk/GVUserDefaults" target="_blank" rel="noopener">GVUserDefaults</a></td>
<td>对 NSUserDefaults 进行了封装, 方便的进行本地化存储操作</td>
</tr>
<tr>
<td><a href="https://github.com/fabiocaccamo/FCCurrentLocationGeocoder" target="_blank" rel="noopener">FCCurrentLocationGeocoder</a></td>
<td>对用户当前地理位置进行正向地址编码和反向地址编码</td>
</tr>
<tr>
<td><a href="https://github.com/appfigures/AFSwipeToHide" target="_blank" rel="noopener">AFSwipeToHide</a></td>
<td>页面滚动时隐藏工具栏</td>
</tr>
<tr>
<td><a href="https://github.com/summerblue/baidu-translate-ios-sdk" target="_blank" rel="noopener">BaiduTranslate</a></td>
<td>非官方百度翻译工具</td>
</tr>
<tr>
<td><a href="https://github.com/JaviSoto/JSBadgeView" target="_blank" rel="noopener">JSBadgeView</a></td>
<td>添加带动画效果的未读消息数提醒</td>
</tr>
<tr>
<td><a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a></td>
<td>一个轻量级的布局框架, 用于替换官方的 AutoLayout 写法</td>
</tr>
<tr>
<td><a href="https://github.com/smileyborg/PureLayout" target="_blank" rel="noopener">PureLayout</a></td>
<td>代码自动布局工具</td>
</tr>
<tr>
<td><a href="https://github.com/adad184/MMPlaceHolder" target="_blank" rel="noopener">MMPlaceHolder</a></td>
<td>可在应用中显示视图的尺寸</td>
</tr>
<tr>
<td><a href="https://github.com/TimOliver/TOWebViewController" target="_blank" rel="noopener">TOWebViewController</a></td>
<td>可在应用中嵌套 Web 页面</td>
</tr>
<tr>
<td><a href="https://github.com/ivoleko/ILTranslucentView" target="_blank" rel="noopener">ILTranslucentView</a></td>
<td>半透明试图,高斯模糊试图</td>
</tr>
<tr>
<td><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="noopener">MJRefresh</a></td>
<td>下拉刷新，上拉加载更多组件</td>
</tr>
<tr>
<td><a href="https://github.com/windshg/VPImageCropper" target="_blank" rel="noopener">VPImageCropper</a></td>
<td>用户上传头像组件</td>
</tr>
<tr>
<td><a href="https://github.com/zys456465111/JCScrollView" target="_blank" rel="noopener">JCScrollView</a></td>
<td>快速给应用视图添加滚动分页效果</td>
</tr>
<tr>
<td><a href="https://github.com/brunow/BWTitlePagerView" target="_blank" rel="noopener">BWTitlePagerView</a></td>
<td>创建类似 Twitter 的导航栏分页效果</td>
</tr>
<tr>
<td><a href="https://github.com/carsonperrotti/CNPPopupController" target="_blank" rel="noopener">CNPPopupController</a></td>
<td>创建弹出卡片视图</td>
</tr>
<tr>
<td><a href="https://github.com/NghiaTranUIT/FeSpinner" target="_blank" rel="noopener">FeSpinner</a></td>
<td>加入沙漏等多种动画加载效果</td>
</tr>
<tr>
<td><a href="https://github.com/shu223/PulsingHalo" target="_blank" rel="noopener">PulsingHalo</a></td>
<td>涟漪动画效果</td>
</tr>
<tr>
<td><a href="https://github.com/leverdeterre/JMHoledView" target="_blank" rel="noopener">JMHoledView</a></td>
<td>方便创建用户引导视图</td>
</tr>
<tr>
<td><a href="https://github.com/cwRichardKim/RKNotificationHub" target="_blank" rel="noopener">RKNotificationHub</a></td>
<td>添加未读消息数显示提醒</td>
</tr>
<tr>
<td><a href="https://github.com/cruffenach/CRToast" target="_blank" rel="noopener">CRToast</a></td>
<td>从应用状态栏弹出消息提醒</td>
</tr>
<tr>
<td><a href="https://github.com/qixin1106/KeychainIDFA" target="_blank" rel="noopener">KeychainIDFA</a></td>
<td>获取 IDFA 标示当设备唯一识别, 并保存到 KeyChain 中</td>
</tr>
<tr>
<td><a href="https://github.com/dzenbot/DZNEmptyDataSet" target="_blank" rel="noopener">DZNEmptyDataSet</a></td>
<td>为 TableView 和 CollectionView 展示空数据视图</td>
</tr>
<tr>
<td><a href="https://github.com/nicklockwood/SwipeView" target="_blank" rel="noopener">SwipeView</a></td>
<td>快速给应用添加上滑动视图</td>
</tr>
<tr>
<td><a href="https://github.com/nicklockwood/FXBlurView" target="_blank" rel="noopener">FXBlurView</a></td>
<td>对视图进行模糊操作</td>
</tr>
<tr>
<td><a href="https://github.com/cloudorz/areapicker" target="_blank" rel="noopener">AreaPicker</a></td>
<td>省市地理位置选择器</td>
</tr>
<tr>
<td><a href="">MLAudioRecorder</a></td>
<td>边录边转码, 播放网络音频Button(本地缓存), 实时语音</td>
</tr>
<tr>
<td><a href="https://github.com/tiagomnh/THProgressView" target="_blank" rel="noopener">THProgressView</a></td>
<td>微型加载进度条</td>
</tr>
<tr>
<td><a href="https://github.com/windshg/VPImageCropper" target="_blank" rel="noopener">VPImageCropper</a></td>
<td>轻松实现微信选取图片并裁剪成头像的控件</td>
</tr>
<tr>
<td><a href="https://github.com/m1entus/WCAlertView" target="_blank" rel="noopener">WCAlertView</a></td>
<td>对官方 Alert View 进行封装, 更加容易使用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>开源库和第三方</tag>
      </tags>
  </entry>
  <entry>
    <title>Git在Xcode中的使用(未完待续)</title>
    <url>/2015/07/02/XcodeAddGit/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogF455F9EE-1B04-4F2A-8DD4-BE6C288C95C4.png?imageView2/1/w/600/h/200" />
<a id="more"></a>

<h3 id="Git在Xcode的两种用法"><a href="#Git在Xcode的两种用法" class="headerlink" title="Git在Xcode的两种用法"></a>Git在Xcode的两种用法</h3><p>Git 到底是什么, 基本是怎么使用的, 我之前有简单的介绍, 有不明白的可以<a href="http://rookie-liu.github.io/2015/05/08/gitUseCourse/" target="_blank" rel="noopener">跳转去看</a>. 也可以去看看<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">廖雪峰的Git</a>, 什么疯子的使用啦, 多人协作, 创建标签啦都有, 有兴趣的可以去看看. </p>
<p>随着对iOS 的开发和不断学习 , 个人也感觉到 Git 使用的重要性. 无论是团队开发还是个人开发中, Git 都是必不可少的使用利器. 并且在 Xcode 中就已经集成了 Git 的一大部分功能, 比如提交, 上传, 更新下载, 创建分支, 管理分支, 添加仓库源等等功能. 基于 Git 的代码托管服务的我目前知道的有两个, 国外的不用说 必须是 <code>Github</code>, 国内的就是 <code>Git@OSC</code>. 那么我现在来针对国内的 <code>Git@OSC</code> 来说一下…其实一般的公司如果使用 git 都会搭建属于自己的 Git 服务器, 使用的方法和他们两个都是基本相同的. <code>Git的使用我这里分为两种情况!</code></p>
<ul>
<li>在开始创建工程的时候就加入 Git 使用的.</li>
<li>还有一种就是你已经创建了工程, 中途加入 Git 使用的.</li>
</ul>
<h2 id="在开始创建工程的时候加入-Git"><a href="#在开始创建工程的时候加入-Git" class="headerlink" title="在开始创建工程的时候加入 Git"></a>在开始创建工程的时候加入 Git</h2><p>大体思路: 在 <a href="https://git.oschina.net" target="_blank" rel="noopener">Git@OSC</a>中注册—-&gt;创建一个代码仓库—-&gt;生成 <a href="http://git.oschina.net/oschina/git-osc/wikis/帮助#ssh-keys" target="_blank" rel="noopener">SSH 的公钥</a>—-&gt;新建工程勾选 Git 服务—-&gt;添加远程仓库源—-&gt;基本上大功告成啦.</p>
<ol>
<li>在<a href="https://git.oschina.net" target="_blank" rel="noopener">Git@OSC</a>中注册一个账号, 这个就不用细说了吧, 如果这个不能注册您也就不用往下看了, 哈哈😄</li>
<li>注册完成后添加一个代码仓库</li>
</ol>
<ul>
<li>添加一个代码仓库<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog1.png" /></li>
<li>创建一个代码仓库<br>这里的 Gitgnore 是用来忽略特殊文件的, 这里会给你自动生成, 就不必手动在添加你的特殊文件.有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files</code> …，有强迫症的童鞋心里肯定不爽。</li>
</ul>
<p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a><br><img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog22.png" /></p>
<ul>
<li>完成之后你会看都这样一些东东<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog33.png" /></li>
</ul>
<ol start="3">
<li>生成 SSH 公钥 </li>
</ol>
<ul>
<li>这里你可以访问<a href="http://git.oschina.net/oschina/git-osc/wikis/帮助#ssh-keys" target="_blank" rel="noopener">这里</a>的 SSH Keys 来看怎么样生成一个 SSH 公钥, 我这里将给你在终端做一遍.</li>
<li>打开终端:生成公钥<br>输入: <code>ssh-keygen -t rsa -C &quot;Rookie_liu@126.com&quot;</code>   这里的邮箱替换成你们自己的注册邮箱<br>出现:<code>Generating public/private rsa key pair.</code><br><code>Enter file in which to save the key (/Users/rookie/.ssh/id_rsa):</code> 这里选择你生成公钥的名字和位置, 默认位置为/Users/rookie/.ssh/id_rsa<br>我这里在<code>Enter file in which to save the key (/Users/rookie/.ssh/id_rsa):</code> 后面输入: FristSSH<br>出现:<code>Enter passphrase (empty for no passphrase):</code>这里让你输入一个密码, 空的也行<br>我这里在<code>Enter passphrase (empty for no passphrase):</code>直接 Enter 也就是为空<br>出现<code>Enter same passphrase again:</code> 在点击 Enter 为空<br>接着出现:<br>Your identification has been saved in FristSSH.<br>Your public key has been saved in FristSSH.pub.<br>The key fingerprint is:<br>c1:9c:3e:3b:87:e4:82:3a:34:80:20:44:09:17:f5:31 <a href="mailto:Rookie_liu@126.com" target="_blank" rel="noopener">Rookie_liu@126.com</a><br>The key’s randomart image is:</li>
</ul>
<p>+–[ RSA 2048]—-+<br>|=o+o. E          |<br>|oo   . = .       |<br>|+     . =        |<br>|o      . .       |<br>| .      S        |<br>|  o  . o +       |<br>| . .. . = .      |<br>|  ..   . o       |<br>|  ..             |<br>+—————–+<br>生成公钥成功啦 , 不信看图<br><img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog44.png" /></p>
<ul>
<li>然后再把FristSSH.pub中的内容加入git@osc 的SSH密钥中<br>在终端输入: cat /Users/rookie/FristSSH.pub   这个路径就是我们生成FristSSH.pub的路径.<br>然后会出现:好长好长一串字符, 这个就是我们需要的公钥 , 这里我们把它复制下来, 添加后他会让你输入一遍当前用户的密码<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog55.png" />
看这里, 看这里, 就添加成功啦 . 
<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog66.png" />
<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog7.png" /></li>
<li>添加 SSH 并连接<br>终端输入:ssh-add /Users/rookie/FirstSSh  这里添加的是另外你生成的那个文件<br>终端出现:Enter passphrase for /Users/rookie/Rookie: 输入密码 , 我们刚刚是空, 回车即可<br>终端出现Identity added: /Users/rookie/FristSSH (/Users/rookie/FristSSH)<br>然后验证,在终端输入:ssh -T <a href="mailto:git@git.oschina.net" target="_blank" rel="noopener">git@git.oschina.net</a><br>终端出现:Welcome to Git@OSC, Rookie_liu!</li>
</ul>
<p>我尼玛, 就这样 SSH 终于添加完成啦 , 是不是很简单呢啊 .</p>
<ol start="4">
<li><p>还要设置一下个人信息, 让人家要知道你是谁把<br>终端输入:<br>git config –global user.name “Rookie_liu”<br>git config –global user.email <a href="mailto:Rookie_liu@126.com" target="_blank" rel="noopener">Rookie_liu@126.com</a></p>
</li>
<li><p>新建并且设置上 Git 服务<br>其实也没有什么啦,就是在新建项目的时候, 勾选这里就行了, 看图吧 . </p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog8.png" /></li>
<li><p>最后一步啦设置项目远程仓库源</p>
</li>
</ol>
<ul>
<li>首先复制一下我们刚刚创建项目时候的 SSH 远程仓库地址, <img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog9.png" /></li>
<li>然后在我们的 Xcode 中添加远程仓库源<br>打开 Xcode 中的配置信息<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog10.png" />
添加仓库源
<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog11.png" />
添加完成啦
<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog12.png" />
这样就配置完成啦, 哈哈哈, 还可以吧. 挺简单的.  你可以用 Xcode 中集成的来做 Git 的上传和下载, 当然你也可以使用终端来进行操作 .</li>
</ul>
<ol start="7">
<li>最后验证<br>我们使用 Xcode 来验证一下看是否可以上传上去, 你也可以在终端进行上传, 不过在终端上传的话如果文件有时候有冲突你是不会看到的 , 然后上传完了如果有冲突你就傻了, 啥, 你不会在终端上传 , 那么<a href="http://rookie-liu.github.io/2015/05/08/gitUseCourse/" target="_blank" rel="noopener">请移步</a>, 这里有简单的使用, 如果想更牛逼的使用方法请问度娘或者谷哥哥吧. </li>
</ol>
<ul>
<li>我们在项目中随意添加一些东西 , 做一些改变<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog13.png" /></li>
<li>然后在 Commit<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog14.png" /></li>
<li>填写 commit 的信息, 这里越详细越好, 然后提交<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog15.png" /></li>
<li>接着Push 到我们的远程仓库就行啦<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog16.png" />
我们这里没有分支, 那么就提交到 master 主分支就行啦
<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog17.png" /></li>
<li>然后在看你的远程代码仓库, 有没有啦<br>不管你有没有 , 反正我这里是有了<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog18.png" />
OK 啦 , 这回才算是大功告成啦 , 啊啊 , 好累的说!!! 差不多就这样了吧 , 


</li>
</ul>
<h2 id="在已有的项目中加入-Git"><a href="#在已有的项目中加入-Git" class="headerlink" title="在已有的项目中加入 Git"></a>在已有的项目中加入 Git</h2><p>其实这里面的前几步都是和前面一样的.<br>大体思路: 在 <a href="https://git.oschina.net" target="_blank" rel="noopener">Git@OSC</a>中注册—-&gt;创建一个代码仓库—-&gt;生成 <a href="http://git.oschina.net/oschina/git-osc/wikis/帮助#ssh-keys" target="_blank" rel="noopener">SSH 的公钥</a>—-&gt;在终端打开的工程文件—-&gt;初始化 Git 服务—-&gt;添加远程仓库源—-&gt;<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758404317281e54b6f5375640abbb11e67be4cd49e0000" target="_blank" rel="noopener">忽略特殊文件</a>—-&gt;大功告成啦.</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Git的使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode使用技巧</title>
    <url>/2015/07/02/XcodeTechnique/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogD8D8681091245F7E192953495BF0CA1B.png?imageView2/1/w/600/h/200" />
<a id="more"></a>

<h3 id="Xcode快捷键"><a href="#Xcode快捷键" class="headerlink" title="Xcode快捷键"></a>Xcode快捷键</h3><p>使用快捷键, 对于提高工作效率有很大的帮助. 这里总结一些常用快捷键</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Cmd + Shift + O</td>
<td>快速查找类, 通过这个可以快速跳转到指定类的源代码中</td>
</tr>
<tr>
<td>Ctrl + 6</td>
<td>列出当前文件中所有的方法, 可以输入关键字来过滤,用他们可以快速定位想编辑的方法</td>
</tr>
<tr>
<td>Cmd + 1</td>
<td>类型为浮点的“序号”</td>
</tr>
<tr>
<td>Cmd + Ctrl + Up</td>
<td>在.h和.m 文件之间切换</td>
</tr>
<tr>
<td>Cmd + 1</td>
<td>切换成 Project Navigator(Cmd + 2 7 也可以做相应切换)</td>
</tr>
<tr>
<td>Cmd + Enter</td>
<td>切换成 standard editor</td>
</tr>
<tr>
<td>Cmd + Opt + Enter</td>
<td>切换成 standard editor (Opt = Alt大键盘中)</td>
</tr>
<tr>
<td>Cmd + Shift + Y</td>
<td>切换 Console View 的显示或隐藏</td>
</tr>
<tr>
<td>Cmd + O</td>
<td>隐藏左边导航(navigator)区</td>
</tr>
<tr>
<td>Cmd + Opt + O</td>
<td>隐藏右边的工具(Utility)区</td>
</tr>
<tr>
<td>Cmd + F</td>
<td>在当前类中查找</td>
</tr>
<tr>
<td>Cmd + Shift +F</td>
<td>在工程中查找</td>
</tr>
<tr>
<td>Cmd + R</td>
<td>运行, 如果选上直接 kill掉上次进程的话, 每次直接一按就可以重新运行了</td>
</tr>
<tr>
<td>Cmd + B</td>
<td>编译工程</td>
</tr>
<tr>
<td>Cmd + Shift + K</td>
<td>清空编译好的文件</td>
</tr>
<tr>
<td>Cmd + .</td>
<td>结束本次调试</td>
</tr>
<tr>
<td>ESC</td>
<td>调出代码补全</td>
</tr>
<tr>
<td>Cmd + 单击</td>
<td>查看该方法的实现</td>
</tr>
<tr>
<td>Opt + 单击</td>
<td>查看该方法的文档</td>
</tr>
<tr>
<td>Cmd + T</td>
<td>新建一个 Tab 栏</td>
</tr>
<tr>
<td>Cmd + [/]</td>
<td>上下移动代码</td>
</tr>
<tr>
<td>Cmd + N</td>
<td>新建文件</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C 编码规范</title>
    <url>/2015/06/26/iOS-Coding-standards/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogD4604528-BCB4-4A38-A14E-F0AF099138E2.png?imageView2/1/w/600/h/200" />
<a id="more"></a>
Objective-C 编码规范
======================
### <a name='project-structure'></a>项目目录
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">———Vendors      //不使用CocoaPod时第三方类库</span><br><span class="line">———Models</span><br><span class="line">———ViewModels   //MVVM设计模式时需要使用</span><br><span class="line">———Views</span><br><span class="line">———Controllers</span><br><span class="line">———Utils</span><br><span class="line">   ———Category</span><br><span class="line">   ———Helpers</span><br><span class="line">———Resources</span><br><span class="line">   ———Documents</span><br><span class="line">   ———Images</span><br><span class="line">   ———Audios</span><br><span class="line">   ———Data</span><br></pre></td></tr></table></figure>
### <a name='resource-structure'></a>资源目录
* 所有的需要适配的图片应该使用Xcode推荐的images.xcassets并根据使用的视图控制器分文件夹管理，通用的请放入Base文件夹
* 部分不需要适配而进行强制拉伸的图片应该以@3x比例制作并存放于Resources/Images目录  


<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a><a name='naming'/></a>命名</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a><a name='naming-basic-principle'></a>基本原则</h3><ul>
<li>仿照 Cocoa 风格来，使用长命名风格</li>
<li>变量命名推荐的命名语素顺序是：最开头是命名空间简写，然后越重要、区别度越大的语素越要往前放。经典的结构是：作用范围+限定修饰+类型。例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern ushort APIDefaultPageSize;        // 还行，能明白意思了</span><br><span class="line">extern ushort APIDefaultFetchPageSize;   // 加上些限定更好一些</span><br><span class="line">extern ushort APIFetchPageSizeDefault;   // 再好些，把重要的往前放</span><br><span class="line"></span><br><span class="line">YHToolbarComment    // 不推荐</span><br><span class="line">YHCommentToolbar    // OK，把类型（toolbar）置后</span><br></pre></td></tr></table></figure>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a><a name='namespace'></a>命名空间</h3><ul>
<li>类名、protocols、C 函数、常量、结构体和枚举应带有命名空间前缀；</li>
<li>类方法不要带前缀，结构体字段也不要带前缀</li>
</ul>
<h3 id="视图命名"><a href="#视图命名" class="headerlink" title="视图命名"></a><a name='naming-viewcontroller'></a>视图命名</h3><p>为了举例，我们假定有 <code>User</code>、<code>Tag</code>、<code>Category</code> 这几种 model 类型。</p>
<p>对象展示一般分列表和单个详情，其 view controller 分别使用 <strong>Model</strong>ListController 和 <strong>Model</strong>DetailController，推荐的语素顺序是：<code>Model名 + 限定与修饰 + ListController|DetailController</code>。举例说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// OK</span><br><span class="line">TagUserUsedListController</span><br><span class="line">TagInCategoryListController</span><br><span class="line">CategoryDetailController</span><br><span class="line"></span><br><span class="line">// 不推荐，列表统一使用 ListController，不指明是 table view 还是 collection view</span><br><span class="line">UserFollowerTableViewController</span><br><span class="line"></span><br><span class="line">// OK</span><br><span class="line">UserFollowerListController</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">UserLikedTagListController</span><br><span class="line"></span><br><span class="line">// OK，把显示的对象放在第一位</span><br><span class="line">TagUserLikedListController</span><br><span class="line"></span><br><span class="line">// 糟糕，如果是 view controller，必须以 Controller 或 Displayer 结尾</span><br><span class="line">TagListView</span><br></pre></td></tr></table></figure>

<p>经常为了便于多个界面复用，我们会把 model 的显示统一在一个 view controller 中，在其他界面嵌入这个 view controller。我们把这类专门管理显示的 view controller 叫做 <code>displayer</code>。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UserListDisplayer</span><br><span class="line">TagListDisplayer</span><br></pre></td></tr></table></figure>

<p>UIView 级别的组件不要以 Controller 或 Displayer 结尾，如果起到管理作用可以使用 control 结尾。</p>
<p><strong>动机</strong></p>
<blockquote>
<p>把 model 名放在首位（如 TagUserLikedListController 而不是 UserLikedTagListController）的主要考量是便于搜索。因为 Xcode 不支持乱序搜索，关键词只能从前往后才会有结果。</p>
<p>如果限定词在前，因为不同人理解差异，自己也会遗忘，这个限定词经常是输入不能的，只能搜 TagList 再从列表中查找，等于第一位的查找语素就废掉了。当 model 类型在第一位时，基本上熟悉这个项目的人都清楚要查找的视图显示的是什么类型，第一位正确了，后面添加/修改限定就很方便了。</p>
<p>另一个便利的场景是参考之前界面实现另一个界面时，查找的大都是相同类型的界面，如实现 UserFollowerListController 参考 UserFollowingListController；而相同限定的场景比较少见，像 UserLikedTagListController 参考 UserLikedCategoryListController 的可能性就较少。</p>
<p>PS: 务必经常使用 Xcode 的 Open Quickly（默认快捷键 Command+Shift+O）</p>
</blockquote>
<h3 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a><a name='naming-method'></a>方法名</h3><ul>
<li>以 <code>alloc</code>、<code>copy</code>、<code>init</code>、<code>mutableCopy</code>、<code>new</code> 开头的方法要注意，它们会改变ARC的行为。[^1]</li>
<li>以 <code>get</code>、<code>set</code> 开头的方法有特殊的意义，不要随意定义。<ol>
<li>set 是属性默认的设置方法，如果函数不是为了设置类成员，则不要用 <code>set</code> 开头，可用 <code>setup</code> 替代。</li>
<li>get 和属性方法无关，但在 Cocoa 中，其标准行为是通过引用传值，而不是直接返回结果的。欲获取变量，直接以变量名为名，如：<code>userInfomation</code>，而不是 <code>getUserInfomation</code>。</li>
</ol>
</li>
</ul>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objective-C</span><br><span class="line">// OK</span><br><span class="line">- (NSString *)name;</span><br><span class="line"></span><br><span class="line">// 糟糕，应用上面的写法</span><br><span class="line">- (NSString *)getName;</span><br><span class="line"></span><br><span class="line">// OK，但极少使用</span><br><span class="line">- (void)getName:(NSString **)buffer range:(NSRange)inRange;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// OK</span><br><span class="line">- (NSSize)cellSize;</span><br><span class="line"></span><br><span class="line">// 糟糕，应用上面的写法</span><br><span class="line">- (NSSize)calcCellSize;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">// 对 controller 做一般设置，OK</span><br><span class="line">- (void)setupController;</span><br><span class="line"></span><br><span class="line">// 列出具体设置的内容，更好</span><br><span class="line">- (void)setupControllerObservers;</span><br><span class="line"></span><br><span class="line">// 糟糕，set 专用于设置属性</span><br><span class="line">- (void)setController;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objective-C</span><br><span class="line">// 来自官方文档</span><br><span class="line">insertObject:atIndex:    // OK</span><br><span class="line">insert:at:               // 不清晰，插入了什么？at 具体指哪里？</span><br><span class="line">removeObjectAtIndex:     // OK</span><br><span class="line">removeObject:            // OK</span><br><span class="line">remove:                  // 糟糕，什么被移除了？</span><br></pre></td></tr></table></figure>

<h3 id="协议名"><a href="#协议名" class="headerlink" title="协议名"></a><a name='naming-protocol'></a>协议名</h3><p>好的协议名应能立刻让人分辨出这不是一个类名，除了以常用的 delegate、dateSource 做结尾外，还可以使用 …ing 这种形式，如：<code>NSCoding</code>、<code>NSCopying</code>、<code>NSLocking</code>。</p>
<h3 id="通知命名"><a href="#通知命名" class="headerlink" title="通知命名"></a><a name='naming-notifications'></a>通知命名</h3><p>基本命名格式是：<code>[与通知相关的类名] + [Did | Will] + [UniquePartOfName] + Notification</code>，例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objective-C</span><br><span class="line">NSApplicationDidBecomeActiveNotification</span><br><span class="line">NSWindowDidMiniaturizeNotification</span><br><span class="line">NSTextViewDidChangeSelectionNotification</span><br><span class="line">NSColorPanelColorDidChangeNotification</span><br></pre></td></tr></table></figure>

<h3 id="临时变量命名"><a href="#临时变量命名" class="headerlink" title="临时变量命名"></a><a name='naming-temporary-variable'></a>临时变量命名</h3><ul>
<li>临时变量可以写得很短，如 i、k、vc 这样；</li>
<li>临时变量可以使用匈牙利前缀，但数据类型不可以作为前缀：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// OK</span><br><span class="line">wCell, vcMaster, vToolbar</span><br><span class="line"></span><br><span class="line">// 糟糕，数据类型作为前缀</span><br><span class="line">bool_switchState, floatBoxHeight</span><br></pre></td></tr></table></figure>

<p>推荐的前缀：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ix</td>
<td>序号，起始为0</td>
</tr>
<tr>
<td>in</td>
<td>序号（自然数范围），起始为1</td>
</tr>
<tr>
<td>if</td>
<td>类型为浮点的“序号”</td>
</tr>
<tr>
<td>x</td>
<td>坐标</td>
</tr>
<tr>
<td>y</td>
<td>坐标</td>
</tr>
<tr>
<td>w</td>
<td>宽度</td>
</tr>
<tr>
<td>h</td>
<td>高度</td>
</tr>
<tr>
<td>vc</td>
<td>视图控制器</td>
</tr>
<tr>
<td>v</td>
<td>视图</td>
</tr>
</tbody></table>
<h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a><a name='naming-constant'></a>常量命名</h3><ul>
<li>尽量避免使用预处理命令#define来定义常量，因为#define定义的 常量是全局的，会将工程中所有定义使用的标示符替换为定义的常量，可能因为定义的标示符重复而引起问题，且不易排查。  </li>
<li>尽量使用static const来进行常量的定义，好处是可以明显地知道常量的类型，且避免用预处理命令#define引起的问题  </li>
<li>用static const进行常量的定义的时候，首写字母要大写，并加小写字母前缀k</li>
<li>对于枚举常量，使用typedef NS_ENUM，对于位掩码常量，使用typedef NS_OPTION，这两个宏已经对C和C++进行了不同的枚举处理  </li>
</ul>
<p>除以上规则约定外，其他常量约定了以下前缀：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>k</td>
<td>宏常量</td>
</tr>
<tr>
<td>CDEN</td>
<td>Core Data entity name</td>
</tr>
<tr>
<td>UDk</td>
<td>User Default key</td>
</tr>
<tr>
<td>KCk</td>
<td>Key Chain key</td>
</tr>
<tr>
<td>APIURL</td>
<td>接口地址</td>
</tr>
</tbody></table>
<p>另见：<a href="#constant">常量管理</a></p>
<h3 id="资源命名"><a href="#资源命名" class="headerlink" title="资源命名"></a><a name='naming-resource'></a>资源命名</h3><p>图片资源在放入xcassets中相应视图控制器文件夹的基础上，根据<code>[相应的功能] + [Btn | BtnClick | Icon]</code>，例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UserAvatarDefaultIcon</span><br><span class="line">PostCommentBtn</span><br><span class="line">ClickShowWebsiteBtn</span><br></pre></td></tr></table></figure>

<h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a><a name='naming-match-case'></a>大小写</h3><ul>
<li>类名采用大驼峰（<code>UpperCamelCase</code>）</li>
<li>类成员、方法小驼峰（<code>lowerCamelCase</code>）</li>
<li>局部变量大小写首选小驼峰，也可使用小写下划线的形式（<code>snake_case</code>）</li>
<li>C函数的命名用大驼峰</li>
</ul>
<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a><a name='abbreviation'/></a>缩写</h3><p>可以使用广泛使用的缩写，如 <code>URL</code>、<code>JSON</code>，并且缩写要大写。但像将<code>download</code>简写为<code>dl</code>这种是不可以的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objective-C</span><br><span class="line">// OK</span><br><span class="line">ID, URL, JSON, WWW</span><br><span class="line"></span><br><span class="line">// 糟糕</span><br><span class="line">id, Url, json, www</span><br><span class="line"></span><br><span class="line">destinationSelection       // OK</span><br><span class="line">destSel                    // 糟糕</span><br><span class="line">setBackgroundColor:        // OK</span><br><span class="line">setBkgdColor:              // 糟糕</span><br></pre></td></tr></table></figure>


<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><a name='naming-others'></a>其他</h3><p>i，j专用于循环标号</p>
<p>为私有方法命名不要直接以“_”开头，而应以“命名空间_”开头。</p>
<h2 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a><a name='formatting'/></a>代码格式化</h2><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a><a name='spaces'></a>空格</h3><p>类方法声明在方法类型与返回类型之间要有空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Objective-C</span><br><span class="line">// 糟糕</span><br><span class="line">-(void)methodName:(NSString *)string;</span><br><span class="line"></span><br><span class="line">// OK</span><br><span class="line">- (void)methodName:(NSString *)string;</span><br></pre></td></tr></table></figure>

<p>条件判断的括号内侧不应有空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 糟糕</span><br><span class="line">if ( a &lt; b ) &#123;</span><br><span class="line">    // something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// OK</span><br><span class="line">if (a &lt; b) &#123;</span><br><span class="line">    // something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关系运算符（如 <code>&gt;=</code>、<code>!=</code>）和逻辑运算符（如 <code>&amp;&amp;</code>、<code>||</code>）两边要有空格。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// OK</span><br><span class="line">(someValue &gt; 100)? YES : NO</span><br><span class="line"></span><br><span class="line">// OK</span><br><span class="line">(items)?: @[]</span><br></pre></td></tr></table></figure>

<p>二元算数运算符两侧是否加空格不确定，根据情况自己定。一元运算符与操作数之前没有空格。</p>
<p>多个参数逗号后留一个空格（这也符合正常的西文语法）。</p>
<h3 id="花括号"><a href="#花括号" class="headerlink" title="花括号"></a><a name='braces'></a>花括号</h3><p>方法的花括号推荐另起一行。方法内部需要写在一行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)methodName:(NSString *)string &#123;</span><br><span class="line"> ↑空格                                ↑空格，推荐花括号在一行</span><br><span class="line">    if () &#123;</span><br><span class="line">   空格↑  ↑空格，花括号不要另起一行</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line"> 要换行↑ ↑空格，花括号不要另起一行</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动机</strong></p>
<blockquote>
<p>Xcode 默认的花括号位置是这样的：方法内部的各种补全都是在同一行的；方法定义的比较混乱，默认模版另起一行，但从 Interface Builder 中连线生成的方法在同一行的。</p>
<p>考虑到 Xcode 的默认行为，方法内部要另起一行，方法所在行不强制定死。另外，模版可以定制，而 IB 生成的代码不可定制，所以不另起一行的写法优先。</p>
<p>另起一行的写法在代码折叠后非常难看。</p>
</blockquote>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a><a name='line-wrap'></a>空行</h3><p>相对独立的程序块之间、变量说明之后必须加空行。</p>
<h3 id="折行"><a href="#折行" class="headerlink" title="折行"></a><a name='line-wrap'></a>折行</h3><p>与多数其他规范不同，不建议手动折行。</p>
<p><strong>动机</strong></p>
<blockquote>
<p>手动折行的效果严重宽度依赖于窗口宽度——窗口过宽浪费宝贵的屏幕空间，较窄时可能无法阅读。而且 Xcode 自动折行的效果还是不错的。</p>
</blockquote>
<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a><a name='code-organization'></a>代码组织</h2><ul>
<li>函数长度（行数）不应超过100行。例外：对于顺序执行的初始化函数，如果其中的过程没有提取为独立方法的必要，则不必限制长度。</li>
<li>单个文件方法数不应超过30个</li>
<li>不要按类别排序（如把IBAction放在一块），应按任务把相关的组合在一起</li>
<li>禁止出现超过两层循环的代码，用函数或block替代。</li>
</ul>
<p>尽早返回错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 为了简化示例，没有错误处理，并使用了伪代码</span><br><span class="line"></span><br><span class="line">// 糟糕的例子</span><br><span class="line">- (Task *)creatTaskWithPath:(NSString *)path &#123;</span><br><span class="line">    Task *aTask;</span><br><span class="line">    if ([path isURL]) &#123;</span><br><span class="line">        if ([fileManager isWritableFileAtPath:path]) &#123;</span><br><span class="line">            if (![taskManager hasTaskWithPath:path]) &#123;</span><br><span class="line">                aTask = [[Task alloc] initWithPath:path];</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return aTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 改写的例子</span><br><span class="line">- (Task *)creatTaskWithPath:(NSString *)path &#123;</span><br><span class="line">    if (![path isURL]) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (![fileManager isWritableFileAtPath:path]) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ([taskManager hasTaskWithPath:path]) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Task *aTask = [[Task alloc] initWithPath:path];</span><br><span class="line">    return aTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类"><a href="#类" class="headerlink" title="类"></a><a name='class'/></a>类</h2><p>禁止在类的 interface 中定义任何 iVar 成员，只允许使用属性，但可以在特定情形中使用属性生成的 iVar。</p>
<p>尽量总是使用点操作符访问属性，而不是属性生成的 iVar 变量。以下情形除外：</p>
<ul>
<li>明确要避免修改产生 KVO 通知的；</li>
<li>需重写属性 getter 或 setter 的；</li>
<li>性能分析确定使用属性会导致性能不可接受的；</li>
<li>多线程环境中，为防止互斥一次进行多个修改的；</li>
<li>init、dealloc 方法中。</li>
</ul>
<p>动机</p>
<blockquote>
<p>如果使用 iVar，很多情况要特殊处理，容易出错。总是使用成员，规则简单，不易出问题。</p>
<p>直接访问 iVar 的 block 会 retain iVar 所属的对象，这点很容易被忽略</p>
<p>定义和使用 iVar 都会产生编译警告，只不过默认设置没启用这两个警告</p>
</blockquote>
<h3 id="Property-attributes"><a href="#Property-attributes" class="headerlink" title="Property attributes"></a><a name='property-attributes'></a>Property attributes</h3><p>什么时候使用 copy？</p>
<ul>
<li>block 属性要定义成 copy。</li>
<li>当一个属性赋值后不期望改变时应当用 copy，最常见的类型如 NSString、NSURL。可变类型的成员，如 NSMutableArray、NSMutableDictionary 不能定成 copy 的。</li>
</ul>
<p>相关 Demo 可在 <a href="https://github.com/BB9z/PropertyTest" target="_blank" rel="noopener">https://github.com/BB9z/PropertyTest</a> 获得。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a><a name='constant'></a>常量</h2><p>除非调试用的、控制不同编译模式行为的常量可用宏外，其他常量不得用宏定义。</p>
<p>常量定义示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 头文件</span><br><span class="line">extern ushort APIFetchPageSizeDefault;    // 无const，可在外部修改</span><br><span class="line"></span><br><span class="line">// 实现文件</span><br><span class="line">ushort APIFetchPageSizeDefault = 10;</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a><a name='comment'></a>注释</h2><p>使用Xcode插件VVDocumenter-Xcode可以有效的进行编写注释的需求<br>所有的.h文件中对外的接口方法定义中必须进行注释，而.m文件中除非已经在.h中已经注释的方法或者是get/set方法可以不注释外，其余函数必须进行注释。<br>修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。<br>最后一点，尽量让代码可以自表述，而不是依赖注释。</p>
<blockquote>
<p>注释应该表达那些代码没有表达以及无法表达的东西。如果一段注释被用于解释一些本应该由这段代码自己表达的东西，我们就应该将这段注释看成一个改变代码结构或编码惯例直至代码可以自我表达的信号。我们重命名那些糟糕的方法和类名，而不是去修补。我们选择将长函数中的一些代码段抽取出来形成一些小函数，这些小函数的名字可以表述原代码段的意图，而不是对这些代码段进行注释。尽可能的通过代码进行表达。你通过代码所能表达的和你想要表达的所有事情之间的差额将为注释提供了一个合理的候选使用场合。对那些代码无法表达的东西进行注释，而不要仅简单地注释那些代码没有表达的东西。”[^2]</p>
</blockquote>
<h3 id="块注释"><a href="#块注释" class="headerlink" title="块注释"></a><a name='block-comment'></a>块注释</h3><p>方法内部禁止使用块注释。除非要临时注释大段代码，一般情况总应使用行注释。</p>
<p><strong>动机</strong></p>
<blockquote>
<p>因为块注释不能正确嵌套。</p>
</blockquote>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a><a name='others'></a>其他</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a><a name='exception'></a>异常</h3><ul>
<li>作为被调用模块的维护者，当被调用不当时（参数有问题、不和时宜），如何处理需要考虑（抛出异常还是返回错误状态）；</li>
<li>不要依赖 try catch，它不是代替你做检查、填补遗漏的工具。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><a name='reference'></a>参考</h2><ul>
<li><a href="https://github.com/Chinamobo/iOS-Team-Norms/blob/master/CodeStyle.md" target="_blank" rel="noopener">Chinamobo Objective-C 编码规范</a></li>
<li><a href="http://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="noopener">Coding Guidelines for Cocoa</a></li>
<li><a href="https://github.com/raywenderlich/swift-style-guide" target="_blank" rel="noopener">https://github.com/raywenderlich/swift-style-guide</a></li>
<li><a href="https://github.com/github/swift-style-guide" target="_blank" rel="noopener">https://github.com/github/swift-style-guide</a></li>
<li><a href="https://github.com/github/objective-c-conventions" target="_blank" rel="noopener">https://github.com/github/objective-c-conventions</a></li>
<li><a href="https://github.com/jverkoey/iOS-Best-Practices" target="_blank" rel="noopener">https://github.com/jverkoey/iOS-Best-Practices</a></li>
<li><a href="https://github.com/troyharris/Complete-iOS-StyleGuide" target="_blank" rel="noopener">https://github.com/troyharris/Complete-iOS-StyleGuide</a></li>
<li><a href="https://github.com/objc-zen/objc-zen-book" target="_blank" rel="noopener">https://github.com/objc-zen/objc-zen-book</a></li>
<li><a href="//www.v2ex.com/t/25732">你们是如何为 View Controller 的变量命名的呢？ - V2EX</a></li>
<li><a href="http://www.amazon.cn/dp/B0061XKRXA" target="_blank" rel="noopener">代码大全(第2版) - 亚马逊</a></li>
</ul>
<p><a name='footnote'></a><br>[^1]: <a href="http://pingguohe.net/2012/06/22/talk_arc_again/" target="_blank" rel="noopener">再谈ARC - 苹果核</a><br>[^2]: <a href="http://bigwhite.blogbus.com/logs/125602412.html" target="_blank" rel="noopener">只对代码无法表达的东西写注释 - Tony Bai</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>编码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>CoreData的使用</title>
    <url>/2015/06/19/CoreData/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog82FCE919-B434-43E7-9431-CAD40B1B9C43.png?imageView2/1/w/600/h/200" />
<a id="more"></a>

<h3 id="CoreData-是什么"><a href="#CoreData-是什么" class="headerlink" title="CoreData 是什么?"></a>CoreData 是什么?</h3><ul>
<li>Core Data 是一个模型层的技术。Core Data 帮助你建立代表程序状态的模型层。Core Data 也是一种持久化技术，它能将模型对象的状态持久化到磁盘，但它最重要的特点是：Core Data 不仅是一个加载、保存数据的框架，它还能和内存中的数据很好的共事</li>
<li>Core Data是iOS5之后才出现的一个框架，它提供了对象-关系映射(ORM)的功能，即能够将OC对象转化成数据，保存在SQLite数据库文件中，也能够将保存在数据库中的数据还原成OC对象。在此数据操作期间，我们不需要编写任何SQL语句.</li>
</ul>
<h3 id="CoreData-基本概念"><a href="#CoreData-基本概念" class="headerlink" title="CoreData 基本概念"></a>CoreData 基本概念</h3><ul>
<li><p>托管对象（managed object）<br>一个托管对象代表你想要保存到数据存储中的一个对象。这在概念上类似于SQL中的一条记录， 并且通常也包含一些域，这些域对应于你想要保存的对象的属性。</p>
</li>
<li><p>数据存储（data store）<br>Core Data支持4中类型的数据存储：SQLiteStore, XMLStore, BinaryStore, InMemoryStore。</p>
</li>
<li><p>托管对象上下文(managed object context)<br>托管对象上下文类似于应用程序和数据存储之间的一块缓冲区。这块缓冲区包含所有未被写入数据存储的托管对象。你可以添加、删除、更改缓冲区内的托管对象。在很多时候，当你需要读、插入、删除对象时，你将会调用托管对象上下文的方法。<br><code>操作实际内容 作用：插入数据  查询  更新  删除</code></p>
</li>
<li><p>持久化存储协调器（persistent store coordinator）<br>持久化存储协调器处理到数据存储的连接，并且包含一些底层信息，像用到数据存储的名字和位置。这个类通常被托管对象上下文用到。<br><code>NSPersistentStoreCoordinator(持久化存储助理) 相当于数据库的连接器</code></p>
</li>
<li><p>托管对象模型(managed object model)<br>托管对象模型是一个类，这个类包含每一个你想存储到数据存储中的托管对象的定义。<br><code>NSManagedObjectModel(被管理的对象模型)相当于实体，不过它包含 了实体间的关系</code></p>
</li>
</ul>
<p>这里有我写的一个简单的Dmeo <a href="http://pan.baidu.com/s/1o6iO6AA" target="_blank" rel="noopener">http://pan.baidu.com/s/1o6iO6AA</a> <a href="http://pan.baidu.com/s/1o6iO6AA" target="_blank" rel="noopener">这里下载</a>提取码 <strong><em>3k2z</em></strong> , 有兴趣的可以自己下载来看..<br>这个 Demo 主要讲的是 CoreData 的原理上的问题, 利用NSManagedObjectContext来实现增删改查等基本的原来,用起来不够整洁方便, 看起来也过于繁琐! <strong><em>下面我们来看一个比现在这个看起来相对简单的Demo, 然后流程我也会讲到!</em></strong></p>
<h3 id="CoreData-的使用"><a href="#CoreData-的使用" class="headerlink" title="CoreData 的使用"></a>CoreData 的使用</h3><ul>
<li><p>首先我们先创建两个实体 <strong><em>PeopleInfo</em></strong> 和 <strong><em>CarInfo</em></strong><br>PeopleInfo实体中有: name , age , sex 三个属性<br>CarInfo实体中有: carName, carAge  两个属性</p>
</li>
<li><p>然后建立 <strong><em>PeopleInfo</em></strong> 和 <strong><em>CarInfo</em></strong>的关联关系<br>我这里的关系是一个人可以有很多辆汽车  </p>
</li>
<li><p><strong>PeopleInfo*</strong> 的属性和关系表</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogcoreData1.png" />

</li>
</ul>
<p><strong><em>CarInfo</em></strong> 的属性和关系表<br><img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogCoreData2.png" /></p>
<ul>
<li>接着生成Model类<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog1111.png" />
Editor->>Create NSManagedObject Subciass..
<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog2222.png" />
这里你们应该只有一个,在没有升级的情况下,那么就选定一个就可以了
<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog3333.png" />
这里可以两个一起生成, 编译如果有错误, 那么就重新生成一次,将原来的覆盖即可;(因为 Xcode 有时候会抽风)


</li>
</ul>
<ul>
<li><p>接着写一个ManageData管理的单利类,用来管理NSManagedObjectContext的一些增删改查的操作<br>这个单利的作用是对 CoreData 数据库的创建, 数据的增删改查等等一些操作</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog977850D3-78F9-458D-BCD6-FF89EE85B55B.png" />
对数据的创建, 并且新建一个NSManagedObjectContext,供整个单利来使用
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setupManaegdObjectContext&#123;</span><br><span class="line">    NSURL *paths = [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject];</span><br><span class="line">    NSURL *storeURL = [paths URLByAppendingPathComponent:@&quot;text.sqlite&quot;];</span><br><span class="line">    self.managedObjectContext = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType];</span><br><span class="line">    self.managedObjectContext.persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[NSManagedObjectModel mergedModelFromBundles:nil]];</span><br><span class="line">    NSError *error;</span><br><span class="line">    NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys:</span><br><span class="line">                             [NSNumber numberWithBool:YES],NSMigratePersistentStoresAutomaticallyOption,[NSNumber numberWithBool:YES],NSInferMappingModelAutomaticallyOption,nil];</span><br><span class="line">    [self.managedObjectContext.persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:options error:&amp;error];</span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;setupManagedObjectContextError: %@&quot;, error);</span><br><span class="line">    &#125;</span><br><span class="line">    self.managedObjectContext.undoManager = [[NSUndoManager alloc] init];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来我们对我们要操作的实体类来添加一个Category(类目)<br>我们用这个类目来对整个实体类中得数据来进行操作, 比如在这里实体类中添加数据, 改变数据,删除数据等等, <code>之所以我们在这里用一个类目来扩展这个实体类是因为我们要升级原有的实体类,所以这些操作要在这个类的类目中来进行</code><br>这里我们针对PeopleInfo实体来新建一个类目</p>
<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogE3371886-865D-4723-82B8-5588ED0E8F59.png" />

<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogD15881DB-6F7E-47C3-B973-29EA8E632C99.png" />

<p><code>Categray(类目)有什么作用呢</code></p>
</li>
</ul>
<p>1.为没有源代码的类添加方法,因为我们拿不到源代码,所以不能添加实例变量但可以添加方法<br>2.具体操作:在相应的.h文件里声明,在.m文件里实现 声明和实现与其他普通的类一样<br>3.具体格式:在.h文件里 @interface 需要扩展的类名(NSString) (扩展类名)开头 @end结束 在.m文件里以:@implementation 需要扩展的类名(NSString) (扩展类名) @end结束<br>4.在main.m文件里的调用和其他方法一样<br><code>延展有什么作用呢</code><br>主要是为有源代码的类添加实例方法或对象 内容私有只在.m文件里实现,不进行声明.<br>1.在.m文件里的开头之前添加@interface 类名 (延展类名){添加实例变量和方法}@end结束<br>2.在.m文件的实现部分对延展里面的方法进行实现</p>
<ul>
<li><p>在PeopleInfo类目中写方添加一条数据的方法并实现<br>在.h中写方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (PeopleInfo *)addSomeDataManagedObjectContext:(NSManagedObjectContext *)context WhitName:(NSString *)name WhitSex:(NSString*)sex WhitAge:(NSString *)age;</span><br></pre></td></tr></table></figure>
<p>在.m中实现方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (PeopleInfo *)addSomeDataManagedObjectContext:(NSManagedObjectContext *)context WhitName:(NSString *)name WhitSex:(NSString *)sex WhitAge:(NSString *)age</span><br><span class="line">&#123;</span><br><span class="line">    PeopleInfo *peo = nil;</span><br><span class="line">    </span><br><span class="line">    NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;PeopleInfo&quot;];</span><br><span class="line">    request.predicate = [NSPredicate predicateWithFormat:@&quot;age == %@&quot;, peo.age];</span><br><span class="line">    NSError *error = nil;</span><br><span class="line">    NSArray *matches = [context executeFetchRequest:request error:&amp;error];</span><br><span class="line">    if (!matches||[matches count] &gt; 1) &#123;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if (![matches count]) &#123;</span><br><span class="line">            peo = [NSEntityDescription insertNewObjectForEntityForName:@&quot;PeopleInfo&quot; inManagedObjectContext:context];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            peo = [matches lastObject];</span><br><span class="line">        &#125;</span><br><span class="line">        peo.name = name;</span><br><span class="line">        peo.age = age;</span><br><span class="line">        peo.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    return peo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在单利ManageData中利用NSManagedObjectContext来添数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addDataWhitName:(NSString *)name WhitSex:(NSString*)sex WhitAge:(NSString *)age&#123;</span><br><span class="line">    [PeopleInfo addSomeDataManagedObjectContext:self.managedObjectContext WhitName:name WhitSex:sex WhitAge:age];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后在ViewController中调用添加数据的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[ManageData shareInstance] addDataWhitName:self.nameTextField.text WhitSex:self.sexTextField.text WhitAge:self.ageTextField.text];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在这里我只写了添加的一个操作, 剩余的操作请大家<a href="http://pan.baidu.com/s/1pJvDGM3" target="_blank" rel="noopener">下载Demo</a></p>
<h3 id="CoreData-升级-版本升级"><a href="#CoreData-升级-版本升级" class="headerlink" title="CoreData 升级-版本升级"></a>CoreData 升级-版本升级</h3><ul>
<li>升级分为两种,第一种是简单的升级, 在原来的基础上添加字段属性的.另外一种是比较复杂的操作,修改原来数据表的字段的名字或者属性. <h2 id="添加字段属性升级"><a href="#添加字段属性升级" class="headerlink" title="添加字段属性升级"></a>添加字段属性升级</h2></li>
<li>如果您的APP已经上架,那么我们的CoreData 数据表不能进行操作, 否则就会有各种奇葩的错误, 如果我们想进行数据表的操作首先我们应该在原来的基础上进行升级, 然后再操作, 完成后再把我们的 CoreData 的 Model Version选择到我们已经升级的版本即可;</li>
<li>选择要升级的版本进行升级<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogD06A804C-0F69-48CE-ABAD-ECA979532D40.png" />
<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog558A151A-B4D6-4834-A3B6-46A02646A2C8.png" /></li>
<li>升级完成后可以在新的表中添加新的字段什么的都可以, </li>
<li>升级完成, 选择版本<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog715558BF-0F75-42FD-AF07-7909C6E9C376.png" /></li>
<li>升级完成后再生成 Model 等文件, 和刚才的操作步骤一样<h2 id="修改原来字段名字操作"><a href="#修改原来字段名字操作" class="headerlink" title="修改原来字段名字操作"></a>修改原来字段名字操作</h2></li>
<li>首先也是要升级一个新的版本(同上升级新), 在修改原有字段的名字<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogFE009721-D88F-436D-8371-596E994AF24C.png" /></li>
<li>升级完成后再生成 Model 等文件, 和刚才的操作步骤一样</li>
</ul>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>CoreData</tag>
      </tags>
  </entry>
  <entry>
    <title>使用PureLayout进行自动布局</title>
    <url>/2015/05/27/PureLayout/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogPureLayout.png?imageView2/1/w/600/h/200" />
<a id="more"></a>

<p>PureLayout 是 iOS &amp; OS X Auto Layout 的终极 API——非常简单，又非常强大。PureLayout 通过一个全面的Auto Layout API 扩展了 UIView/NSView, NSArray 和 NSLayoutConstraint，仿照苹果自身的框架, 构建了一个全面的自动布局 API, 这样你再也不用为适配而苦恼啦!!!</p>
<h3 id="添加PureLayout到你的工程里面"><a href="#添加PureLayout到你的工程里面" class="headerlink" title="添加PureLayout到你的工程里面"></a>添加PureLayout到你的工程里面</h3><ul>
<li>用CocoaPods安装（<code>podilfe中加pod &#39;PureLayout&#39;</code>）/GitHub下载PureLayout, 手动添加到你的项目中</li>
<li>导入头文件<code>#import &lt;PureLayout/PureLayout.h&gt;</code>  /  <code>#import &quot;PureLayout.h&quot;</code></li>
</ul>
<h3 id="我们就这个布局来简单说一下"><a href="#我们就这个布局来简单说一下" class="headerlink" title="我们就这个布局来简单说一下"></a>我们就这个布局来简单说一下</h3><img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogF2A38CDD-71C5-4115-9F9B-8ECB0D77C850.png" />

<h2 id="首先新建几个-View"><a href="#首先新建几个-View" class="headerlink" title="首先新建几个 View"></a>首先新建几个 View</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong) UIView *blueView;</span><br><span class="line">@property (nonatomic, strong) UIView *redView;</span><br><span class="line">@property (nonatomic, strong) UIView *yellowView;</span><br><span class="line">@property (nonatomic, strong) UIView *greenView;</span><br><span class="line">@property (nonatomic, assign) BOOL didSetupConstraints;  // 判断是否存在约束条件</span><br></pre></td></tr></table></figure>

<h2 id="然后在加载试图"><a href="#然后在加载试图" class="headerlink" title="然后在加载试图"></a>然后在加载试图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)loadView</span><br><span class="line">&#123;</span><br><span class="line">    self.view = [UIView new];</span><br><span class="line">    self.view.backgroundColor = [UIColor colorWithWhite:0.1 alpha:1.0];</span><br><span class="line">    </span><br><span class="line">    [self.view addSubview:self.blueView];</span><br><span class="line">    [self.view addSubview:self.redView];</span><br><span class="line">    [self.view addSubview:self.yellowView];</span><br><span class="line">    [self.view addSubview:self.greenView];</span><br><span class="line">    [self.view setNeedsUpdateConstraints]; //  设置新的约束天剑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如果没有试图-那么就重新创建一个"><a href="#如果没有试图-那么就重新创建一个" class="headerlink" title="如果没有试图,那么就重新创建一个"></a>如果没有试图,那么就重新创建一个</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (UIView *)blueView</span><br><span class="line">&#123;</span><br><span class="line">    if (!_blueView) &#123;</span><br><span class="line">        _blueView = [UIView newAutoLayoutView];</span><br><span class="line">        _blueView.backgroundColor = [UIColor blueColor];</span><br><span class="line">    &#125;</span><br><span class="line">    return _blueView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIView *)redView</span><br><span class="line">&#123;</span><br><span class="line">    if (!_redView) &#123;</span><br><span class="line">        _redView = [UIView newAutoLayoutView];</span><br><span class="line">        _redView.backgroundColor = [UIColor redColor];</span><br><span class="line">    &#125;</span><br><span class="line">    return _redView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIView *)yellowView</span><br><span class="line">&#123;</span><br><span class="line">    if (!_yellowView) &#123;</span><br><span class="line">        _yellowView = [UIView newAutoLayoutView];</span><br><span class="line">        _yellowView.backgroundColor = [UIColor yellowColor];</span><br><span class="line">    &#125;</span><br><span class="line">    return _yellowView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIView *)greenView</span><br><span class="line">&#123;</span><br><span class="line">    if (!_greenView) &#123;</span><br><span class="line">        _greenView = [UIView newAutoLayoutView];</span><br><span class="line">        _greenView.backgroundColor = [UIColor greenColor];</span><br><span class="line">    &#125;</span><br><span class="line">    return _greenView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="然后再添加试图的约束条件"><a href="#然后再添加试图的约束条件" class="headerlink" title="然后再添加试图的约束条件"></a>然后再添加试图的约束条件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)updateViewConstraints   //更新约束条件</span><br><span class="line">&#123;</span><br><span class="line">   // 如果没有自动约束条件</span><br><span class="line">    if (!self.didSetupConstraints) &#123;</span><br><span class="line">        // Blue view is centered on screen,(Centers the view in its superview.) with size &#123;50 pt, 50 pt&#125;</span><br><span class="line"></span><br><span class="line">        //设置蓝色的 view 在父试图的中心, </span><br><span class="line">        [self.blueView autoCenterInSuperview];</span><br><span class="line">        //设置蓝色的 view 的宽和高(50.0 50.0)</span><br><span class="line">        [self.blueView autoSetDimensionsToSize:CGSizeMake(50.0, 50.0)];</span><br><span class="line">        </span><br><span class="line">        // Red view is positioned at the bottom right corner of the blue view, with the same width, and a height of 40 pt</span><br><span class="line">        // 设置红色 view 的顶部是蓝色 view 的底部</span><br><span class="line">        [self.redView autoPinEdge:ALEdgeTop toEdge:ALEdgeBottom ofView:self.blueView];</span><br><span class="line">        //设置红色 view 的左边是蓝色 view 的右边</span><br><span class="line">        [self.redView autoPinEdge:ALEdgeLeft toEdge:ALEdgeRight ofView:self.blueView];</span><br><span class="line">        //设置红色 view 的宽度就是蓝色 view 的宽度</span><br><span class="line">        [self.redView autoMatchDimension:ALDimensionWidth toDimension:ALDimensionWidth ofView:self.blueView];</span><br><span class="line">        //设置红色 view 的高度为40.0</span><br><span class="line">        [self.redView autoSetDimension:ALDimensionHeight toSize:40.0];</span><br><span class="line">        </span><br><span class="line">        // Yellow view is positioned 10 pt below the red view, extending across the screen with 20 pt insets from the edges,</span><br><span class="line">        // and with a fixed height of 25 pt</span><br><span class="line">        //设置黄色 veiw 的顶部距离红色 view 距离为10.0</span><br><span class="line">        [self.yellowView autoPinEdge:ALEdgeTop toEdge:ALEdgeBottom ofView:self.redView withOffset:10.0];</span><br><span class="line">        //设置黄色 view 的高度为25.0</span><br><span class="line">        [self.yellowView autoSetDimension:ALDimensionHeight toSize:25.0];</span><br><span class="line">        //设置黄色 view 距离父试图左边的距离为20.0</span><br><span class="line">        [self.yellowView autoPinEdgeToSuperviewEdge:ALEdgeLeft withInset:20.0];</span><br><span class="line">        //设置黄色 view 距离父试图右边的距离为20.0</span><br><span class="line">        [self.yellowView autoPinEdgeToSuperviewEdge:ALEdgeRight withInset:20.0];</span><br><span class="line">        </span><br><span class="line">        // Green view is positioned 10 pt below the yellow view, aligned to the vertical axis of its superview,</span><br><span class="line">        // with its height twice the height of the yellow view and its width fixed to 150 pt</span><br><span class="line">        //设置绿色 view 的顶部距离黄色 view 的底部距离为10.0</span><br><span class="line">        [self.greenView autoPinEdge:ALEdgeTop toEdge:ALEdgeBottom ofView:self.yellowView withOffset:10.0];</span><br><span class="line">        //设置绿色 view 相对父试图竖向居中</span><br><span class="line">        [self.greenView autoAlignAxisToSuperviewAxis:ALAxisVertical];</span><br><span class="line">        //设置绿色的 view 的高度是黄色 view 高度的2.0倍</span><br><span class="line">        [self.greenView autoMatchDimension:ALDimensionHeight toDimension:ALDimensionHeight ofView:self.yellowView withMultiplier:2.0];</span><br><span class="line">        //设置绿色 view 的宽度为150.0</span><br><span class="line">        [self.greenView autoSetDimension:ALDimensionWidth toSize:150.0];</span><br><span class="line">        </span><br><span class="line">        //设置已经添加过约束了</span><br><span class="line">        self.didSetupConstraints = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [super updateViewConstraints];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>github 地址:<a href="https://github.com/smileyborg/PureLayout#" target="_blank" rel="noopener">https://github.com/smileyborg/PureLayout#</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>自动布局</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 国际化</title>
    <url>/2015/05/25/internationalization/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog2.png?imageView2/1/w/600/h/200" />
<a id="more"></a>

<h2 id="国际化-vs-本地化"><a href="#国际化-vs-本地化" class="headerlink" title="国际化 vs 本地化"></a>国际化 vs 本地化</h2><p>（Internationalization vs Localization）</p>
<p>简单说，国际化是一个应用程序国际兼容性设计的过程，比如：</p>
<ol>
<li>以用户母语处理文本输入和输出；</li>
<li>处理不同的日期、时间以及数字格式；</li>
<li>利用适当的历法和时区处理数据；<br>国际化是一项你和开发者通过利用系统提供的API来实现的活动，并在代码上做一些补充和修改，从而让应用的中文版、阿拉伯语版本和英文版一样好。</li>
</ol>
<p>相比之下，本地化仅仅是把应用的用户界面和资源翻译成不同的语言，这是你可以也应该交给别人做的工作，除非你能精通app应该支持的每种语言。<br><code>使用本地国际化还有一个好处就是在你的程序中许多字符串命名都可以放在Localizable.strings中</code><br><code>在字符串命名的时候只需要调用一个 key 就可以进行赋值,这样可以方便集中管理字符串!</code></p>
<p>多语言在应用程序中一般有两种做法：</p>
<ul>
<li>程序中提供给用户自己选择的机会；</li>
<li>根据当前用户当前移动设备的语言自动将我们的app切换对应语言。</li>
</ul>
<p>第一种做法比较简单完全靠自己的发挥了，这里主要讲第二种做法，主要分一下几点：</p>
<ol>
<li>本地化应用程序名称</li>
<li>本地化字符串</li>
<li>本地化图片</li>
<li>本地化其他文件</li>
</ol>
<h2 id="本地化字符串"><a href="#本地化字符串" class="headerlink" title="本地化字符串"></a>本地化字符串</h2><ol>
<li>创建国际化语言文件：文件名必须为：Localizable.strings<br><code>这里如果不使用这个名字来命名,如果你使用的是自定义名字的.strings，比如MyApp.strings，</code><br><code>那么你在程序中可以这样获取字符串：NSLocalizedStringFromTable (@&quot;mykey&quot;,@&quot;MyApp&quot;, nil)</code><br><code>这样即可获取到&quot;myvalue&quot;这个字符串，可以是任何语言。</code><img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog4.png?imageView2/1/w/600/h/400" /></li>
<li>选中Localizable.strings文件，在Utilites中，点击Localizable选项<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog5.png?imageView2/1/w/600/h/400" /></li>
<li>创建English语言包。<br>创建后，你的Localizable.strings文件下将挂在英文的语言支持文件。<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog6.png?imageView2/1/w/600/h/400" /></li>
<li>根据需要添加其他多国语言支持。<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog3.png?imageView2/1/w/600/h/400" />

</li>
</ol>
<p><strong><em>添加语言支持。</em></strong><br>我们以我的文件为例：<br>在Localizable.strings(Chinese(Simplified))中，加入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;play&quot;=&quot;播放&quot;;</span><br></pre></td></tr></table></figure>

<p>在Localizable.strings(English)中，加入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;play&quot;=&quot;play&quot;;</span><br></pre></td></tr></table></figure>

<p><strong><em>使用语言支持</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self.textButton setTitle:NSLocalizedString(@&quot;play&quot;,@&quot;&quot;) forState:UIControlStateNormal];</span><br></pre></td></tr></table></figure>

<p><strong><em>获得当前设备的语言</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 取得用户默认信息</span><br><span class="line">    NSUserDefaults *defaults = [ NSUserDefaults standardUserDefaults ];</span><br><span class="line">// 取得 iPhone 支持的所有语言设置</span><br><span class="line">NSArray *languages = [defaults objectForKey : @&quot;AppleLanguages&quot; ];</span><br><span class="line">NSLog (@&quot;%@&quot;, languages);</span><br><span class="line">    </span><br><span class="line">// 获得当前iPhone使用的语言</span><br><span class="line">NSString* currentLanguage = [languages objectAtIndex:0];</span><br><span class="line">NSLog(@&quot;当前使用的语言：%@&quot;,currentLanguage);</span><br></pre></td></tr></table></figure>

<h2 id="本地化应用程序名称"><a href="#本地化应用程序名称" class="headerlink" title="本地化应用程序名称"></a>本地化应用程序名称</h2><ol>
<li>点击“new file”然后在弹出窗口左侧选择IOS的resource项，在右侧就可以看到“String File”的图标。创建这个文件，命名为“InfoPlist”（一定是这个文件名） 就生成一个InfoPlist.strings文件；</li>
<li>选中InfoPlist.strings 点击 XCode-&gt; View-&gt; Utilities -&gt; File Inspector,在Localization中点“+”，添加chinese （zh－Hans）类型的为简体中文，english 应该会自动添加上。然后在InfoPlish.strings 左边会多出一个三角形，点击展开后可以看到InfoPlish.strings(english)和InfoPlish.strings(chinese)两个版本的文件；</li>
<li>在InfoPlish.strings(english)文件中加入： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其中“Program”为英文应用程序名称，同理在InfoPlish.strings(chinese)文件中加入：</span><br><span class="line">    ```CFBundleDisplayName =&quot;应用程序&quot;;</span><br></pre></td></tr></table></figure>
<code>其中“应用程序”为中文名称，注意：CFBundleDisplayName加不加双引号都行</code></li>
<li>编辑Info.plist，添加一个新的属性Application has localized display name, 设置其类型为boolean，并将其value设置为YES即可</li>
</ol>
<h2 id="本地化图片"><a href="#本地化图片" class="headerlink" title="本地化图片"></a>本地化图片</h2><p>这里又分两种方法，第一种和本地化字符串方法类似，把中英文图片的名字分别存到中英文对应的strings文件，然后通过NSLocalizedString)来获取图片名称，如：</p>
<p>Localizable.strings(english)文件中加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;BtnCancel&quot;=&quot;BtnCancelEn.png&quot;;</span><br></pre></td></tr></table></figure>

<p>Localizable.strings(chinese)文件中加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;BtnCancel&quot;=&quot;BtnCancelCn.png&quot;;</span><br></pre></td></tr></table></figure>

<p>然后在代码中使用NSLocalizedString)来获取图片名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CCSprite *btnCancel = [CCSprite spriteWithSpriteFrameName:NSLocalizedString(@&quot;BtnCancel&quot;, nil)];  </span><br><span class="line">btnCancel.position=ccp(s.width/2,s.height/2-40);  </span><br><span class="line">[self addChild:btnCancel z:2 tag:104];</span><br></pre></td></tr></table></figure>

<p>第二种就比较正规化了：点中你要本地化的图片，如<code>icon.png</code>，然后XCode-&gt; View-&gt; Utilities -&gt; File Inspector，在<code>Localization</code>中点“+”添加chinese （zh－Hans）；在图片左边就会出现一个倒三角，点开就会出现（english）和（chinese）的2张图，并且在项目文件夹中会出现en.lproj文件和zh-Hans.lproj文件；en.lproj文件存放的是英文版图片，zh-Hans.lproj存放的是中文版图片，中英文图片名字一样，<code>我们在文件夹中直接替换图片就可以了</code>，最后使用时直接使用正常名字就行了，如：“icon.png”。</p>
<h2 id="本地化其他文件"><a href="#本地化其他文件" class="headerlink" title="本地化其他文件"></a>本地化其他文件</h2><p>本地化其他文件和本地化图片第二种方法类似，先在Localization中添加语言，然后把对应版本拷贝到en.lproj和zh-Hans.lproj文件夹中，最后引用就行了。</p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>国际化</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 中的多线程</title>
    <url>/2015/05/22/performAND-dispatch/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogdispatch.png?imageView2/1/w/600/h/200" />
<a id="more"></a>
## 为什么要使用多线程
1. 好事的操作使用线程, 提高应用程序响应.
2. 并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求。
3. 多CPU系统中，使用线程提高CPU利用率
4. 改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。

<ul>
<li>使用多线程的理由之一是和进程相比，它是一种非常<code>花销小，切换快</code>，更”节俭”的多任务操作方式。在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，<code>启动一个线程所花费的空间远远小于启动一个进程所花费的空间</code>，而且，<code>线程间彼此切换所需的时间也远远小于进程间切换所需要的时间</code>。</li>
<li>使用多线程的理由之二是线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便。当然，数据的共享也带来其他一些问题，有的变量不能同时被两个线程所修改，有的子程序中声明为static的数据更有可能给多线程程序带来灾难性的打击，这些正是编写多线程程序时最需要注意的地方。<br><strong><em>除了以上所说的优点外，不和进程比较，多线程程序作为一种多任务、并发的工作方式，当然有以下的优点：</em></strong></li>
</ul>
<ol>
<li><code>提高应用程序响应</code>。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time consuming）置于一个新的线程，可以避免这种尴尬的情况。</li>
<li><code>多CPU系统更加有效</code>。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</li>
<li><code>改善程序结构</code>一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。 </li>
</ol>
<h2 id="理解的线程"><a href="#理解的线程" class="headerlink" title="理解的线程"></a>理解的线程</h2><ul>
<li>要讲解线程，不得不说一下进程，<code>进程是应用程序的执行实例</code>，每个进程是由私有的虚拟地址空间、代码、数据和其它系统资源组成。进程在运行时创建的资源随着进程的终止而死亡。线程的基本思想很简单，它是一个独立的执行流，是进程内部的一个独立的执行单元，相当于一个子程序，它对应Visual C++中的CwinThread类的对象。单独一个执行程序运行时，缺省的运行包含的一个主线程，主线程以函数地址的形式，如main或WinMain函数，提供程序的启动点，当主线程终止时，进程也随之终止，但根据需要，<code>应用程序又可以分解成许多独立执行的线程,每个线程并行的运行在同一进程中</code>。 </li>
<li><code>一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。</code>操作系统给每个线程分配不同的CPU时间片，在某一个时刻，CPU只执行一个时间片内的线程，多个时间片中的相应线程在CPU内轮流执行，由于每个时间片时间很短，所以对用户来说，仿佛各个线程在计算机中是并行处理的。操作系统是根据线程的优先级来安排CPU的时间，优先级高的线程优先运行，优先级低的线程则继续等待。</li>
<li>线程被分为两种：<code>用户界面线程</code>和<code>工作线程（又称为后台线程）</code>。用户界面线程通常用来处理用户的输入并响应各种事件和消息，其实，应用程序的主执行线程CWinAPP对象就是一个用户界面线程，当应用程序启动时自动创建和启动，同样它的终止也意味着该程序的结束，进城终止。工作者线程用来执行程序的后台处理任务，比如计算、调度、对串口的读写操作等，它和用户界面线程的区别是它不用从CwinThread类派生来创建，对它来说最重要的是如何实现工作线程任务的运行控制函数。工作线程和用户界面线程启动时要调用同一个函数的不同版本；最后需要读者明白的是，一个进程中的所有线程共享它们父进程的变量，但同时每个线程可以拥有自己的变量。</li>
</ul>
<h2 id="多线程和异步操作"><a href="#多线程和异步操作" class="headerlink" title="多线程和异步操作"></a>多线程和异步操作</h2><ul>
<li>多线程和异步操作两者都可以达到避免调用线程阻塞的目的，从而提高软件的可响应性。甚至有些时候我们就认为多线程和异步操作是等同的概念。但是，多线程和异步操作还是有一些区别的。而这些区别造成了使用多线程和异步操作的时机的区别。<br><strong><em>异步操作的本质</em></strong><br>所有的程序最终都会由计算机硬件来执行，所以为了更好的理解异步操作的本质，我们有必要了解一下它的硬件基础。 熟悉电脑硬件的朋友肯定对DMA这个词不陌生，硬盘、光驱的技术规格中都有明确DMA的模式指标，其实网卡、声卡、显卡也是有DMA功能的。DMA就是直接内存访问的意思，也就是说，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。只要CPU在发起数据传输时发送一个指令，硬件就开始自己和内存交换数据，在传输完成之后硬件会触发一个中断来通知操作完成。这些无须消耗CPU时间的I/O操作正是异步操作的硬件基础。所以即使在DOS这样的单进程（而且无线程概念）系统中也同样可以发起异步的DMA操作。<br><strong><em>线程的本质</em></strong><br>线程不是一个计算机硬件的功能，而是<code>操作系统提供的一种逻辑功能</code>线程本质上是进程中一段并发运行的代码，所以线程需要操作系统投入CPU资源来运行和调度<br><strong><em>异步操作的优缺点</em></strong><br>因为异步操作无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必使用共享变量（即使无法完全不用，最起码可以减少共享变量的数量），减少了死锁的可能。当然异步操作也并非完美无暇。编写异步操作的复杂程度较高，程序主要使用回调方式进行处理，与普通人的思维方式有些初入，而且难以调试。<br><strong><em>多线程的优缺点</em></strong><br>多线程的优点很明显，线程中的处理程序依然是顺序执行，符合普通人的思维习惯，所以编程简单。但是多线程的缺点也同样明显，线程的使用（滥用）会给系统带来上下文切换的额外负担。并且线程间的共享变量可能造成死锁的出现。<br><strong><em>使用范围</em></strong></li>
<li>在了解了线程与异步操作各自的优缺点之后，我们可以来探讨一下线程和异步的合理用途。我认为：<code>当需要执行I/O操作时，使用异步操作比使用线程+同步I/O操作更合适</code>。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.net Remoting等跨进程的调用。</li>
<li>而<code>线程的适用范围则是那种需要长时间CPU运算的场合</code>，例如耗时较长的图形处理和算法执行。但是往往由于使用线程编程的简单和符合习惯，所以很多朋友往往会使用线程来执行耗时较长的I/O操作。这样在只有少数几个并发操作的时候还无伤大雅，如果需要处理大量的并发操作时就不合适了。</li>
</ul>
<h2 id="iOS-中的多线程"><a href="#iOS-中的多线程" class="headerlink" title="iOS 中的多线程"></a>iOS 中的多线程</h2><ul>
<li>多线程是一个比较轻量级的方法来实现单个应用程序内多个代码执行路径,在系统级别内，程序并排执行，程序分配到每个程序的执行时间是基于该程序的所需时间和其他程序的所需时间来决定的。</li>
<li>然而，在每个程序内部，存在一个或者多个执行线程，它同时或在一个几乎同时发生的方式里执行不同的任务。</li>
<li><strong>概要提示：*</strong><br>iPhone中的线程应用并不是无节制的，官方给出的资料显示，iPhone OS下的主线程的堆栈大小是1M，第二个线程开始就是512KB，并且该值不能通过编译器开关或线程API函数来更改，只有主线程有直接修改UI的能力</li>
<li><strong>线程概述:*</strong></li>
<li>有些程序是一条直线，起点到终点——如简单的hello world，运行打印完，它的生命周期便结束了，像是昙花一现。有些程序是一个圆，不断循环直到将它切断——如操作系统，一直运行直到你关机。</li>
<li>一个运行着的程序就是一个进程或者叫做一个任务，一个进程至少包含一个线程，线程就是程序的执行流。Mac和IOS中的程序启动，创建好一个进程的同时，一个线程便开始运作，这个线程叫做主线程。主线成在程序中的位置和其他线程不同，它是其他线程最终的父线程，且所有的界面的显示操作即AppKit或UIKit的操作必须在主线程进行。</li>
<li>系统中每一个进程都有自己独立的虚拟内存空间，而同一个进程中的多个线程则公用进程的内存空间。<br>每创建一个新的进成，都需要一些内存（如每个线程有自己的stack空间）和消耗一定的CPU时间。</li>
<li>当多个进成对同一个资源出现争夺的时候需要注意线程安全问题</li>
<li><strong>多线程的优势:*</strong></li>
</ul>
<ol>
<li>充分发挥多核处理器优势,将不同线程任务分配给不同的处理器,真正进入”并行运算”状态;</li>
<li>将耗时的任务分配到其他线程执行,由主线程负责统一更新界面会使应用程序更加流畅,用户体验更好;</li>
<li>当硬件处理器的数量增加,程序会运行更快,而程序无需做任何调整.</li>
</ol>
<p><strong><em>弊端</em></strong><br>新建线程会消耗内存空间和CPU时间,线程太多会降低系统的运行性能.</p>
<h2 id="iOS的三种多线程"><a href="#iOS的三种多线程" class="headerlink" title="iOS的三种多线程"></a>iOS的三种多线程</h2><ol>
<li><strong><em>NSThread:</em></strong></li>
</ol>
<ul>
<li>使用NSThread对象建立一个线程非常方便;</li>
<li>但是!要使用NSThread管理多个线程非常困难,不推荐使用;</li>
<li>技巧!使用[NSThread currentThread]跟踪任务所在线程,适用于这三种技术.  </li>
</ul>
<ol start="2">
<li><strong><em>NSOperation/NSOperationQueue:</em></strong></li>
</ol>
<ul>
<li>是使用GCD实现的一套Objective-C的API;</li>
<li>是面向对象的多线程技术;</li>
<li>提供了一些在GCD中不容易实现的特性,如:限制最大并发数量,操作之间的依赖关系.</li>
</ul>
<ol start="3">
<li><strong><em>GCD—Grand Central Dispatch:</em></strong></li>
</ol>
<ul>
<li>是基于C语言的底层API;</li>
<li>用Block定义任务,使用起来非常灵活便捷;</li>
<li>提供了更多的控制能力以及操作队列中所不能使用的底层函数.</li>
</ul>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>NSThree是官方推荐的线程处理方式，它在处理机制上，需要开发者负责手动管理Thread的生命周期，包括子线程与主线程之间的同步等。线程共享同一应用程序的部分内存空间，它们拥有对数据相同的访问权限。你得协调多个线程 对同一数据的访问，一般做法是在访问之前加锁，这会导致一定的性能开销。<br><strong><em>使用步骤</em></strong></p>
<ol>
<li>声明一个NSCondition同步锁;</li>
<li>声明若干个NSThread子线程;</li>
<li>指定NSThread子线程的目标指行方法（可以在构造函数中指定）;</li>
<li>设置子线程的名称;</li>
<li>star启动子线程。<br>其中，子线程的执行方法一般只需要一个共同方法即可（可以通过线程名，分辨当前的执行线程）。下面通过代码演示NSThread类的使用。假设我们需要下载网络图片，在非异步形式的情况下，IOS界面必须等到图片下载完毕后，UI才会反应。这时利用多线程就可以达到异步下载的效果。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface ViewController1 : UIViewController&#123;</span><br><span class="line">    NSCondition *_condition;</span><br><span class="line">    NSThread *_thread_1;</span><br><span class="line">    NSThread *_thread_2;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface ViewController1 ()</span><br><span class="line">@end</span><br><span class="line">@implementation ViewController1</span><br><span class="line">- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil</span><br><span class="line">&#123;</span><br><span class="line">    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // Custom initialization</span><br><span class="line">        self.title=@&quot;多线程NSThread&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];                       </span><br><span class="line">    //创建一个进程锁，实现线程同步</span><br><span class="line">    _condition=[[NSCondition alloc] init];                </span><br><span class="line">    //创建线程1</span><br><span class="line">    _thread_1=[[NSThread alloc]initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">    [_thread_1 setName:@&quot;thread_1&quot;];</span><br><span class="line">    [_thread_1 start];                                                                                                             </span><br><span class="line">    //创建线程2</span><br><span class="line">    _thread_2=[[NSThread alloc]initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">    [_thread_2 setName:@&quot;thread_2&quot;];</span><br><span class="line">    [_thread_2 start];                                                                                                           </span><br><span class="line">&#125;</span><br><span class="line">#pragma mark--线程执行方法</span><br><span class="line">-(void)run&#123;</span><br><span class="line">    //进程上锁</span><br><span class="line">    [_condition lock];</span><br><span class="line">    NSLog(@&quot;运行的线程名：%@&quot;,[[NSThread currentThread]name]);</span><br><span class="line">    if ([[[NSThread currentThread]name] isEqualToString:@&quot;thread_1&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;111&quot;);</span><br><span class="line">        NSURL *imageUrl_1=[NSURL URLWithString:@&quot;http://t.beauty-soft.net/upload/ceiba20130224_014522_8679.jpg&quot;];</span><br><span class="line">        NSData *data_1=[NSData dataWithContentsOfURL:imageUrl_1];</span><br><span class="line">        UIImage *image_1=[UIImage imageWithData:data_1];</span><br><span class="line">        UIImageView *imageView_1=[[UIImageView alloc] initWithImage:image_1];</span><br><span class="line">        imageView_1.frame=CGRectMake(60, 20, 200, 200);</span><br><span class="line">        [self.view addSubview:imageView_1];</span><br><span class="line">        [imageView_1 release];                </span><br><span class="line">    &#125;else if([[[NSThread currentThread]name] isEqualToString:@&quot;thread_2&quot;])&#123;</span><br><span class="line">        NSLog(@&quot;222&quot;);                                                                                                           </span><br><span class="line">        NSURL *imageUrl_2=[NSURL URLWithString:@&quot;http://t.beauty-soft.net/upload/ceiba20120704_121437_3455.jpg&quot;];    </span><br><span class="line">        NSData *data_2=[NSData dataWithContentsOfURL:imageUrl_2];</span><br><span class="line">        UIImage *image_2=[UIImage imageWithData:data_2];</span><br><span class="line">        UIImageView *imageView_2=[[UIImageView alloc] initWithImage:image_2];</span><br><span class="line">        imageView_2.frame=CGRectMake(60, 250, 200, 200);</span><br><span class="line">        [self.view addSubview:imageView_2];</span><br><span class="line">        [imageView_2 release];</span><br><span class="line">    &#125;</span><br><span class="line">    //解锁</span><br><span class="line">    [_condition unlock];                                                                                                         </span><br><span class="line">&#125;</span><br><span class="line">-(void)dealloc&#123;</span><br><span class="line">    [_thread_1 release];</span><br><span class="line">    [_thread_2 release];</span><br><span class="line">    [_condition release];</span><br><span class="line">    [super dealloc];</span><br><span class="line">&#125;</span><br><span class="line">- (void)didReceiveMemoryWarning</span><br><span class="line">&#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">    // Dispose of any resources that can be recreated.</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h3 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h3><p>如果需要让线程同时并行运行多个，<code>可以将线程加入队列（Queue）中</code>，NSOperationQueue类就是一个<code>线程队列管理类</code>，他提供了线程并行、队列的管理。可以认为NSOperationQueue就是一个线程管理器，通过addOperations方法，我们可以一次性把多个（数组形式）线程添加到队列中。同时，NSOperationQueue允许通过setMaxConcurrentOperationCount方法设置队列的并行（同一时间）运行数量。<br><strong><em>使用步骤</em></strong></p>
<ol>
<li>声明一个NSOperationQueue对象;</li>
<li>声明若干个NSInvocationOperation子线程对象，并指定回调方法;</li>
<li>将NSInvocationOperation子线程添加到数组;</li>
<li>把数组赋给NSOperationQueue类中的addOperations方法;</li>
<li>实现回调方法;</li>
<li>在回调方法中实现performSelectorOnMainThread方法，更新主线程上的界面UI元素。</li>
</ol>
<p>下面，使用NSOperationQueue类，实现前面NSThread类相同的功能（即下载图片）。代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;ViewController2.h&quot;</span><br><span class="line">@interface ViewController2 ()</span><br><span class="line">@end</span><br><span class="line">@implementation ViewController2</span><br><span class="line">- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil</span><br><span class="line">&#123;</span><br><span class="line">    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // Custom initialization</span><br><span class="line">        self.title=@&quot;线程队列&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // 线程队列管理器，实现线程并行运行</span><br><span class="line">    _opeartionQueue=[[NSOperationQueue alloc] init];</span><br><span class="line">    //队列最大同时运行数量</span><br><span class="line">    [_opeartionQueue setMaxConcurrentOperationCount:1];</span><br><span class="line"></span><br><span class="line">    tags=20;</span><br><span class="line">    //创建线程1</span><br><span class="line">    NSInvocationOperation *invocationOpearation_1=[[[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run:) object:@&quot;http://t.beauty-soft.net/upload/ceiba20130224_014522_8679.jpg&quot;] autorelease];</span><br><span class="line">    //创建线程2</span><br><span class="line">    NSInvocationOperation *invocationOpearation_2=[[[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run:) object:@&quot;http://t.beauty-soft.net/upload/ceiba20120704_121437_3455.jpg&quot;] autorelease];</span><br><span class="line">                                                                                                                                                           </span><br><span class="line">    NSArray *array=@[invocationOpearation_1,invocationOpearation_2];</span><br><span class="line">    //把程序添加到管理器中</span><br><span class="line">    [_opeartionQueue addOperations:array waitUntilFinished:YES];</span><br><span class="line">&#125;</span><br><span class="line">-(void)run:(NSString *)imageStrinUrl&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[_opeartionQueue operations]);</span><br><span class="line">    NSLog(@&quot;mainQueue%@&quot;,[NSOperationQueue mainQueue]);</span><br><span class="line">    NSLog(@&quot;i==%i&quot;,tags);</span><br><span class="line">    NSLog(@&quot;urlStr：%@&quot;,imageStrinUrl);</span><br><span class="line">    NSURL *url=[NSURL URLWithString:imageStrinUrl];</span><br><span class="line">    NSData *data=[NSData dataWithContentsOfURL:url];</span><br><span class="line">    UIImage *image=[UIImage imageWithData:data];</span><br><span class="line">    UIImageView *imageView=[[[UIImageView alloc] initWithImage:image]autorelease];</span><br><span class="line">    imageView.frame=CGRectMake(60, tags, 200, 200);</span><br><span class="line">    tags+=200;</span><br><span class="line">    //通知主线程更新UI</span><br><span class="line">    [self performSelectorOnMainThread:@selector(updateUI:) withObject:imageView waitUntilDone:NO];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-(void)updateUI:(UIImageView *)imageView&#123;</span><br><span class="line">    [self.view addSubview:imageView];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [_opeartionQueue release];</span><br><span class="line">    [super dealloc];</span><br><span class="line">&#125;</span><br><span class="line">- (void)didReceiveMemoryWarning</span><br><span class="line">&#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">    // Dispose of any resources that can be recreated.</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>说到这里, 就不得不提一下这个 <strong><em>performSelector</em></strong> 了,么我们简单的介绍一下他的几种用法<br><strong><em>performSelector</em></strong><br>API是这么解释的 <code>Sends a specified message to the receiver and returns the result of the message.</code> </p>
<ul>
<li><strong>(id)performSelector:(SEL)aSelector</strong><br>API 解释:<code>A selector identifying the message to send. If aSelector is NULL, an NSInvalidArgumentException is raised.</code></li>
<li><strong>(id)performSelector:(SEL)aSelector withObject:(id)anObject</strong><br>API 解释:<code>Sends a message to the receiver with an object as the argument.</code></li>
<li><strong>(id)performSelector:(SEL)aSelector withObject:(id)anObject withObject:(id)anotherObject</strong><br>API 解释:<code>Sends a message to the receiver with two objects as arguments</code></li>
<li><strong>(void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay</strong><br>API 解释:<code>Invokes a method of the receiver on the current thread using the default mode after a delay.</code> <code>常用的延迟执行的方法</code></li>
<li><strong>(void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay</strong><br>API 解释:<code>Invokes a method of the receiver on the current thread using the default mode after a delay.</code></li>
<li><strong>(void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray *)modes</strong><br>API 解释:<code>Invokes a method of the receiver on the current thread using the specified modes after a delay.</code></li>
<li><strong>(void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg</strong><br>API 解释:<code>Invokes a method of the receiver on a new background thread.</code></li>
<li><strong>(void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait</strong><br>API 解释:<code>Invokes a method of the receiver on the main thread using the default mode.</code></li>
</ul>
<h3 id="GCD-Grand-Central-Dispatch"><a href="#GCD-Grand-Central-Dispatch" class="headerlink" title="GCD(Grand Central Dispatch)"></a>GCD(Grand Central Dispatch)</h3><p>这里转载于<a href="http://www.dreamingwish.com/article/gcd%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8Cdispatch-queue.html" target="_blank" rel="noopener">Dreamingwish</a></p>
<ul>
<li>Grand Central Dispatch或者GCD，是一套低层API，提供了一种新的方法来进行并发程序编写。从基本功能上讲，GCD有点像NSOperationQueue，他们都允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。</li>
<li>除了代码的平行执行能力，GCD还提供高度集成的事件控制系统。可以设置句柄来响应文件描述符、mach ports（Mach port 用于 OS X上的进程间通讯）、进程、计时器、信号、用户生成事件。这些句柄通过GCD来并发执行。</li>
<li>GCD的API很大程度上基于block，当然，GCD也可以脱离block来使用，比如使用传统c机制提供函数指针和上下文指针。实践证明，当配合block使用时，GCD非常简单易用且能发挥其最大能力。</li>
</ul>
<p><strong><em>为何使用 GCD</em></strong></p>
<ol>
<li>易用: GCD比之thread跟简单易用。由于GCD基于work unit而非像thread那样基于运算，所以GCD可以控制诸如等待任务结束、监视文件描述符、周期执行代码以及工作挂起等任务。基于block的血统导致它能极为简单得在不同代码作用域之间传递上下文。</li>
<li>效率: GCD被实现得如此轻量和优雅，使得它在很多地方比之专门创建消耗资源的线程更实用且快速。这关系到易用性：导致GCD易用的原因有一部分在于你可以不用担心太多的效率问题而仅仅使用它就行了。</li>
<li>性能: GCD自动根据系统负载来增减线程数量，这就减少了上下文切换以及增加了计算效率。</li>
</ol>
<p><strong><em>GCD中有三种队列类型：</em></strong></p>
<ol>
<li>The main queue: 与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。main queue可以调用dispatch_get_main_queue()来获得。因为main queue是与主线程相关的，所以这是一个串行队列。</li>
<li>Global queues: 全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。可以调用dispatch_get_global_queue函数传入优先级来访问队列。</li>
<li>用户队列: 用户队列 (GCD并不这样称呼这种队列, 但是没有一个特定的名字来形容这种队列，所以我们称其为用户队列) 是用函数 dispatch_queue_create 创建的队列. 这些队列是串行的。正因为如此，它们可以用来完成同步机制, 有点像传统线程中的mutex。</li>
</ol>
<p>下面转载于<a href="http://blog.devtang.com/blog/2012/02/22/use-gcd/" target="_blank" rel="noopener">唐巧的技术博客</a><br><strong><em>系统提供的dispatch方法</em></strong><br>为了方便地使用GCD，苹果提供了一些方法方便我们将block放在主线程 或 后台线程执行，或者延后执行。使用的例子如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/  后台执行：</span><br><span class="line"> dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">      // something</span><br><span class="line"> &#125;);</span><br><span class="line"> // 主线程执行：</span><br><span class="line"> dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      // something</span><br><span class="line"> &#125;);</span><br><span class="line"> // 一次性执行：</span><br><span class="line"> static dispatch_once_t onceToken;</span><br><span class="line"> dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">     // code to be executed once</span><br><span class="line"> &#125;);</span><br><span class="line"> // 延迟2秒执行：</span><br><span class="line"> double delayInSeconds = 2.0;</span><br><span class="line"> dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, delayInSeconds * NSEC_PER_SEC);</span><br><span class="line"> dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123;</span><br><span class="line">     // code to be executed on the main queue after delay</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>dispatch_queue_t 也可以自己定义，如要要自定义queue，可以用dispatch_queue_create方法，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t urls_queue = dispatch_queue_create(&quot;blog.devtang.com&quot;, NULL);</span><br><span class="line">dispatch_async(urls_queue, ^&#123;</span><br><span class="line">     // your code</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_release(urls_queue);</span><br></pre></td></tr></table></figure>

<p>另外，GCD还有一些高级用法，例如让后台2个线程并行执行，然后等2个线程都结束后，再汇总执行结果。这个可以用<code>dispatch_group</code>, <code>dispatch_group_async</code> 和 <code>dispatch_group_notify</code>来实现，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"> dispatch_group_async(group, dispatch_get_global_queue(0,0), ^&#123;</span><br><span class="line">      // 并行执行的线程一</span><br><span class="line"> &#125;);</span><br><span class="line"> dispatch_group_async(group, dispatch_get_global_queue(0,0), ^&#123;</span><br><span class="line">      // 并行执行的线程二</span><br><span class="line"> &#125;);</span><br><span class="line"> dispatch_group_notify(group, dispatch_get_global_queue(0,0), ^&#123;</span><br><span class="line">      // 汇总结果</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p><strong><em>修改block之外的变量</em></strong><br>默认情况下，在程序块中访问的外部变量是复制过去的，即写操作不对原变量生效。但是你可以加上 __block来让其写操作生效，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__block int a = 0;</span><br><span class="line">void  (^foo)(void) = ^&#123;</span><br><span class="line">     a = 1;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">// 这里，a的值被修改为1</span><br></pre></td></tr></table></figure>

<p><strong><em>后台执行</em></strong><br>使用block的另一个用处是可以让程序在后台较长久的运行。在以前，当app被按home键退出后，app仅有最多5秒钟的时候做一些保存或清理资源的工作。但是应用可以调用UIApplication的<code>beginBackgroundTaskWithExpirationHandler</code>方法，让app最多有10分钟的时间在后台长久运行。这个时间可以用来做清理本地缓存，发送统计数据等工作。</p>
<p>让程序在后台长久运行的示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// AppDelegate.h文件</span><br><span class="line">@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundUpdateTask;</span><br><span class="line"></span><br><span class="line">// AppDelegate.m文件</span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [self beingBackgroundUpdateTask];</span><br><span class="line">    // 在这里加上你需要长久运行的代码</span><br><span class="line">    [self endBackgroundUpdateTask];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)beingBackgroundUpdateTask</span><br><span class="line">&#123;</span><br><span class="line">    self.backgroundUpdateTask = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        [self endBackgroundUpdateTask];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)endBackgroundUpdateTask</span><br><span class="line">&#123;</span><br><span class="line">    [[UIApplication sharedApplication] endBackgroundTask: self.backgroundUpdateTask];</span><br><span class="line">    self.backgroundUpdateTask = UIBackgroundTaskInvalid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里感谢<a href="http://www.dreamingwish.com/article/gcd%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8Cdispatch-queue.html" target="_blank" rel="noopener">Dreamingwish</a>  , <a href="http://blog.devtang.com/blog/2012/02/22/use-gcd/" target="_blank" rel="noopener">唐巧的技术博客</a><br><strong><em>performSelector: 和dispatch_time的不同</em></strong></p>
<ul>
<li><p>iOS中timer相关的延时调用，常见的有NSObject中的performSelector:withObject:afterDelay:这个方法在调用的时候会设置当前runloop中timer，还有一种延时，直接使用NSTimer来配置任务。</p>
</li>
<li><p>这两种方式都一个共同的前提，就是当前线程里面需要有一个运行的runloop并且这个runloop里面有一个timer。</p>
</li>
<li><p>我们知道：只有主线程会在创建的时候默认自动运行一个runloop，并且有timer，普通的子线程是没有这些的。这样就带来一个问题了，有些时候我们并不确定我们的模块是不是会异步调用到，而我们在写这样的延时调用的时候一般都不会去检查运行时的环境，这样在子线程中被调用的时候，我们的代码中的延时调用的代码就会一直等待timer的调度，但是实际上在子线程中又没有这样的timer，这样我们的代码就永远不会被调到。</p>
</li>
<li><p>在有多线程操作的环境中，这样performSelector的延时调用，其实是缺乏安全性的。而且如果做延时,延迟的时间因为ronloop的原因延时时间可能不受控制,我们可以用另一套方案来解决这个问题，就是使用GCD中的dispatch_after来实现单次的延时调用</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>UITableView 的优化</title>
    <url>/2015/05/21/iOS-optimizedTableView/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog26D561AB-5CDE-44A4-A692-C371B19AFAA4.png?imageView2/1/w/600/h/200" />
<a id="more"></a>

<h2 id="UITableView-原理"><a href="#UITableView-原理" class="headerlink" title="UITableView 原理"></a>UITableView 原理</h2><ul>
<li>UITableView是UIScrollView的子类，因此它可以自动响应滚动事件（一般为上下滚动）。</li>
<li>它内部包含0到多个UITableViewCell对象，每个table cell展示各自的内容。当新cell需要被显示时，就会调用tableView:cellForRowAtIndexPath:方法来获取或创建一个cell；而不可视时，它又会被释放。由此可见，同一时间其实只需要存在一屏幕的cell对象即可，不需要为每一行创建一个cell。</li>
<li>此外，UITableView还可以分为多个sections，每个区段都可以有自己的head、foot和cells。而在定位一个cell时，就需要2个字段了：在哪个section，以及在这个section的第几行。这在iOS SDK中是用NSIndexPath来表述的，UIKit为其添加了indexPathForRow:inSection:这个创建方法。</li>
</ul>
<h2 id="UITableView-的简单的优化"><a href="#UITableView-的简单的优化" class="headerlink" title="UITableView 的简单的优化"></a>UITableView 的简单的优化</h2><ol>
<li>使用不透明视图<br>不透明的视图可以极大地提高渲染的速度。因此如非必要，可以将table cell及其子视图的opaque属性设为YES（默认值）。<br>其中的特例包括背景色，它的alpha值应该为1（例如不要使用clearColor）；图像的alpha值也应该为1，或者在画图时设为不透明。</li>
<li>不要重复创建不必要的table cell<br>前面说了，UITableView只需要一屏幕的UITableViewCell对象即可。因此在cell不可见时，可以将其缓存起来，而在需要时继续使用它即可。<br>而UITableView也提供了这种机制，只需要简单地设置一个identifier即可：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">static NSString *CellIdentifier = @<span class="string">"xxx"</span>;</span><br><span class="line">UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];</span><br><span class="line"><span class="keyword">if</span> (cell == nil) &#123;</span><br><span class="line">cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>不要做多余的绘制工作。<br>在实现drawRect:的时候，它的rect参数就是需要绘制的区域，这个区域之外的不需要进行绘制。<br>例如上例中，就可以用CGRectIntersectsRect、CGRectIntersection或CGRectContainsRect判断是否需要绘制image和text，然后再调用绘制方法。<h2 id="优化UITableViewCell高度计算的那些事"><a href="#优化UITableViewCell高度计算的那些事" class="headerlink" title="优化UITableViewCell高度计算的那些事"></a>优化UITableViewCell高度计算的那些事</h2>下面是转载于 <a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">BLOG: SUNNYXX – 优化UITableViewCell高度计算的那些事</a><br>他们也在维护一个开源的扩展，UITableView+FDTemplateLayoutCell，让高度计算这个事情变的前所未有的简单，也受到了很多星星的支持，<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">github链接请戳我</a></li>
</ol>
<h3 id="UITableViewCell高度计算"><a href="#UITableViewCell高度计算" class="headerlink" title="UITableViewCell高度计算"></a>UITableViewCell高度计算</h3><p><strong><strong>rowHeight</strong></strong></p>
<p><code>UITableView</code>是我们再熟悉不过的视图了，它的 delegate 和 data source 回调不知写了多少次，也不免遇到 UITableViewCell 高度计算的事。UITableView 询问 cell 高度有两种方式。<br>一种是针对所有 Cell 具有固定高度的情况，通过：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">self.tableView.rowHeight = 88;</span><br></pre></td></tr></table></figure>
<p>上面的代码指定了一个所有 cell 都是 88 高度的 UITableView，对于定高需求的表格，强烈建议使用这种（而非下面的）方式保证不必要的高度计算和调用。rowHeight属性的默认值是 44，所以一个空的 UITableView 显示成那个样子。</p>
<p>另一种方式就是实现 <code>UITableViewDelegate</code> 中的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">     <span class="built_in">return</span> 88;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，实现了这个方法后，<code>rowHeight</code> 的设置将无效。所以，这个方法适用于具有多种 cell 高度的 UITableView。</p>
<p><strong><strong>estimatedRowHeight</strong></strong><br>这个属性 iOS7 就出现了， 文档是这么描述它的作用的：</p>
<blockquote>
<p>If the table contains variable height rows, it might be expensive to calculate all their heights when the table loads. Using estimation allows you to defer some of the cost of geometry calculation from load time to scrolling time.</p>
</blockquote>
<p>恩，听上去蛮靠谱的。我们知道，UITableView 是个 UIScrollView，就像平时使用 <code>UIScrollView</code> 一样，加载时指定 contentSize 后它才能根据自己的 bounds、contentInset、contentOffset 等属性共同决定是否可以滑动以及滚动条的长度。而 UITableView 在一开始并不知道自己会被填充多少内容，于是询问 data source 个数和创建 cell，同时询问 delegate 这些 cell 应该显示的高度，这就造成它在加载的时候浪费了多余的计算在屏幕外边的 cell 上。和上面的 <code>rowHeight</code> 很类似，设置这个估算高度有两种方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.tableView.estimatedRowHeight = 88;</span><br><span class="line">// or</span><br><span class="line">- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    // return xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有所不同的是，即使面对种类不同的 cell，我们依然可以使用简单的 <code>estimatedRowHeight</code> 属性赋值，只要整体估算值接近就可以，比如大概有一半 cell 高度是 44， 一半 cell 高度是 88， 那就可以估算一个 66，基本符合预期。</p>
<ol>
<li>设置估算高度后，contentSize.height 根据“cell估算值 x cell个数”计算，这就导致滚动条的大小处于不稳定的状态，contentSize 会随着滚动从估算高度慢慢替换成真实高度，肉眼可见滚动条突然变化甚至“跳跃”。</li>
<li>若是有设计不好的下拉刷新或上拉加载控件，或是 KVO 了 contentSize 或 contentOffset 属性，有可能使表格滑动时跳动。</li>
<li>估算高度设计初衷是好的，让加载速度更快，那凭啥要去侵害滑动的流畅性呢，用户可能对进入页面时多零点几秒加载时间感觉不大，但是滑动时实时计算高度带来的卡顿是明显能体验到的，个人觉得还不如一开始都算好了呢（iOS8更过分，即使都算好了也会边划边计算）</li>
</ol>
<h3 id="UITableView-FDTemplateLayoutCell"><a href="#UITableView-FDTemplateLayoutCell" class="headerlink" title="UITableView+FDTemplateLayoutCell"></a>UITableView+FDTemplateLayoutCell</h3><p>使用<code>UITableView+FDTemplateLayoutCell</code> 无疑是解决算高问题的最佳实践之一，既有 iOS8 self-sizing 功能简单的 API，又可以达到 iOS7 流畅的滑动效果，还保持了最低支持 iOS6。<br>使用起来大概是这样：</p>
<figure class="highlight plain"><figcaption><span><UITableView+FDTemplateLayoutCell.h></span></figcaption><table><tr><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    return [tableView fd_heightForCellWithIdentifier:@&quot;identifer&quot; cacheByIndexPath:indexPath configuration:^(id cell) &#123;</span><br><span class="line">        // 配置 cell 的数据源，和 &quot;cellForRow&quot; 干的事一致，比如：</span><br><span class="line">        cell.entity = self.feedEntities[indexPath.row];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完上面的代码后，你就已经使用到了：</p>
<ul>
<li><strong><em>和每个 UITableViewCell ReuseID 一一对应的 template layout cell</em></strong><br>这个 cell 只为了参加高度计算，不会真的显示到屏幕上；它通过 UITableView 的 <code>-dequeueCellForReuseIdentifier:</code> 方法 lazy 创建并保存，所以要求这个 ReuseID 必须已经被注册到了 UITableView 中，也就是说，要么是 Storyboard 中的原型 cell，要么就是使用了 UITableView 的 <code>-registerClass:forCellReuseIdentifier:</code> 或 <code>-registerNib:forCellReuseIdentifier:</code>其中之一的注册方法。</li>
<li><strong><em>根据 autolayout 约束自动计算高度</em></strong><br>使用了系统在 iOS6 就提供的 API：<code>-systemLayoutSizeFittingSize:</code></li>
<li><strong><em>根据 index path 的一套高度缓存机制</em></strong><br>计算出的高度会自动进行缓存，所以滑动时每个 cell 真正的高度计算只会发生一次，后面的高度询问都会命中缓存，减少了非常可观的多余计算。</li>
<li><strong><em>自动的缓存失效机制</em></strong><br>无须担心你数据源的变化引起的缓存失效，当调用如-reloadData，-deleteRowsAtIndexPaths:withRowAnimation:等任何一个触发 UITableView 刷新机制的方法时，已有的高度缓存将以最小的代价执行失效。如删除一个 indexPath 为 [0:5] 的 cell 时，[0:0] ~ [0:4] 的高度缓存不受影响，而 [0:5] 后面所有的缓存值都向前移动一个位置。自动缓存失效机制对 UITableView 的 9 个公有 API 都进行了分别的处理，以保证没有一次多余的高度计算。</li>
<li><strong><em>预缓存机制</em></strong><br>预缓存机制将在 UITableView 没有滑动的空闲时刻执行，计算和缓存那些还没有显示到屏幕中的 cell，整个缓存过程完全没有感知，这使得完整列表的高度计算既没有发生在加载时，又没有发生在滑动时，同时保证了加载速度和滑动流畅性，下文会着重讲下这块的实现原理。</li>
</ul>
<h3 id="开始使用UITableView-FDTemplateLayoutCell"><a href="#开始使用UITableView-FDTemplateLayoutCell" class="headerlink" title="开始使用UITableView+FDTemplateLayoutCell"></a>开始使用UITableView+FDTemplateLayoutCell</h3><p>如果你觉得这个工具能帮得到你，整合到工程也十分简单。<br>使用 cocoapods：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod search UITableView+FDTemplateLayoutCell</span><br></pre></td></tr></table></figure>
<p>欢迎使用和支持这个工具，有 bug 请随时反馈哦~<br>再复习下 github 地址： <a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS优化</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 常用高效开发宏</title>
    <url>/2015/05/13/iOS-define/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogFB285A52-DDFA-4318-8361-139FC01912C5.png?imageView2/1/w/600/h/200" />
<a id="more"></a>
    宏定义在很多方面都会使用，例如定义高度、判断iOS系统、工具类，还有诸如文件路径、服务端api接口文档。为了对宏能够快速定位和了解其功能，我们最好在定义的时候将其放入特定的头文件中,其主要目的是为程序员在编程时提供一定的方便，并能在一定程度上提高程序的运行效率，又能减少系统开销。

<h2 id="创建宏文件并引入"><a href="#创建宏文件并引入" class="headerlink" title="创建宏文件并引入"></a>创建宏文件并引入</h2><p>因为在 Xcode6以后新建项目的时候不会自动创建 pch 文件了. 那么我们如果想使用全局的宏就要自行创建一个 pch 宏文件, 然后再自行引入</p>
<ul>
<li>Command+N，打开新建文件窗口：ios-&gt;other-&gt;PCH file，创建一个pch文件：“projectname-Prefix.pch”</li>
<li>将building setting中的precompile header选项的路径添加“$(SRCROOT)/项目名称/pch文件名”（例如：$(SRCROOT)/Project/PrefixHeader.pch）</li>
<li>将Precompile Prefix Header为YES，预编译后的pch文件会被缓存起来，可以提高编译速度</li>
<li>编译一下程序，如果有错误检查一下添加的路径是否正确。</li>
</ul>
<h2 id="定义尺寸类的宏"><a href="#定义尺寸类的宏" class="headerlink" title="定义尺寸类的宏"></a>定义尺寸类的宏</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//状态栏高度</span><br><span class="line"><span class="comment">#define STATUS_BAR_HEIGHT 20</span></span><br><span class="line">//NavBar高度</span><br><span class="line"><span class="comment">#define NAVIGATION_BAR_HEIGHT 44</span></span><br><span class="line">//状态栏 ＋ 导航栏 高度</span><br><span class="line"><span class="comment">#define STATUS_AND_NAVIGATION_HEIGHT ((STATUS_BAR_HEIGHT) + (NAVIGATION_BAR_HEIGHT))</span></span><br><span class="line"></span><br><span class="line">//屏幕 rect</span><br><span class="line"><span class="comment">#define SCREEN_RECT ([UIScreen mainScreen].bounds)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define SCREEN_WIDTH ([UIScreen mainScreen].bounds.size.width)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define SCREEN_HEIGHT ([UIScreen mainScreen].bounds.size.height)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define CONTENT_HEIGHT (SCREEN_HEIGHT - NAVIGATION_BAR_HEIGHT - STATUS_BAR_HEIGHT)</span></span><br><span class="line"></span><br><span class="line">//屏幕分辨率</span><br><span class="line"><span class="comment">#define SCREEN_RESOLUTION (SCREEN_WIDTH * SCREEN_HEIGHT * ([UIScreen mainScreen].scale))</span></span><br><span class="line"></span><br><span class="line">//广告栏高度</span><br><span class="line"><span class="comment">#define BANNER_HEIGHT 215</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define STYLEPAGE_HEIGHT 21</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define SMALLTV_HEIGHT 77</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define SMALLTV_WIDTH 110</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define FOLLOW_HEIGHT 220</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define SUBCHANNEL_HEIGHT 62</span></span><br></pre></td></tr></table></figure>
<h2 id="定义沙盒目录文件的宏"><a href="#定义沙盒目录文件的宏" class="headerlink" title="定义沙盒目录文件的宏"></a>定义沙盒目录文件的宏</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//文件目录</span><br><span class="line"><span class="comment">#define kPathTemp                   NSTemporaryDirectory()</span></span><br><span class="line"><span class="comment">#define kPathDocument               [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]</span></span><br><span class="line"><span class="comment">#define kPathCache                  [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) objectAtIndex:0]</span></span><br><span class="line"><span class="comment">#define kPathSearch                 [kPathDocument stringByAppendingPathComponent:@"Search.plist"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define kPathMagazine               [kPathDocument stringByAppendingPathComponent:@"Magazine"]</span></span><br><span class="line"><span class="comment">#define kPathDownloadedMgzs         [kPathMagazine stringByAppendingPathComponent:@"DownloadedMgz.plist"]</span></span><br><span class="line"><span class="comment">#define kPathDownloadURLs           [kPathMagazine stringByAppendingPathComponent:@"DownloadURLs.plist"]</span></span><br><span class="line"><span class="comment">#define kPathOperation              [kPathMagazine stringByAppendingPathComponent:@"Operation.plist"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define kPathSplashScreen           [kPathCache stringByAppendingPathComponent:@"splashScreen"]</span></span><br><span class="line"><span class="comment">#endif</span></span><br></pre></td></tr></table></figure>

<h2 id="工具类的宏"><a href="#工具类的宏" class="headerlink" title="工具类的宏"></a>工具类的宏</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// rgb颜色转换（16进制-&gt;10进制）</span><br><span class="line"><span class="comment">#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0]</span></span><br><span class="line">// 获取RGB颜色</span><br><span class="line"><span class="comment">#define RGBA(r,g,b,a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a]</span></span><br><span class="line"><span class="comment">#define RGB(r,g,b) RGBA(r,g,b,1.0f)</span></span><br><span class="line">//背景色</span><br><span class="line"><span class="comment">#define BACKGROUND_COLOR [UIColor colorWithRed:242.0/255.0 green:236.0/255.0 blue:231.0/255.0 alpha:1.0]</span></span><br><span class="line">//清除背景色</span><br><span class="line"><span class="comment">#define CLEARCOLOR [UIColor clearColor]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#define IsPortrait ([UIApplication sharedApplication].statusBarOrientation == UIInterfaceOrientationPortrait || [UIApplication sharedApplication].statusBarOrientation == UIInterfaceOrientationPortraitUpsideDown)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#define IsNilOrNull(_ref)   (((_ref) == nil) || ([(_ref) isEqual:[NSNull null]]))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//角度转弧度</span><br><span class="line"><span class="comment">#define DEGREES_TO_RADIANS(d) (d * M_PI / 180)</span></span><br><span class="line"></span><br><span class="line">//大于等于7.0的ios版本</span><br><span class="line"><span class="comment">#define iOS7_OR_LATER SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@"7.0")</span></span><br><span class="line"></span><br><span class="line">//大于等于8.0的ios版本</span><br><span class="line"><span class="comment">#define iOS8_OR_LATER SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(@"8.0")</span></span><br><span class="line"></span><br><span class="line">//iOS6时，导航VC中view的起始高度</span><br><span class="line"><span class="comment">#define YH_HEIGHT (iOS7_OR_LATER ? 64:0)</span></span><br><span class="line"></span><br><span class="line">//获取系统时间戳</span><br><span class="line"><span class="comment">#define getCurentTime [NSString stringWithFormat:@"%ld", (long)[[NSDate date] timeIntervalSince1970]]</span></span><br><span class="line">//判断是真机还是模拟器</span><br><span class="line"><span class="comment">#if TARGET_OS_IPHONE</span></span><br><span class="line">//iPhone Device</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#if TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">//iPhone Simulator</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">//定义UIImage对象</span><br><span class="line"><span class="comment">#define IMAGE(A) [UIImage imageWithContentsOfFile:[[NSBundle mainBundle] pathForResource:A ofType:nil]]</span></span><br><span class="line">//定义UIImage对象</span><br><span class="line"><span class="comment">#define ImageNamed(_pointer) [UIImage imageNamed:_pointer]</span></span><br><span class="line">//可拉伸的图片</span><br><span class="line"><span class="comment">#define ResizableImage(name,top,left,bottom,right) [[UIImage imageNamed:name] resizableImageWithCapInsets:UIEdgeInsetsMake(top,left,bottom,right)]</span></span><br><span class="line"><span class="comment">#define ResizableImageWithMode(name,top,left,bottom,right,mode) [[UIImage imageNamed:name] resizableImageWithCapInsets:UIEdgeInsetsMake(top,left,bottom,right) resizingMode:mode]</span></span><br><span class="line">//方正黑体简体字体定义</span><br><span class="line"><span class="comment">#define FONT(F) [UIFont fontWithName:@"FZHTJW--GB1-0" size:F]</span></span><br></pre></td></tr></table></figure>

<h2 id="通知Notification相关的宏"><a href="#通知Notification相关的宏" class="headerlink" title="通知Notification相关的宏"></a>通知Notification相关的宏</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//系统Notification定义</span><br><span class="line"></span><br><span class="line"><span class="comment">#define TNCancelFavoriteProductNotification     @"TNCancelFavoriteProductNotification"      //取消收藏时</span></span><br><span class="line"><span class="comment">#define TNMarkFavoriteProductNotification       @"TNMarkFavoriteProductNotification"        //标记收藏时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define kNotficationDownloadProgressChanged     @"kNotficationDownloadProgressChanged"      //下载进度变化</span></span><br><span class="line"><span class="comment">#define kNotificationPauseDownload              @"kNotificationPauseDownload"               //暂停下载</span></span><br><span class="line"><span class="comment">#define kNotificationStartDownload              @"kNotificationStartDownload"               //开始下载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define kNotificationDownloadSuccess            @"kNotificationDownloadSuccess"             //下载成功</span></span><br><span class="line"><span class="comment">#define kNotificationDownloadFailed             @"kNotificationDownloadFailed"              //下载失败</span></span><br><span class="line"><span class="comment">#define kNotificationDownloadNewMagazine        @"kNotificationDownloadNewMagazine"</span></span><br></pre></td></tr></table></figure>

<h2 id="服务端API接口的宏"><a href="#服务端API接口的宏" class="headerlink" title="服务端API接口的宏"></a>服务端API接口的宏</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//接口名称相关</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef DEBUG</span></span><br><span class="line">//Debug状态下的测试API</span><br><span class="line"><span class="comment">#define API_BASE_URL_STRING     @"http://boys.test.companydomain.com/api/"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">//Release状态下的线上API</span><br><span class="line"><span class="comment">#define API_BASE_URL_STRING     @"http://www.companydomain.com/api/"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">//接口</span><br><span class="line"><span class="comment">#define GET_CONTENT_DETAIL      @"channel/getContentDetail" //获取内容详情(含上一个和下一个)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define GET_COMMENT_LIST        @"comment/getCommentList"   //获取评论列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define COMMENT_LOGIN           @"comment/login"            //获取评论列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define COMMENT_PUBLISH         @"comment/publish"          //发布评论</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define COMMENT_DELETE          @"comment/delComment"       //删除评论</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LOGINOUT                @"common/logout"            //登出</span></span><br></pre></td></tr></table></figure>
<p>这些只是宏的基本用法,了解更多<a href="http://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="noopener">请点击</a></p>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS常用宏</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS简单View动画</title>
    <url>/2015/05/13/iOS-animation/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog6EB3DA3D-F376-4672-BCA3-B52956B5F5A1.png?imageView2/1/w/600/h/200" />
<a id="more"></a>

<pre><code>我们今天介绍的是UIview的animateWithDuration方法</code></pre><h2 id="Animating-Views-with-Block-Objects"><a href="#Animating-Views-with-Block-Objects" class="headerlink" title="Animating Views with Block Objects"></a>Animating Views with Block Objects</h2><ul>
<li><p>动画可以控制持续时间,延迟执行,动画效果和处理完成的回调</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+ animateWithDuration:delay:options:animations:completion:</span><br></pre></td></tr></table></figure>
<p>这个动画改变一个或者多个试图使用指定的持续时间(duration),延迟执行时间(delay),效果的选项(options),动画效果的 block(animations),和动画完成之后的处理(completion)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+ (void)animateWithDuration:(NSTimeInterval)duration</span><br><span class="line">                      delay:(NSTimeInterval)delay</span><br><span class="line">                    options:(UIViewAnimationOptions)options</span><br><span class="line">                 animations:(void (^)(void))animations</span><br><span class="line">                 completion:(void (^)(BOOL finished))completion</span><br></pre></td></tr></table></figure>
</li>
<li><p>动画可以控制持续时间, 动画效果和动画完成的回调</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+ animateWithDuration:animations:completion:</span><br></pre></td></tr></table></figure>
<p>这个动画改变一个或者东哥试图使用的持续时间(duration), 动画效果(animations),和动画完成后的处理(completion)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+ (void)animateWithDuration:(NSTimeInterval)duration</span><br><span class="line">                 animations:(void (^)(void))animations</span><br><span class="line">                 completion:(void (^)(BOOL finished))completion</span><br></pre></td></tr></table></figure></li>
<li><p>动画可以控制持续时间和动画效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+ animateWithDuration:animations:</span><br></pre></td></tr></table></figure>
<p>这个动画改变一个或者多个试图的持续时间(duration)和动画效果(animations)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+ (void)animateWithDuration:(NSTimeInterval)duration</span><br><span class="line">animations:(void (^)(void))animations</span><br></pre></td></tr></table></figure>
<p>CGAffineTransform的使用<br>CATransform3D的使用</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>git简单使用教程</title>
    <url>/2015/05/08/gitUseCourse/</url>
    <content><![CDATA[<img src ="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog3B9D0523-E5B6-4C0C-988F-C5C2B37CDA54.png?imageView2/1/w/600/h/200" />

<a id="more"></a>

<h2 id="git-的基本使用指令"><a href="#git-的基本使用指令" class="headerlink" title="git 的基本使用指令"></a>git 的基本使用指令</h2><pre><code>我们先来简单熟悉一下 git 的简单使用的指令, 作为最基本的 git 指令一定要熟悉</code></pre><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">克隆代码:</span><br><span class="line">git <span class="built_in">clone</span> https://xxxxx/xxx.git</span><br><span class="line"></span><br><span class="line">添加文件:</span><br><span class="line">git add filename</span><br><span class="line"></span><br><span class="line">添加所有文件:</span><br><span class="line">git add -A</span><br><span class="line"></span><br><span class="line">删除文件:</span><br><span class="line">git rm filename</span><br><span class="line"></span><br><span class="line">删除所有文件:</span><br><span class="line">git rm * -r</span><br><span class="line"></span><br><span class="line">查看暂存区状态:</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">提交到本机代码库:</span><br><span class="line">git commit -m ‘提交注释内容’</span><br><span class="line"></span><br><span class="line">推送到远程服务器,比如 Github:</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line">查看自己的远程服务器名称:</span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line">查看提交记录</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">嫌弃显示乱七八糟的，可带上 --pretty=oneline 参数，如 git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line"></span><br><span class="line">回到上一个版本</span><br><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<h2 id="gti-的简单介绍"><a href="#gti-的简单介绍" class="headerlink" title="gti 的简单介绍"></a>gti 的简单介绍</h2><ul>
<li>1991年Linus创建了Linux。</li>
<li>2002年之前，志愿者将源码通过diff的方式发给Linus手动合代码。</li>
<li>2002年Linus选择了商业版本控制系统BitKeeper，这家公司授予Liunx社区免费使用。</li>
<li>2005年Andrew试图破解BitKeeper的协议，导致回收了Linux社区的免费使用权。</li>
<li>Linus可以道歉，但是大牛就是大牛……Linus花了两周时间用C写了一个分布式版本控制系统，这货就是Git！</li>
<li>一个月之内，Liunx系统的代码就完全交由Git来管理，让BitKeeper情何以堪…重新定义了牛逼…</li>
</ul>
<h2 id="Svn和Git有什么差异呢"><a href="#Svn和Git有什么差异呢" class="headerlink" title="Svn和Git有什么差异呢"></a>Svn和Git有什么差异呢</h2><ul>
<li>Svn是集中式的，Git是分布式的</li>
<li>Svn必须联网使用，Git脱离网络一样可用</li>
<li>创建分支时Svn需要将代码复制一份，速度很慢，而Git可在不到1秒的时间完成分支创建</li>
<li>爱的就是Git强大的分支管理功能</li>
</ul>
<h2 id="Git的基础操作"><a href="#Git的基础操作" class="headerlink" title="Git的基础操作"></a>Git的基础操作</h2><ul>
<li>在使用Git之前，需要先设置一下自己的名称以及邮箱地址</li>
<li>使用以下指令来进行设定：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name “CairoLee”</span><br><span class="line">git config --global user.email Rookie_liu@126.com</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="创建全新代码库"><a href="#创建全新代码库" class="headerlink" title="创建全新代码库"></a>创建全新代码库</h2><ul>
<li>创建一个目录，用cd切换到该目录下</li>
<li>创建代码库：<strong><em>git init</em></strong></li>
</ul>
<h2 id="克隆已有代码库"><a href="#克隆已有代码库" class="headerlink" title="克隆已有代码库"></a>克隆已有代码库</h2><ul>
<li>找到一个想放代码库的地方<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 代码库地址 文件夹名称</span><br></pre></td></tr></table></figure>
比如：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://git.bandfuntech/xxx/x.git 目录名</span><br><span class="line">git <span class="built_in">clone</span> git@git.bandfuntech:xxx/x.git 目录名</span><br></pre></td></tr></table></figure></li>
<li>目录名可以不带，不带的话默认用项目名做目录名</li>
</ul>
<h2 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h2><ul>
<li>新建一个文件，如 <strong><em>6666.txt</em></strong> 内容为 <strong><em>Hello World</em></strong></li>
<li>用  <strong><em>git add 6666.txt</em></strong> 来告诉git把此文件纳入版本控制</li>
<li>你可以重复执行多次add指令来添加多个文件，然后再一次性提交到代码仓库中去</li>
<li>你也可以用 <strong><em>bash git add -A</em></strong> 来添加当前目录所有被修改过的文件（增、删、改在git中都认为是修改）</li>
</ul>
<h2 id="确认状态"><a href="#确认状态" class="headerlink" title="确认状态"></a>确认状态</h2><ul>
<li>在工作过程中，随时可用  git status 来确认目前工作区的状态</li>
<li>当文件没被纳入管理时，会显示在<strong><em>Untracked files</em></strong>中</li>
<li>当<strong><em>add</em></strong>后没<strong><em>commit</em></strong>的话，会显示在<strong><em>Changes to be commited</em></strong>中，并且用绿色<strong><em>new file</em></strong>标记显示</li>
<li>修改过的文件没有<strong><em>add</em></strong>过的话，用红色<strong><em>modified</em></strong>标记显示</li>
<li>修改过的文件已经<strong><em>add</em></strong>过的话，用绿色<strong><em>modified</em></strong>标记显示</li>
</ul>
<h2 id="提交到仓库"><a href="#提交到仓库" class="headerlink" title="提交到仓库"></a>提交到仓库</h2><p>使用：    <strong><em>git commit</em></strong>   来提交到仓库<br>若想带上提交描述，可用  <strong>_git commit -m ‘添加6666.txt 文件’ _</strong><br>注意<strong><em>-m</em></strong>命令后面只能是单引号，不能是双引号</p>
]]></content>
      <categories>
        <category>Hexo使用指南</category>
      </categories>
      <tags>
        <tag>Git的使用</tag>
      </tags>
  </entry>
  <entry>
    <title>为-Hexo-主题添加多种图片样式</title>
    <url>/2015/04/28/photo/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogu=2996845824,3058166210&fm=21&gp=0.jpg?imageView2/1/w/600/h/200" />
<a id="more"></a>

<p>从现在开始, 这里面的图片都从七牛上来获取, 现在只是简单的使用, 更多精彩还在使用中!</p>
<p>##主题图片</p>
<p>  从七牛上拿来的床图进行裁剪处理:?imageView2/1/w/600/h/200 </p>
<p>我比较喜欢像36氪那样，一篇文章带一张相关图片。图片能传达的信息永远比文字丰富。当浏览文章列表时，除了标题最吸引人的自然就属文章主题图片了。<br>所以为了方便使用，我创建了一个图片样式叫img-topic，大概是长这样子的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.img-topic</span><br><span class="line">max-width: 300px;</span><br><span class="line">max-height: 1800px;</span><br><span class="line">display: block ;</span><br><span class="line">margin-left: .7em;</span><br><span class="line">margin-right: .7em;</span><br><span class="line">padding: 0;</span><br><span class="line"><span class="built_in">float</span>: right;</span><br><span class="line">clear: right;</span><br></pre></td></tr></table></figure>

<p>在博客中，我更希望主题图片居右，并且点进文章正文后该图片不会显示。我们可以使用HTML语法插入图片。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">"图片路径"</span> class=<span class="string">"img-topic"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>这儿是一张使用img-topic样式后的效果图。</p>
<img src="http://ww2.sinaimg.cn/large/81b78497jw1en8cj4beb9j20s80b8adb.jpg" />

<p>##Logo 图片<br>Logo 图片可以快速定义一篇文章的主题。与主题图片非常类似，只不过 Logo 图片放置的是 Logo ，而且一般比主题图片要小。类似的，Logo 图片也是居右，并且在文章正文中不会显示。<br>关于img-logo的样式如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.img-logo </span><br><span class="line">max-width: 180px;</span><br><span class="line">max-height: 96px;</span><br><span class="line">display: block;</span><br><span class="line">margin-right: .7em;</span><br><span class="line">margin-left: .7em;</span><br><span class="line">padding: 0;</span><br><span class="line"><span class="built_in">float</span>: right;</span><br><span class="line">clear: right;</span><br></pre></td></tr></table></figure>

<p>使用HTML语法插入图片</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">"图片路径"</span> class=<span class="string">"img-logo"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>效果如下图：</p>
<img src="http://ww4.sinaimg.cn/large/81b78497jw1en8cj55warj20se0avgoh.jpg" />


]]></content>
      <categories>
        <category>Hexo使用指南</category>
      </categories>
      <tags>
        <tag>博客使用</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 使用文本编辑的 Markdown 语法</title>
    <url>/2015/04/28/Markdown/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogmarkdown-cheatsheet-syntax-manual.jpg?imageView2/1/w/600/h/200" />
<a id="more"></a>

<p>Markdown 是一种轻量级标记语言，能将文本换成有效的XHTML(或者HTML)文档，它的目标是实现易读易写，成为一种适用于网络的书写语言。</p>
<p>Markdown 语法简洁明了，易于掌握，所以用它来写作是件既效率又舒服的事情。我们所熟知的和一些大型CMS，如Joomla!、Drupal等都能很好的支持Markdown。我是因为写GitHub项目库中的Readme才开始接触Markdown。</p>
<p>Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p>
<h2 id="Headers-标题："><a href="#Headers-标题：" class="headerlink" title="Headers 标题："></a>Headers 标题：</h2><h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><h3 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h3><h4 id="H4"><a href="#H4" class="headerlink" title="H4"></a>H4</h4><h5 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h5><h6 id="H6"><a href="#H6" class="headerlink" title="H6"></a>H6</h6><p>另外，H1和H2还能用以下方式显示：<br>一级标题<br>===</p>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  H1</span></span><br><span class="line"><span class="comment">##  H2</span></span><br><span class="line"><span class="comment">###  H3</span></span><br><span class="line"><span class="comment">####  H4</span></span><br><span class="line"><span class="comment">#####  H5</span></span><br><span class="line"><span class="comment">######  H6</span></span><br><span class="line"></span><br><span class="line">另外，H1和H2还能用以下方式显示：</span><br><span class="line">一级标题</span><br><span class="line">===</span><br><span class="line"></span><br><span class="line">二级标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="Emphasis-文本强调："><a href="#Emphasis-文本强调：" class="headerlink" title="Emphasis 文本强调："></a>Emphasis 文本强调：</h2><p><em>斜体</em> or <em>强调</em><br><strong>加粗</strong> or <strong>加粗</strong><br><strong><em>粗斜体</em></strong> or <strong>_粗斜体</strong></p>
<p>但是，如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号：这是一段* 文本强调 <em>的说明示例。<br>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线（转义符）：*this text is surrounded by literal asterisks\</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*斜体* or _强调_</span><br><span class="line">**加粗** or __加粗__</span><br><span class="line">***粗斜体*** or ___粗斜体__</span><br><span class="line"></span><br><span class="line">但是，如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号：这是一段* 文本强调 *的说明示例。</span><br><span class="line">如果要在文字前后直接插入普通的星号或底线，你可以用反斜线（转义符）：\*this text is surrounded by literal asterisks\*</span><br></pre></td></tr></table></figure>
<h2 id="标题设置"><a href="#标题设置" class="headerlink" title="标题设置"></a>标题设置</h2><p>=第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。<br>=第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）</p>
<h2 id="块注释（blockquote）"><a href="#块注释（blockquote）" class="headerlink" title="块注释（blockquote）"></a>块注释（blockquote）</h2><blockquote>
<blockquote>
<p>通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。）</p>
</blockquote>
</blockquote>
<h2 id="链接（Links）"><a href="#链接（Links）" class="headerlink" title="链接（Links）"></a>链接（Links）</h2><p>Markdown中有两种方式，实现链接，分别为内联方式和引用方式。<br>内联方式：This is an <a href="http://example.com/" target="_blank" rel="noopener">example link</a>.<br>引用方式：<br>I get 10 times more traffic from <a href="http://google.com/" target="_blank" rel="noopener" title="Google">Google</a> than from <a href="http://search.yahoo.com/" target="_blank" rel="noopener" title="Yahoo Search">Yahoo</a> or <a href="http://search.msn.com/" target="_blank" rel="noopener" title="MSN Search">MSN</a>.  </p>
<h2 id="Lists-列表："><a href="#Lists-列表：" class="headerlink" title="Lists 列表："></a>Lists 列表：</h2><p>但是，如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号：这是一段* 文本强调 <em>的说明示例。<br>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线（转义符）：*this text is surrounded by literal asterisks\</em><br>Lists 列表：</p>
<p>Unordered 无序列表：</p>
<ul>
<li>无序列表</li>
<li>子项</li>
<li>子项</li>
</ul>
<ul>
<li>无序列表</li>
<li>子项</li>
<li>子项</li>
</ul>
<ul>
<li>无序列表</li>
<li>子项</li>
<li>子项</li>
</ul>
<p>Ordered 有序列表：</p>
<ol>
<li><p>第一行</p>
</li>
<li><p>第二行</p>
</li>
<li><p>第三行</p>
</li>
<li><p>第一行</p>
</li>
</ol>
<ul>
<li>第二行</li>
<li>第三行</li>
</ul>
<p>组合：</p>
<ul>
<li><p>产品介绍（子项无项目符号）<br>此时子项，要以一个制表符或者4个空格缩进</p>
</li>
<li><p>产品特点</p>
</li>
</ul>
<ol>
<li>特点1</li>
</ol>
<ul>
<li>特点2</li>
<li>特点3</li>
</ul>
<ul>
<li>产品功能</li>
</ul>
<ol>
<li>功能1</li>
</ol>
<ul>
<li>功能2</li>
<li>功能3</li>
</ul>
<p>可有时我们会出现这样的情况，首行内容是以日期或数字开头：2013. 公司年度目标。<br>为了避免也被转化成有序列表，我们可以在”.”前加上反斜杠（转义符）：2013. 公司年度目标。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*斜体* or _强调_</span><br><span class="line">**加粗** or __加粗__</span><br><span class="line">***粗斜体*** or ___粗斜体__</span><br><span class="line"></span><br><span class="line">但是，如果你的 * 和 _ 两边都有空白的话，它们就只会被当成普通的符号：这是一段* 文本强调 *的说明示例。</span><br><span class="line">如果要在文字前后直接插入普通的星号或底线，你可以用反斜线（转义符）：\*this text is surrounded by literal asterisks\*</span><br><span class="line">Lists 列表：</span><br><span class="line"></span><br><span class="line">Unordered 无序列表：</span><br><span class="line">* 无序列表</span><br><span class="line">* 子项</span><br><span class="line">* 子项</span><br><span class="line"></span><br><span class="line">+ 无序列表</span><br><span class="line">+ 子项</span><br><span class="line">+ 子项</span><br><span class="line"></span><br><span class="line">- 无序列表</span><br><span class="line">- 子项</span><br><span class="line">- 子项</span><br><span class="line"></span><br><span class="line">Ordered 有序列表：</span><br><span class="line">1. 第一行</span><br><span class="line">2. 第二行</span><br><span class="line">3. 第三行</span><br><span class="line"></span><br><span class="line">1. 第一行</span><br><span class="line">- 第二行</span><br><span class="line">- 第三行</span><br><span class="line"></span><br><span class="line">组合：</span><br><span class="line">* 产品介绍（子项无项目符号）</span><br><span class="line">此时子项，要以一个制表符或者4个空格缩进</span><br><span class="line"></span><br><span class="line">* 产品特点</span><br><span class="line">1. 特点1</span><br><span class="line">- 特点2</span><br><span class="line">- 特点3</span><br><span class="line">* 产品功能</span><br><span class="line">1. 功能1</span><br><span class="line">- 功能2</span><br><span class="line">- 功能3</span><br><span class="line"></span><br><span class="line">可有时我们会出现这样的情况，首行内容是以日期或数字开头：2013. 公司年度目标。</span><br><span class="line">为了避免也被转化成有序列表，我们可以在<span class="string">"."</span>前加上反斜杠（转义符）：2013\. 公司年度目标。</span><br></pre></td></tr></table></figure>

<h2 id="Links-连接（title为可选项）："><a href="#Links-连接（title为可选项）：" class="headerlink" title="Links 连接（title为可选项）："></a>Links 连接（title为可选项）：</h2><p>Inline-style 内嵌方式：<br><a href="https://www.google.com" target="_blank" rel="noopener" title="title text">link text</a></p>
<p>Reference-style 引用方式：<br>[link text][id]<br>[id]: <a href="https://www.mozilla.org" target="_blank" rel="noopener">https://www.mozilla.org</a> “title text”</p>
<p>Relative reference to a repository file 引用存储文件：<br><a href="../path/file/readme.text" title="title text">link text</a></p>
<p>还能这样使用：<br>[link text][]<br>[link text]: <a href="http://www.reddit.com" target="_blank" rel="noopener">http://www.reddit.com</a></p>
<p>Email 邮件：<br><a href="mailto:&#101;&#120;&#97;&#x6d;&#x70;&#108;&#101;&#x40;&#x65;&#120;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#101;&#120;&#97;&#x6d;&#x70;&#108;&#101;&#x40;&#x65;&#120;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Inline-style 内嵌方式：</span><br><span class="line">[link text](https://www.google.com <span class="string">"title text"</span>)</span><br><span class="line"></span><br><span class="line">Reference-style 引用方式：</span><br><span class="line">[link text][id]</span><br><span class="line">[id]: https://www.mozilla.org <span class="string">"title text"</span></span><br><span class="line"></span><br><span class="line">Relative reference to a repository file 引用存储文件：</span><br><span class="line">[link text](../path/file/readme.text <span class="string">"title text"</span>)</span><br><span class="line"></span><br><span class="line">还能这样使用：</span><br><span class="line">[link text][]</span><br><span class="line">[link text]: http://www.reddit.com</span><br><span class="line"></span><br><span class="line">Email 邮件：</span><br><span class="line">&lt;example@example.com&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hexo使用指南</category>
      </categories>
      <tags>
        <tag>博客使用</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2015/04/25/FirstBlog/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlogEB02567E-4403-47B4-8188-F78A270E3554.png?imageView2/1/w/600/h/200" />
<a id="more"></a>


<h2 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h2><pre><code>在这里要特别感谢李煜哥的无私帮助! </code></pre><h2 id="为什么写博客"><a href="#为什么写博客" class="headerlink" title="为什么写博客"></a>为什么写博客</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul>
<li>从很早的时候就想建立一个属于一个自己的博客!可是由于种种原因都没有搭建起来. 最近看到 在 git 上与 hexo 配合可以搭建一个博客 , 页面整洁大气, 没有过多的花哨, 易于移植, 编写使用Markdown, 不用购买域名空间, 不怕丢失, 看起来好屌的样子,故下定决心来搭建.</li>
<li>最终在李煜哥的大力帮助下, 终于搭建完成. 参照网上的教程, 然后结合 hexo 的文档. 现在想想很简单 ,可是过程中几度放弃了.不过最后还是单间成功了 ,其实过程是很有意思的, 有兴趣的可以自己研究, 网上教程一大把….</li>
<li>其实我原来自己已经有博客了, 是在51CTO.<a href="http://liuyafang.blog.51cto.com" target="_blank" rel="noopener">小刘_Blog</a>, 这些是我之前前期做 iOS 开发来写的一些技术博客. 但是大部分的内容都是复制来的 . 可是我感觉博客的成长都是这么一个过程, 我敢肯定没有开始就可以写出牛逼的博客来. 都是几经磨砺, 才能找对适合自己的地方, 才能找到适合自己的方式.</li>
<li>在这里也不是想写出自己多牛的博客, 更多的用处还是用来记录技术, 写一写自己平时的生活,工作感悟等等吧 . </li>
</ul>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><ul>
<li>终于写到为什么写博客了啊 ,其实我写博客的目的很简单, 一装逼, 二装逼, 三装逼. </li>
<li>其实也不全是为了装逼吧 . 我想着是为了做一个技术博客, 不用太多的围观者, 不用太多的掌声 , 只是默默的写着自己的生活工作罢了!!!</li>
<li>如果非说为什么写博客, 那就如下</li>
<li>记录生活, 在自己的每一天上留下思考和回忆</li>
<li>整理思路, 固话知识, 获得更多更好的想法</li>
<li>分享经验, 将自己的想法,经验与人分享</li>
<li>交流提高, 通过交流产生更多的思考, 无论是生活还是技术</li>
<li>广交朋友, 在这里交到一些朋友, 互相鼓励, 一路同行</li>
</ul>
]]></content>
      <categories>
        <category>成长之路</category>
      </categories>
      <tags>
        <tag>博客使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2015/04/25/hello-world/</url>
    <content><![CDATA[<img src="http://7xisto.com1.z0.glb.clouddn.com/RookieBlog7DF83ACE-6928-4EF0-B73E-10999E750FA3.png?imageView2/1/w/600/h/200" />

<a id="more"></a>

<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>


<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo使用指南</category>
      </categories>
      <tags>
        <tag>博客介绍</tag>
      </tags>
  </entry>
</search>
